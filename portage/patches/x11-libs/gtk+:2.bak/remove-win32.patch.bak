diff --git a/gdk/win32/Makefile.am b/gdk/win32/Makefile.am
deleted file mode 100644
index e3e4608..0000000
--- a/gdk/win32/Makefile.am
+++ /dev/null
@@ -1,82 +0,0 @@
-## Process this file with automake to produce Makefile.in
-include $(top_srcdir)/Makefile.decl
-
-libgdkincludedir = $(includedir)/gtk-2.0/gdk
-
-INCLUDES = \
-	-DG_LOG_DOMAIN=\"Gdk\"	\
-	-DINSIDE_GDK_WIN32	\
-	-I$(top_srcdir)		\
-	-I$(top_srcdir)/gdk	\
-	-I$(top_builddir)/gdk	\
-	$(GTK_DEBUG_FLAGS) 	\
-	$(GDK_DEP_CFLAGS)	\
-	$(GDK_WIN32_EXTRA_CFLAGS)\
-	-DGDK_COMPILATION
-
-LDADDS = $(GDK_DEP_LIBS)
-
-noinst_LTLIBRARIES = libgdk-win32.la
-
-SUBDIRS=rc
-
-EXTRA_DIST += \
-	bdfcursor.c \
-	makefile.msc
-
-libgdk_win32_la_SOURCES = \
-	xcursors.h \
-	gdkapplaunchcontext-win32.c \
-	gdkcolor-win32.c \
-	gdkcursor-win32.c \
-	gdkdisplay-win32.c \
-	gdkdnd-win32.c \
-	gdkdrawable-win32.c \
-	gdkdrawable-win32.h \
-	gdkevents-win32.c \
-	gdkfont-win32.c \
-	gdkgc-win32.c \
-	gdkgeometry-win32.c \
-	gdkglobals-win32.c \
-	gdkim-win32.c \
-	gdkimage-win32.c \
-	gdkinput.c \
-	gdkinput-win32.c \
-	gdkinput-win32.h \
-	gdkkeys-win32.c \
-	gdkmain-win32.c \
-	gdkpixmap-win32.c \
-	gdkpixmap-win32.h \
-	gdkprivate-win32.h \
-	gdkproperty-win32.c \
-	gdkscreen-win32.c \
-	gdkselection-win32.c \
-	gdkspawn-win32.c \
-	gdktestutils-win32.c \
-	gdkvisual-win32.c \
-	gdkwin32.h \
-	gdkwin32keys.h \
-	gdkwin32id.c \
-	gdkwindow-win32.c \
-	gdkwindow-win32.h \
-	wintab.h \
-	pktdef.h
-
-libgdkinclude_HEADERS =		\
-	gdkwin32.h
-
-# -------- MSVC Project Items -----
-MSVCPROJS = gdk-win32
-
-gdk_win32_FILES = $(libgdk_win32_la_SOURCES)
-gdk_win32_EXCLUDES = gdkwin32dummy
-
-gdk_win32_HEADERS_DIR = $(libgdkincludedir)
-gdk_win32_HEADERS_INST = $(libgdkinclude_HEADERS)
-gdk_win32_HEADERS_EXCLUDES = gdkwin32dummy
-
-include $(top_srcdir)/build/Makefile.msvcproj
-
-dist-hook: $(top_builddir)/build/win32/vs9/gdk-win32.vcproj $(top_builddir)/build/win32/vs9/gdk-win32.headers
-
--include $(top_srcdir)/git.mk
diff --git a/gdk/win32/Makefile.in b/gdk/win32/Makefile.in
deleted file mode 100644
index 2899293..0000000
--- a/gdk/win32/Makefile.in
+++ /dev/null
@@ -1,1249 +0,0 @@
-# Makefile.in generated by automake 1.16.5 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2021 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-# GTK+ - The GIMP Toolkit
-
-# Author: Fan, Chun-wei
-# Common Autotools file used to generate Visual Studio 2008+
-# Projects from their templates
-
-# This autotools file, from GLib, can be used in other projects
-# that have Visual Studio build support, and is copied into
-# $(srcroot)/build/.
-
-# * Input variables:
-#
-#   MSVCPROJS - List of Projects that should be generated
-#
-# * Simple tutorial
-#
-# Add this to Makefile.am where your library/program is built:
-#   include $(top_srcdir)/build/Makefile.msvcproj
-#   MSVCPROJS = YourProject (can be multiple projects in a single srcdir)
-#   YourProject_FILES = $(libyourlib_1_0_SOURCES)
-#   YourProject_EXCLUDES = ... # list of sources to exclude, separated by '|', wildcards allowed; use random unsed value if none
-#   YourProject_HEADERS_DIR = $(libyourlibincludedir)
-#   YourProject_HEADERS_INST = $(libyourlib_1_0_HEADERS)
-#   YourProject_HEADERS_EXCLUDES = ... # <list of headers to exclude from installation, separated by '|', wildcards allowed; use random unsed value if none>
-#
-#   dist-hook: \ # (or add to it if it is already there, note the vs9 items will also call the vs10 items in the process)
-#   	$(top_builddir)/build/win32/vs9/YourProject.vcproj	\
-#   	$(top_builddir)/build/win32/vs9/YourProject.headers
-
-# Private functions
-
-
-VPATH = @srcdir@
-am__is_gnu_make = { \
-  if test -z '$(MAKELEVEL)'; then \
-    false; \
-  elif test -n '$(MAKE_HOST)'; then \
-    true; \
-  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
-    true; \
-  else \
-    false; \
-  fi; \
-}
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = gdk/win32
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/introspection.m4 \
-	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
-	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
-	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-DIST_COMMON = $(srcdir)/Makefile.am $(libgdkinclude_HEADERS) \
-	$(am__DIST_COMMON)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-LTLIBRARIES = $(noinst_LTLIBRARIES)
-libgdk_win32_la_LIBADD =
-am_libgdk_win32_la_OBJECTS = gdkapplaunchcontext-win32.lo \
-	gdkcolor-win32.lo gdkcursor-win32.lo gdkdisplay-win32.lo \
-	gdkdnd-win32.lo gdkdrawable-win32.lo gdkevents-win32.lo \
-	gdkfont-win32.lo gdkgc-win32.lo gdkgeometry-win32.lo \
-	gdkglobals-win32.lo gdkim-win32.lo gdkimage-win32.lo \
-	gdkinput.lo gdkinput-win32.lo gdkkeys-win32.lo \
-	gdkmain-win32.lo gdkpixmap-win32.lo gdkproperty-win32.lo \
-	gdkscreen-win32.lo gdkselection-win32.lo gdkspawn-win32.lo \
-	gdktestutils-win32.lo gdkvisual-win32.lo gdkwin32id.lo \
-	gdkwindow-win32.lo
-libgdk_win32_la_OBJECTS = $(am_libgdk_win32_la_OBJECTS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__maybe_remake_depfiles = depfiles
-am__depfiles_remade = ./$(DEPDIR)/gdkapplaunchcontext-win32.Plo \
-	./$(DEPDIR)/gdkcolor-win32.Plo ./$(DEPDIR)/gdkcursor-win32.Plo \
-	./$(DEPDIR)/gdkdisplay-win32.Plo ./$(DEPDIR)/gdkdnd-win32.Plo \
-	./$(DEPDIR)/gdkdrawable-win32.Plo \
-	./$(DEPDIR)/gdkevents-win32.Plo ./$(DEPDIR)/gdkfont-win32.Plo \
-	./$(DEPDIR)/gdkgc-win32.Plo ./$(DEPDIR)/gdkgeometry-win32.Plo \
-	./$(DEPDIR)/gdkglobals-win32.Plo ./$(DEPDIR)/gdkim-win32.Plo \
-	./$(DEPDIR)/gdkimage-win32.Plo ./$(DEPDIR)/gdkinput-win32.Plo \
-	./$(DEPDIR)/gdkinput.Plo ./$(DEPDIR)/gdkkeys-win32.Plo \
-	./$(DEPDIR)/gdkmain-win32.Plo ./$(DEPDIR)/gdkpixmap-win32.Plo \
-	./$(DEPDIR)/gdkproperty-win32.Plo \
-	./$(DEPDIR)/gdkscreen-win32.Plo \
-	./$(DEPDIR)/gdkselection-win32.Plo \
-	./$(DEPDIR)/gdkspawn-win32.Plo \
-	./$(DEPDIR)/gdktestutils-win32.Plo \
-	./$(DEPDIR)/gdkvisual-win32.Plo ./$(DEPDIR)/gdkwin32id.Plo \
-	./$(DEPDIR)/gdkwindow-win32.Plo
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-AM_V_CC = $(am__v_CC_@AM_V@)
-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC      " $@;
-am__v_CC_1 = 
-CCLD = $(CC)
-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CCLD = $(am__v_CCLD_@AM_V@)
-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD    " $@;
-am__v_CCLD_1 = 
-SOURCES = $(libgdk_win32_la_SOURCES)
-DIST_SOURCES = $(libgdk_win32_la_SOURCES)
-RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
-	ctags-recursive dvi-recursive html-recursive info-recursive \
-	install-data-recursive install-dvi-recursive \
-	install-exec-recursive install-html-recursive \
-	install-info-recursive install-pdf-recursive \
-	install-ps-recursive install-recursive installcheck-recursive \
-	installdirs-recursive pdf-recursive ps-recursive \
-	tags-recursive uninstall-recursive
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
-am__installdirs = "$(DESTDIR)$(libgdkincludedir)"
-HEADERS = $(libgdkinclude_HEADERS)
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
-am__recursive_targets = \
-  $(RECURSIVE_TARGETS) \
-  $(RECURSIVE_CLEAN_TARGETS) \
-  $(am__extra_recursive_targets)
-AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
-	distdir distdir-am
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-DIST_SUBDIRS = $(SUBDIRS)
-am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/Makefile.decl \
-	$(top_srcdir)/build/Makefile.msvcproj $(top_srcdir)/depcomp
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-am__relativize = \
-  dir0=`pwd`; \
-  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
-  sed_rest='s,^[^/]*/*,,'; \
-  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
-  sed_butlast='s,/*[^/]*$$,,'; \
-  while test -n "$$dir1"; do \
-    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
-    if test "$$first" != "."; then \
-      if test "$$first" = ".."; then \
-        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
-        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
-      else \
-        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
-        if test "$$first2" = "$$first"; then \
-          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
-        else \
-          dir2="../$$dir2"; \
-        fi; \
-        dir0="$$dir0"/"$$first"; \
-      fi; \
-    fi; \
-    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
-  done; \
-  reldir="$$dir2"
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AS = @AS@
-ATK_PREFIX = @ATK_PREFIX@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-BASE_DEPENDENCIES_CFLAGS = @BASE_DEPENDENCIES_CFLAGS@
-BASE_DEPENDENCIES_LIBS = @BASE_DEPENDENCIES_LIBS@
-CAIRO_BACKEND_CFLAGS = @CAIRO_BACKEND_CFLAGS@
-CAIRO_BACKEND_LIBS = @CAIRO_BACKEND_LIBS@
-CAIRO_PREFIX = @CAIRO_PREFIX@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCAS = @CCAS@
-CCASDEPMODE = @CCASDEPMODE@
-CCASFLAGS = @CCASFLAGS@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CSCOPE = @CSCOPE@
-CTAGS = @CTAGS@
-CUPS_API_MAJOR = @CUPS_API_MAJOR@
-CUPS_API_MINOR = @CUPS_API_MINOR@
-CUPS_CFLAGS = @CUPS_CFLAGS@
-CUPS_CONFIG = @CUPS_CONFIG@
-CUPS_LIBS = @CUPS_LIBS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DB2HTML = @DB2HTML@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
-DIRECTFB_LIBS = @DIRECTFB_LIBS@
-DLLTOOL = @DLLTOOL@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-ETAGS = @ETAGS@
-EXEEXT = @EXEEXT@
-EXE_MANIFEST_ARCHITECTURE = @EXE_MANIFEST_ARCHITECTURE@
-FGREP = @FGREP@
-FILECMD = @FILECMD@
-GAIL_INET_LIBS = @GAIL_INET_LIBS@
-GAIL_LT_CURRENT_MINUS_AGE = @GAIL_LT_CURRENT_MINUS_AGE@
-GAIL_LT_VERSION_INFO = @GAIL_LT_VERSION_INFO@
-GDK_DEP_CFLAGS = @GDK_DEP_CFLAGS@
-GDK_DEP_LIBS = @GDK_DEP_LIBS@
-GDK_EXTRA_CFLAGS = @GDK_EXTRA_CFLAGS@
-GDK_EXTRA_LIBS = @GDK_EXTRA_LIBS@
-GDK_PACKAGES = @GDK_PACKAGES@
-GDK_PIXBUF_CSOURCE = @GDK_PIXBUF_CSOURCE@
-GDK_PIXBUF_LIBS = @GDK_PIXBUF_LIBS@
-GDK_WLIBS = @GDK_WLIBS@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GLIB_CFLAGS = @GLIB_CFLAGS@
-GLIB_COMPILE_RESOURCES = @GLIB_COMPILE_RESOURCES@
-GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GLIB_LIBS = @GLIB_LIBS@
-GLIB_MKENUMS = @GLIB_MKENUMS@
-GLIB_PREFIX = @GLIB_PREFIX@
-GMODULE_CFLAGS = @GMODULE_CFLAGS@
-GMODULE_LIBS = @GMODULE_LIBS@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GOBJECT_QUERY = @GOBJECT_QUERY@
-GREP = @GREP@
-GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_CHECK_PATH = @GTKDOC_CHECK_PATH@
-GTKDOC_DEPS_CFLAGS = @GTKDOC_DEPS_CFLAGS@
-GTKDOC_DEPS_LIBS = @GTKDOC_DEPS_LIBS@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
-GTK_API_VERSION = @GTK_API_VERSION@
-GTK_BINARY_AGE = @GTK_BINARY_AGE@
-GTK_BINARY_VERSION = @GTK_BINARY_VERSION@
-GTK_DEBUG_FLAGS = @GTK_DEBUG_FLAGS@
-GTK_DEP_CFLAGS = @GTK_DEP_CFLAGS@
-GTK_DEP_LIBS = @GTK_DEP_LIBS@
-GTK_EXTRA_CFLAGS = @GTK_EXTRA_CFLAGS@
-GTK_EXTRA_LIBS = @GTK_EXTRA_LIBS@
-GTK_INTERFACE_AGE = @GTK_INTERFACE_AGE@
-GTK_MAJOR_VERSION = @GTK_MAJOR_VERSION@
-GTK_MICRO_VERSION = @GTK_MICRO_VERSION@
-GTK_MINOR_VERSION = @GTK_MINOR_VERSION@
-GTK_PACKAGES = @GTK_PACKAGES@
-GTK_UPDATE_ICON_CACHE = @GTK_UPDATE_ICON_CACHE@
-GTK_VERSION = @GTK_VERSION@
-GTK_XIM_FLAGS = @GTK_XIM_FLAGS@
-HAVE_HTTP_AUTHSTRING = @HAVE_HTTP_AUTHSTRING@
-HTML_DIR = @HTML_DIR@
-INCLUDED_IMMODULE_DEFINE = @INCLUDED_IMMODULE_DEFINE@
-INCLUDED_IMMODULE_OBJ = @INCLUDED_IMMODULE_OBJ@
-INDENT = @INDENT@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTL_MACOSX_LIBS = @INTL_MACOSX_LIBS@
-INTROSPECTION_CFLAGS = @INTROSPECTION_CFLAGS@
-INTROSPECTION_COMPILER = @INTROSPECTION_COMPILER@
-INTROSPECTION_GENERATE = @INTROSPECTION_GENERATE@
-INTROSPECTION_GIRDIR = @INTROSPECTION_GIRDIR@
-INTROSPECTION_LIBS = @INTROSPECTION_LIBS@
-INTROSPECTION_MAKEFILE = @INTROSPECTION_MAKEFILE@
-INTROSPECTION_SCANNER = @INTROSPECTION_SCANNER@
-INTROSPECTION_TYPELIBDIR = @INTROSPECTION_TYPELIBDIR@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBTOOL_EXPORT_OPTIONS = @LIBTOOL_EXPORT_OPTIONS@
-LIB_EXE_MACHINE_FLAG = @LIB_EXE_MACHINE_FLAG@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-LT_CURRENT_MINUS_AGE = @LT_CURRENT_MINUS_AGE@
-LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
-LT_VERSION_INFO = @LT_VERSION_INFO@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MATH_LIB = @MATH_LIB@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANGO_PREFIX = @PANGO_PREFIX@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PERL = @PERL@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-RANLIB = @RANLIB@
-REBUILD = @REBUILD@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WINDRES = @WINDRES@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-XMLCATALOG = @XMLCATALOG@
-XML_CATALOG_FILE = @XML_CATALOG_FILE@
-XSLTPROC = @XSLTPROC@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-gdktarget = @gdktarget@
-gdktargetlib = @gdktargetlib@
-gtktargetlib = @gtktargetlib@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-ms_librarian = @ms_librarian@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-runstatedir = @runstatedir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-GTESTER = gtester		# in $PATH for non-GLIB packages
-GTESTER_REPORT = gtester-report		# in $PATH for non-GLIB packages
-
-# initialize variables for unconditional += appending
-EXTRA_DIST = bdfcursor.c makefile.msc
-TEST_PROGS = 
-
-### testing rules
-
-# Xvfb based test rules
-XVFB = Xvfb -ac -noreset -screen 0 800x600x16
-XIDS = 101 102 103 104 105 106 107 197 199 211 223 227 293 307 308 309 310 311 \
-   491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 \
-   991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 \
-  1008 1009 4703 4721 4723 4729 4733 4751 9973 9974 9975 9976 9977 9978 9979 \
-  9980 9981 9982 9983 9984 9985 9986 9987 9988 9989 9990 9991 9992 9993 9994 \
-  9995 9996 9997 9998 9999
-
-SKIP_GDKTARGET = \
-	test "$(gdktarget)" != "x11" \
-	&& echo "Gtk+Tests:INFO: Skipping GUI tests for non-X11 target."
-
-XVFB_START = \
-	${XVFB} -help 2>/dev/null 1>&2 \
-	&& XID=`for id in $(XIDS) ; do test -e /tmp/.X$$id-lock || { echo $$id; exit 0; }; done; exit 1` \
-	&& { ${XVFB} :$$XID -screen 0 800x600x16 -nolisten tcp -auth /dev/null >/dev/null 2>&1 & \
-	       trap "kill -15 $$! " 0 HUP INT QUIT TRAP USR1 PIPE TERM ; } \
-	|| { echo "Gtk+Tests:ERROR: Failed to start Xvfb environment for X11 target tests."; exit 1; } \
-	&& DISPLAY=:$$XID && export DISPLAY
-
-libgdkincludedir = $(includedir)/gtk-2.0/gdk
-INCLUDES = \
-	-DG_LOG_DOMAIN=\"Gdk\"	\
-	-DINSIDE_GDK_WIN32	\
-	-I$(top_srcdir)		\
-	-I$(top_srcdir)/gdk	\
-	-I$(top_builddir)/gdk	\
-	$(GTK_DEBUG_FLAGS) 	\
-	$(GDK_DEP_CFLAGS)	\
-	$(GDK_WIN32_EXTRA_CFLAGS)\
-	-DGDK_COMPILATION
-
-LDADDS = $(GDK_DEP_LIBS)
-noinst_LTLIBRARIES = libgdk-win32.la
-SUBDIRS = rc
-libgdk_win32_la_SOURCES = \
-	xcursors.h \
-	gdkapplaunchcontext-win32.c \
-	gdkcolor-win32.c \
-	gdkcursor-win32.c \
-	gdkdisplay-win32.c \
-	gdkdnd-win32.c \
-	gdkdrawable-win32.c \
-	gdkdrawable-win32.h \
-	gdkevents-win32.c \
-	gdkfont-win32.c \
-	gdkgc-win32.c \
-	gdkgeometry-win32.c \
-	gdkglobals-win32.c \
-	gdkim-win32.c \
-	gdkimage-win32.c \
-	gdkinput.c \
-	gdkinput-win32.c \
-	gdkinput-win32.h \
-	gdkkeys-win32.c \
-	gdkmain-win32.c \
-	gdkpixmap-win32.c \
-	gdkpixmap-win32.h \
-	gdkprivate-win32.h \
-	gdkproperty-win32.c \
-	gdkscreen-win32.c \
-	gdkselection-win32.c \
-	gdkspawn-win32.c \
-	gdktestutils-win32.c \
-	gdkvisual-win32.c \
-	gdkwin32.h \
-	gdkwin32keys.h \
-	gdkwin32id.c \
-	gdkwindow-win32.c \
-	gdkwindow-win32.h \
-	wintab.h \
-	pktdef.h
-
-libgdkinclude_HEADERS = \
-	gdkwin32.h
-
-
-# -------- MSVC Project Items -----
-MSVCPROJS = gdk-win32
-gdk_win32_FILES = $(libgdk_win32_la_SOURCES)
-gdk_win32_EXCLUDES = gdkwin32dummy
-gdk_win32_HEADERS_DIR = $(libgdkincludedir)
-gdk_win32_HEADERS_INST = $(libgdkinclude_HEADERS)
-gdk_win32_HEADERS_EXCLUDES = gdkwin32dummy
-_proj_name = $(subst /,_,$(subst -,_,$(subst .,_,$(1))))
-_proj_path_raw := $(subst $(abs_top_srcdir),,$(abs_srcdir))
-_proj_path = $(subst /,\\,$(_proj_path_raw))
-_proj_subdir_int = $(subst \\\\,\\,\\$(_proj_path)\\)
-_proj_subdir = $(subst \\.\\,\\,$(_proj_subdir_int))
-_proj_files_raw = $(subst /,\\,$($(_proj_name)_FILES))
-_proj_files = $(subst $(srcdir)\\,,$(subst $(builddir)\\,,$(subst $(top_builddir)\\$(_proj_path)\\,\\,$(_proj_files_raw))))
-_proj_filters = $($(_proj_name)_EXCLUDES)
-_proj_headers_raw = $(subst /,\\,$($(_proj_name)_HEADERS_INST))
-_proj_headers = $(subst $(srcdir)\\,,$(subst $(builddir)\\,,$(subst $(top_builddir)\\$(_proj_path)\\,\\,$(_proj_headers_raw))))
-_proj_headers_excludes = $($(_proj_name)_HEADERS_EXCLUDES)
-_headers_dest_posix = $(subst $(includedir),,$($(_proj_name)_HEADERS_DIR))
-_headers_destdir = $(subst /,\\,$(_headers_dest_posix))
-all: all-recursive
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/Makefile.decl $(top_srcdir)/build/Makefile.msvcproj $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu gdk/win32/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu gdk/win32/Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
-	esac;
-$(top_srcdir)/Makefile.decl $(top_srcdir)/build/Makefile.msvcproj $(am__empty):
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-clean-noinstLTLIBRARIES:
-	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; \
-	locs=`for p in $$list; do echo $$p; done | \
-	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
-	      sort -u`; \
-	test -z "$$locs" || { \
-	  echo rm -f $${locs}; \
-	  rm -f $${locs}; \
-	}
-
-libgdk-win32.la: $(libgdk_win32_la_OBJECTS) $(libgdk_win32_la_DEPENDENCIES) $(EXTRA_libgdk_win32_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK)  $(libgdk_win32_la_OBJECTS) $(libgdk_win32_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkapplaunchcontext-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkcolor-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkcursor-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkdisplay-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkdnd-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkdrawable-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkevents-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkfont-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkgc-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkgeometry-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkglobals-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkim-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkimage-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkinput-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkinput.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkkeys-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkmain-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkpixmap-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkproperty-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkscreen-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkselection-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkspawn-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdktestutils-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkvisual-win32.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkwin32id.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdkwindow-win32.Plo@am__quote@ # am--include-marker
-
-$(am__depfiles_remade):
-	@$(MKDIR_P) $(@D)
-	@echo '# dummy' >$@-t && $(am__mv) $@-t $@
-
-am--depfiles: $(am__depfiles_remade)
-
-.c.o:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
-
-.c.obj:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
-
-.c.lo:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-install-libgdkincludeHEADERS: $(libgdkinclude_HEADERS)
-	@$(NORMAL_INSTALL)
-	@list='$(libgdkinclude_HEADERS)'; test -n "$(libgdkincludedir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(libgdkincludedir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(libgdkincludedir)" || exit 1; \
-	fi; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libgdkincludedir)'"; \
-	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libgdkincludedir)" || exit $$?; \
-	done
-
-uninstall-libgdkincludeHEADERS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(libgdkinclude_HEADERS)'; test -n "$(libgdkincludedir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(libgdkincludedir)'; $(am__uninstall_files_from_dir)
-
-# This directory's subdirectories are mostly independent; you can cd
-# into them and run 'make' without going through this Makefile.
-# To change the values of 'make' variables: instead of editing Makefiles,
-# (1) if the variable is set in 'config.status', edit 'config.status'
-#     (which will cause the Makefiles to be regenerated when you run 'make');
-# (2) otherwise, pass the desired values on the 'make' command line.
-$(am__recursive_targets):
-	@fail=; \
-	if $(am__make_keepgoing); then \
-	  failcom='fail=yes'; \
-	else \
-	  failcom='exit 1'; \
-	fi; \
-	dot_seen=no; \
-	target=`echo $@ | sed s/-recursive//`; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	for subdir in $$list; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    dot_seen=yes; \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done; \
-	if test "$$dot_seen" = "no"; then \
-	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
-	fi; test -z "$$fail"
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-recursive
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
-	  include_option=--etags-include; \
-	  empty_fix=.; \
-	else \
-	  include_option=--include; \
-	  empty_fix=; \
-	fi; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    test ! -f $$subdir/TAGS || \
-	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
-	  fi; \
-	done; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-recursive
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-recursive
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-distdir: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) distdir-am
-
-distdir-am: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    $(am__make_dryrun) \
-	      || test -d "$(distdir)/$$subdir" \
-	      || $(MKDIR_P) "$(distdir)/$$subdir" \
-	      || exit 1; \
-	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
-	    $(am__relativize); \
-	    new_distdir=$$reldir; \
-	    dir1=$$subdir; dir2="$(top_distdir)"; \
-	    $(am__relativize); \
-	    new_top_distdir=$$reldir; \
-	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
-	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
-	    ($(am__cd) $$subdir && \
-	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$$new_top_distdir" \
-	        distdir="$$new_distdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
-		am__skip_mode_fix=: \
-	        distdir) \
-	      || exit 1; \
-	  fi; \
-	done
-	$(MAKE) $(AM_MAKEFLAGS) \
-	  top_distdir="$(top_distdir)" distdir="$(distdir)" \
-	  dist-hook
-check-am: all-am
-	$(MAKE) $(AM_MAKEFLAGS) check-local
-check: check-recursive
-all-am: Makefile $(LTLIBRARIES) $(HEADERS)
-installdirs: installdirs-recursive
-installdirs-am:
-	for dir in "$(DESTDIR)$(libgdkincludedir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-recursive
-install-exec: install-exec-recursive
-install-data: install-data-recursive
-uninstall: uninstall-recursive
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-recursive
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-recursive
-
-clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-recursive
-		-rm -f ./$(DEPDIR)/gdkapplaunchcontext-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkcolor-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkcursor-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkdisplay-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkdnd-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkdrawable-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkevents-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkfont-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkgc-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkgeometry-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkglobals-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkim-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkimage-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkinput-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkinput.Plo
-	-rm -f ./$(DEPDIR)/gdkkeys-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkmain-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkpixmap-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkproperty-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkscreen-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkselection-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkspawn-win32.Plo
-	-rm -f ./$(DEPDIR)/gdktestutils-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkvisual-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkwin32id.Plo
-	-rm -f ./$(DEPDIR)/gdkwindow-win32.Plo
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-recursive
-
-dvi-am:
-
-html: html-recursive
-
-html-am:
-
-info: info-recursive
-
-info-am:
-
-install-data-am: install-libgdkincludeHEADERS
-
-install-dvi: install-dvi-recursive
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-recursive
-
-install-html-am:
-
-install-info: install-info-recursive
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-recursive
-
-install-pdf-am:
-
-install-ps: install-ps-recursive
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-recursive
-		-rm -f ./$(DEPDIR)/gdkapplaunchcontext-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkcolor-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkcursor-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkdisplay-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkdnd-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkdrawable-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkevents-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkfont-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkgc-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkgeometry-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkglobals-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkim-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkimage-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkinput-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkinput.Plo
-	-rm -f ./$(DEPDIR)/gdkkeys-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkmain-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkpixmap-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkproperty-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkscreen-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkselection-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkspawn-win32.Plo
-	-rm -f ./$(DEPDIR)/gdktestutils-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkvisual-win32.Plo
-	-rm -f ./$(DEPDIR)/gdkwin32id.Plo
-	-rm -f ./$(DEPDIR)/gdkwindow-win32.Plo
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-recursive
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-recursive
-
-pdf-am:
-
-ps: ps-recursive
-
-ps-am:
-
-uninstall-am: uninstall-libgdkincludeHEADERS
-
-.MAKE: $(am__recursive_targets) check-am install-am install-strip
-
-.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \
-	am--depfiles check check-am check-local clean clean-generic \
-	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
-	ctags-am dist-hook distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-libgdkincludeHEADERS \
-	install-man install-pdf install-pdf-am install-ps \
-	install-ps-am install-strip installcheck installcheck-am \
-	installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags tags-am uninstall uninstall-am \
-	uninstall-libgdkincludeHEADERS
-
-.PRECIOUS: Makefile
-
-# call as: $(XVFB_START) && someprogram
-
-# test: run all tests in cwd and subdirs
-test: test-cwd test-recurse
-# test-cwd: run tests in cwd
-test-cwd: ${TEST_PROGS}
-	@$(SKIP_GDKTARGET) || test -z "${TEST_PROGS}" || { \
-	  $(XVFB_START) && { set -e; $(TESTS_ENVIRONMENT) ${GTESTER} --verbose ${TEST_PROGS}; }; \
-	}
-# test-report: run tests in subdirs and generate report
-# perf-report: run tests in subdirs with -m perf and generate report
-# full-report: like test-report: with -m perf and -m slow
-test-report perf-report full-report:	${TEST_PROGS}
-	@ ignore_logdir=true ; \
-	  if test -z "$$GTESTER_LOGDIR" ; then \
-	    GTESTER_LOGDIR=`mktemp -d "\`pwd\`/.testlogs-XXXXXX"`; export GTESTER_LOGDIR ; \
-	    ignore_logdir=false ; \
-	  fi ; \
-	  $(SKIP_GDKTARGET) || test -z "${TEST_PROGS}" || { \
-	    case $@ in \
-	    test-report) test_options="-k";; \
-	    perf-report) test_options="-k -m=perf";; \
-	    full-report) test_options="-k -m=perf -m=slow";; \
-	    esac ; \
-	    $(XVFB_START) && { \
-	      set -e; \
-	      if test -z "$$GTESTER_LOGDIR" ; then \
-	        ${GTESTER} --verbose $$test_options -o test-report.xml ${TEST_PROGS} ; \
-	      elif test -n "${TEST_PROGS}" ; then \
-	        ${GTESTER} --verbose $$test_options -o `mktemp "$$GTESTER_LOGDIR/log-XXXXXX"` ${TEST_PROGS} ; \
-	      fi ; \
-	    }; \
-	  }; \
-	  $$ignore_logdir || { \
-	    echo '<?xml version="1.0"?>' > $@.xml ; \
-	    echo '<report-collection>'  >> $@.xml ; \
-	    for lf in `ls -L "$$GTESTER_LOGDIR"/.` ; do \
-	      sed '1,1s/^<?xml\b[^>?]*?>//' <"$$GTESTER_LOGDIR"/"$$lf" >> $@.xml ; \
-	    done ; \
-	    echo >> $@.xml ; \
-	    echo '</report-collection>' >> $@.xml ; \
-	    rm -rf "$$GTESTER_LOGDIR"/ ; \
-	    ${GTESTER_REPORT} --version 2>/dev/null 1>&2 ; test "$$?" != 0 || ${GTESTER_REPORT} $@.xml >$@.html ; \
-	  }
-.PHONY: test test-cwd test-recurse test-report perf-report full-report
-# run make test-cwd as part of make check
-check-local: test-cwd
-
-#
-# Creates Visual Studio 2008/2010 projects from items passed in from autotools files
-# $(1) - Base Name of the MSVC project files (outputs)
-#
-
-define msvcproj-builder
-
-$(top_builddir)/build/win32/vs10/$(1).vcxproj: $(top_builddir)/build/win32/vs9/$(1).vcproj
-$(top_builddir)/build/win32/vs10/$(1).vcxproj.filters: $(top_builddir)/build/win32/vs9/$(1).vcproj
-$(1).sourcefiles: $(top_builddir)/build/win32/vs9/$(1).vcproj
-$(1).vs10.sourcefiles: $(top_builddir)/build/win32/vs9/$(1).vcproj
-$(1).vs10.sourcefiles.filters: $(top_builddir)/build/win32/vs9/$(1).vcproj
-
-$(top_builddir)/build/win32/vs9/$(1).vcproj: Makefile
-	-$(RM) $(top_builddir)/build/win32/vs9/$(1).vcproj
-	-$(RM) $(top_builddir)/build/win32/vs10/$(1).vcxproj
-	-$(RM) $(top_builddir)/build/win32/vs10/$(1).vcxproj.filters
-	-$(RM) $(top_builddir)/build/win32/vs11/$(1).vcxproj
-	-$(RM) $(top_builddir)/build/win32/vs11/$(1).vcxproj.filters
-	-$(RM) $(top_builddir)/build/win32/vs12/$(1).vcxproj
-	-$(RM) $(top_builddir)/build/win32/vs12/$(1).vcxproj.filters
-	-$(RM) $(top_builddir)/build/win32/vs14/$(1).vcxproj
-	-$(RM) $(top_builddir)/build/win32/vs14/$(1).vcxproj.filters
-	-$(RM) $(top_builddir)/build/win32/vs15/$(1).vcxproj
-	-$(RM) $(top_builddir)/build/win32/vs15/$(1).vcxproj.filters
-
-	for F in $(_proj_files); do \
-		case $$$$F in \
-		$(_proj_filters)) \
-			;; \
-		*.c|*.cpp|*.cc|*.cxx) \
-			echo '   <File RelativePath="..\..\..'$(_proj_subdir)$$$$F'" />' >>$(1).sourcefiles && \
-			echo '   <ClCompile Include="..\..\..'$(_proj_subdir)$$$$F'" />' >>$(1).vs10.sourcefiles && \
-			echo '   <ClCompile Include="..\..\..'$(_proj_subdir)$$$$F'"><Filter>Source Files</Filter></ClCompile>' >>$(1).vs10.sourcefiles.filters \
-			;; \
-		esac;	\
-	done
-
-	$(CPP) -P - <$(top_srcdir)/build/win32/vs9/$(1).vcprojin >$(top_builddir)/build/win32/vs9/$(1).vcproj
-	$(CPP) -P - <$(top_srcdir)/build/win32/vs10/$(1).vcxprojin >$(top_builddir)/build/win32/vs10/$(1).vcxproj
-	$(CPP) -P - <$(top_srcdir)/build/win32/vs10/$(1).vcxproj.filtersin >$(top_builddir)/build/win32/vs10/$(1).vcxproj.filters
-	$(RM) $(1).sourcefiles
-	$(RM) $(1).vs10.sourcefiles
-	$(RM) $(1).vs10.sourcefiles.filters
-
-$(top_builddir)/build/win32/vs10/$(1).vs10.headers: $(top_builddir)/build/win32/vs9/$(1).headers
-
-$(top_builddir)/build/win32/vs9/$(1).headers: Makefile
-	-$(RM) $(top_builddir)/build/win32/vs9/$(1).headers
-	-$(RM) $(top_builddir)/build/win32/vs10/$(1).vs10.headers
-
-	for F in $(_proj_headers); do \
-		case $$$$F in \
-		$(_proj_headers_excludes)) \
-			;; \
-		*.h|*.hpp|*.hh|*.hxx) \
-			echo 'copy ..\..\..'$(_proj_subdir)$$$$F' $$$$(CopyDir)\include'$(_headers_destdir)'\'$$$$F'&#x0D;&#x0A;' >>$(top_builddir)/build/win32/vs9/$(1).headers && \
-			echo 'copy ..\..\..'$(_proj_subdir)$$$$F' $$$$(CopyDir)\include'$(_headers_destdir)'\'$$$$F >>$(top_builddir)/build/win32/vs10/$(1).vs10.headers \
-			;; \
-		esac;	\
-	done
-
-endef
-
-$(foreach proj,$(MSVCPROJS),$(eval $(call msvcproj-builder,$(proj))))
-
-dist-hook: $(top_builddir)/build/win32/vs9/gdk-win32.vcproj $(top_builddir)/build/win32/vs9/gdk-win32.headers
-
--include $(top_srcdir)/git.mk
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff --git a/gdk/win32/bdfcursor.c b/gdk/win32/bdfcursor.c
deleted file mode 100644
index 599f365..0000000
--- a/gdk/win32/bdfcursor.c
+++ /dev/null
@@ -1,408 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 2001 Stefan Ondrejicka
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <string.h>
-#include <stdio.h>
-#include <errno.h>
-#include <ctype.h>
-#include <stdlib.h>
-
-#include <glib.h>
-
-typedef struct {
-	gchar	*name;
-	gint	id;
-	gchar	*bitmap;
-	gint	hotx;
-	gint	hoty;
-} font_info_t;
-
-typedef struct {
-	gchar	*name;
-	gint	id;
-	gint	width;
-	gint	height;
-	gint	hotx;
-	gint	hoty;
-	gchar	*data;
-} cursor_info_t;
-
-static GSList *fonts = NULL;
-static GSList *cursors = NULL;
-
-static gint dw,dh;
-
-static gboolean debug = FALSE;
-
-#define HEX(c) (((c) >= '0' && (c) <= '9') ? \
-	((c) - '0') : (toupper(c) - 'A' + 10))
-
-static void print_font(fi)
-font_info_t *fi;
-{
-	int x,y;
-
-	for (y = 0; y < dh; y++)
-	{
-		for (x = 0; x < dw; x++)
-		{
-			printf(fi->bitmap[y*dw+x]? "X" : " ");
-		}
-		printf("\n");
-	}
-}
-
-static void print_cursor(ci)
-cursor_info_t *ci;
-{
-	int x,y;
-
-	for (y = 0; y < ci->height; y++)
-	{
-		printf("/* ");
-		for (x = 0; x < ci->width; x++)
-		{
-			if (ci->hotx == x && ci->hoty == y)
-				printf("o");
-			else
-				switch (ci->data[y*ci->width+x])
-				{
-					case 0:
-						printf(" ");
-					break;
-					case 1:
-						printf(".");
-					break;
-					case 2:
-						printf("X");
-					break;
-				}
-		}
-		printf(" */\n");
-	}
-}
-
-static gint read_bdf_font(fname)
-gchar *fname;
-{
-	FILE *f;
-	gchar line[2048];
-	gint rv = 0;
-	gboolean startchar = FALSE, startbitmap = FALSE;
-	gchar *charname,*p,*bitmap;
-	gint dx = 0,dy = 0;
-	gint w,h,x,y,py;
-	gint id,tmp;
-
-	dw = 0;
-	dh = 0;
-
-	if (!(f = fopen(fname, "r")))
-	{
-		perror(fname);
-		return -1;
-	}
-
-	if (fgets(line, sizeof(line), f) && strncasecmp("STARTFONT ", line, 10))
-	{
-		printf("!BDF font file\n");
-		fclose(f);
-		return -1;
-	}
-	
-	p = line;
-	while (fgets(line, sizeof(line), f))
-	{
-		if (!startchar)
-		{
-			if (!strncasecmp("STARTCHAR ", line, 10))
-			{
-				startchar = TRUE;
-				charname = g_strndup(p + 10,
-					strcspn(p+10, "\r\n"));
-			}
-			else if (!strncasecmp("FONTBOUNDINGBOX ", line, 16))
-				sscanf(p+16, "%d %d %d %d", &dw, &dh, &dx, &dy);
-		}
-		else
-		{
-			if (!strncasecmp("ENDCHAR", line, 7))
-			{
-				font_info_t *nfi;
-
-				if (debug)
-					printf(" %*s*/\n", dw, "");
-				startchar = FALSE;
-				startbitmap = FALSE;
-
-				nfi = g_malloc(sizeof(font_info_t));
-				memset(nfi, '\0', sizeof(font_info_t));
-
-				nfi->name = charname;
-				nfi->id = id;
-				nfi->bitmap = bitmap;
-				nfi->hotx = 0 - dx;
-				nfi->hoty = 0 - dy;
-
-				fonts = g_slist_append(fonts, nfi);
-			}
-			else if (startbitmap)
-			{
-				int px,cx;
-				guchar mask;
-
-				px = x - dx + py * dw;
-				for (cx = 0; cx < w; cx++)
-				{
-					mask = 1 << (3 - (cx % 4));
-
-					bitmap[px+cx] =
-						(mask & HEX(line[cx/4])) != 0;
-
-					if (debug)
-						printf(bitmap[px+cx] ? "X" : " ");
-				}
-				py++;
-				if (debug)
-					printf(" %*s*/\n/* %*s", dw-w, "", dw+dx, "");
-			}
-			else if (!strncasecmp("BBX ", line, 4))
-			{
-				sscanf(p+4, "%d %d %d %d", &w, &h, &x, &y);
-				if (debug)
-					printf("/* %s: */\n/* %*s", charname, dw+dx, "");
-			}
-			else if (!strncasecmp("ENCODING ", line, 9))
-			{
-				if (sscanf(p+9, "%d %d", &tmp, &id) != 2)
-					id = tmp;
-			}
-			else if (!strncasecmp("BITMAP", line, 6))
-			{
-				py = y - dy;
-				startbitmap = TRUE;
-				bitmap = g_malloc(dw*dh);
-				memset(bitmap, '\0', dw*dh);
-			}
-		}
-	}
-
-	if (strncasecmp("ENDFONT", line, 7))
-		rv = -1;
-
-	fclose(f);
-
-	return rv;
-}
-
-static gint font_info_compare(fi, name)
-font_info_t *fi;
-char *name;
-{
-	return strcmp(name, fi->name);
-}
-
-static cursor_info_t *gen_cursor(bmap, mask)
-font_info_t *bmap;
-font_info_t *mask;
-{
-	cursor_info_t *ci;
-	int bx = dw,by = dh,ex = 0,ey = 0;
-	int i,j;
-
-	for (j = 0; j < dh; j++)
-	{
-		gboolean havep = FALSE;
-
-		for (i = 0; i < dw; i++)
-		{
-			if (bmap->bitmap[j*dw+i] || mask->bitmap[j*dw+i])
-			{
-				havep = TRUE;
-				bx = MIN(bx, i);
-				ex = MAX(i+1, ex);
-			}
-		}
-
-		if (havep)
-		{
-			by = MIN(by, j);
-			ey = MAX(ey, j+1);
-		}
-	}
-
-	ci = g_malloc(sizeof(cursor_info_t));
-	ci->name = g_strdup(bmap->name);
-	ci->id = bmap->id;
-
-	ci->width = ex - bx;
-	ci->height = ey - by;
-
-	ci->hotx = bmap->hotx - bx;
-	ci->hoty = ci->height - (bmap->hoty - by);
-
-	ci->data = g_malloc(ci->width * ci->height);
-	memset(ci->data, '\0', ci->width * ci->height);
-
-	for (j = 0; j < ci->height; j++)
-	{
-		for (i = 0; i < ci->width; i++)
-		{
-			int ofs = (by + j) * dw + bx + i;
-
-			ci->data[j*ci->width + i] = mask->bitmap[ofs] *
-				(1 + bmap->bitmap[ofs]);
-		}
-	}
-
-	return ci;
-}
-
-static void compose_cursors_from_fonts()
-{
-	GSList *l;
-
-	for (l = g_slist_copy (fonts); l; l = g_slist_delete_link (l,l))
-	{
-		font_info_t *fi = l->data;
-		gchar *name;
-		GSList *ml;
-
-		name = g_strconcat(fi->name, "_mask", NULL);
-
-		if ((ml = g_slist_find_custom(fonts, name,
-			(GCompareFunc) font_info_compare)))
-		{
-			cursors = g_slist_append(cursors, gen_cursor(l->data, ml->data));
-			fonts = g_slist_remove(fonts, l->data);
-			fonts = g_slist_remove(fonts, ml->data);
-		}
-
-		g_free(name);
-	}
-}
-
-static char *dump_cursor(ci, id)
-cursor_info_t *ci;
-int id;
-{
-	static gchar cdata[8192];
-	gchar *p;
-	gint i;
-	gint c;
-	gboolean flushed;
-
-	sprintf(cdata, "  { \"%s\", %d, %d, %d, %d, %d, \n    \"",
-		ci->name, ci->id, ci->width, ci->height, ci->hotx, ci->hoty);
-	p = cdata + strlen(cdata);
-
-	for (i = 0; i < ci->width * ci->height; i++)
-	{
-		flushed = FALSE;
-
-		if (!(i%4))
-			c = 0;
-
-		c = c << 2;
-
-		c += ci->data[i];
-
-		if ((i % 4) == 3)
-		{
-			flushed = TRUE;
-			sprintf(p, "\\%03o", c);
-			p += strlen(p);
-		}
-
-		if (i > 0 && !(i % 64))
-		{
-			strcpy(p ,"\"\n    \"");
-			p += strlen(p);
-		}
-	}
-	if (!flushed)
-	{
-		sprintf(p, "\\%03o", c);
-		p += strlen(p);
-	}
-
-	strcpy(p, "\" }");
-
-	return cdata;
-}
-
-static int dump_cursors()
-{
-	GSList *ptr;
-	FILE *f = stdout;
-
-	fprintf(f, "static const struct { const gchar *name; gint type; guchar width; guchar height; guchar hotx; guchar hoty; guchar *data; } cursors[] = {\n");
-
-	for (ptr = cursors; ptr; ptr = ptr->next)
-	{
-		if (debug)
-			print_cursor(ptr->data);
-		fprintf(f, "%s, \n", dump_cursor(ptr->data));
-	}
-
-	fprintf(f, "  { NULL, 0, 0, 0, 0, 0, NULL },\n};\n");
-
-	return 0;
-}
-
-gint main(argc, argv)
-gint argc;
-gchar **argv;
-{
-	if (argc != 2)
-	{
-		printf("missing parameters !\n");
-		printf("Usage: %s [BDF cursor file]\n", argv[0]);
-		return -1;
-	}
-
-	if (g_getenv ("BDFCURSOR_DEBUG") != NULL)
-	  debug = TRUE;
-
-	if (read_bdf_font(argv[1]) || !fonts)
-	{
-		printf("Error reading font\n");
-		return 1;
-	}
-
-	compose_cursors_from_fonts();
-
-	if (!cursors)
-	{
-		printf("failed to generate cursors from font!\n");
-		return 1;
-	}
-
-	dump_cursors();
-
-	if (fonts)
-	{
-		printf("some fonts remained unconverted!\n");
-		return 1;
-	}
-
-	return 0;
-}
-
diff --git a/gdk/win32/gdkapplaunchcontext-win32.c b/gdk/win32/gdkapplaunchcontext-win32.c
deleted file mode 100644
index 8a7323c..0000000
--- a/gdk/win32/gdkapplaunchcontext-win32.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* gdkapplaunchcontext-win32.c - Gtk+ implementation for GAppLaunchContext
-
-   Copyright (C) 2007 Red Hat, Inc.
-
-   The Gnome Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The Gnome Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the Gnome Library; see the file COPYING.LIB.  If not,
-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.
-
-   Author: Matthias Clasen <mclasen@redhat.com>
-*/
-
-#include "config.h"
-
-#include "gdkapplaunchcontext.h"
-
-
-char *
-_gdk_windowing_get_startup_notify_id (GAppLaunchContext *context,
-                                      GAppInfo          *info,
-                                      GList             *files)
-{
-	return NULL;
-}
-
-void
-_gdk_windowing_launch_failed (GAppLaunchContext *context,
-                              const char        *startup_notify_id)
-{
-}
-
-
diff --git a/gdk/win32/gdkcolor-win32.c b/gdk/win32/gdkcolor-win32.c
deleted file mode 100644
index 60a8464..0000000
--- a/gdk/win32/gdkcolor-win32.c
+++ /dev/null
@@ -1,1311 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "gdkcolor.h"
-#include "gdkscreen.h"
-#include "gdkinternals.h"
-#include "gdkprivate-win32.h"
-
-static gint     gdk_colormap_match_color (GdkColormap      *cmap,
-					  GdkColor         *color,
-					  const gchar      *available);
-static void     gdk_colormap_init        (GdkColormap      *colormap);
-static void     gdk_colormap_class_init  (GdkColormapClass *klass);
-static void     gdk_colormap_finalize    (GObject          *object);
-
-static gpointer parent_class = NULL;
-
-GType
-gdk_colormap_get_type (void)
-{
-  static GType object_type = 0;
-
-  if (!object_type)
-    {
-      const GTypeInfo object_info =
-      {
-        sizeof (GdkColormapClass),
-        (GBaseInitFunc) NULL,
-        (GBaseFinalizeFunc) NULL,
-        (GClassInitFunc) gdk_colormap_class_init,
-        NULL,           /* class_finalize */
-        NULL,           /* class_data */
-        sizeof (GdkColormap),
-        0,              /* n_preallocs */
-        (GInstanceInitFunc) gdk_colormap_init,
-      };
-      
-      object_type = g_type_register_static (G_TYPE_OBJECT,
-                                            "GdkColormap",
-                                            &object_info, 0);
-    }
-  
-  return object_type;
-}
-
-static void
-gdk_colormap_init (GdkColormap *colormap)
-{
-  GdkColormapPrivateWin32 *private;
-
-  private = g_new (GdkColormapPrivateWin32, 1);
-
-  colormap->windowing_data = private;
-  
-  private->hpal = NULL;
-  private->current_size = 0;
-  private->use = NULL;
-  private->hash = NULL;
-  private->info = NULL;
-
-  colormap->size = 0;
-  colormap->colors = NULL;
-}
-
-static void
-gdk_colormap_class_init (GdkColormapClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  parent_class = g_type_class_peek_parent (klass);
-
-  object_class->finalize = gdk_colormap_finalize;
-}
-
-static void
-gdk_colormap_finalize (GObject *object)
-{
-  GdkColormap *colormap = GDK_COLORMAP (object);
-  GdkColormapPrivateWin32 *private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  GDI_CALL (DeleteObject, (private->hpal));
-
-  if (private->hash)
-    g_hash_table_destroy (private->hash);
-  
-  g_free (private->info);
-  g_free (colormap->colors);
-  g_free (private);
-  
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-/* Mimics XAllocColorCells. Allocate read/write color cells. */
-
-static gboolean
-alloc_color_cells (GdkColormap    *cmap,
-		   gboolean        contig,
-		   unsigned long   plane_masks_return[],
-		   unsigned int    nplanes,
-		   unsigned long   pixels_return[],
-		   unsigned int	   npixels)
-{
-  GdkColormapPrivateWin32 *cmapp = GDK_WIN32_COLORMAP_DATA (cmap);
-  gint i, nfree, iret, start = 0;
-
-  GDK_NOTE (COLORMAP, g_print ("alloc_color_cells: cmap=%p contig=%s npl=%d npix=%d",
-			       cmapp, contig ? "TRUE" : "FALSE",
-			       nplanes, npixels));
-
-  switch (cmap->visual->type)
-    {
-    case GDK_VISUAL_GRAYSCALE:
-    case GDK_VISUAL_PSEUDO_COLOR:
-      nfree = 0;
-      for (i = 0; i < cmap->size && nfree < npixels; i++)
-	if (cmapp->use[i] == GDK_WIN32_PE_AVAILABLE &&
-	    (!contig ||
-	     (nfree == 0 || cmapp->use[i-1] == GDK_WIN32_PE_AVAILABLE)))
-	  {
-	    if (nfree == 0)
-	      start = i;
-	    nfree++;
-	  }
-	else if (contig)
-	  nfree = 0;
-
-      if (npixels > nfree)
-	{
-	  GDK_NOTE (COLORMAP, g_print ("... nope (%d > %d)\n",
-				       npixels, nfree));
-	  return FALSE;
-	}
-      else
-	GDK_NOTE (COLORMAP, g_print ("... ok\n"));
-
-      iret = 0;
-      for (i = start; i < cmap->size && iret < npixels; i++)
-	if (cmapp->use[i] == GDK_WIN32_PE_AVAILABLE)
-	  {
-	    cmapp->use[i] = GDK_WIN32_PE_INUSE;
-	    pixels_return[iret] = i;
-	    iret++;
-	  }
-      g_assert (iret == npixels);
-      break;
-
-    default:
-      g_assert_not_reached ();
-    }
-
-  return TRUE;
-}
-
-/* The following functions are originally from Tk8.0, but heavily
-   modified.  Here are tk's licensing terms. I hope these terms don't
-   conflict with the GNU Lesser General Public License? They
-   shouldn't, as they are looser that the GLPL, yes? */
-
-/*
-This software is copyrighted by the Regents of the University of
-California, Sun Microsystems, Inc., and other parties.  The following
-terms apply to all files associated with the software unless explicitly
-disclaimed in individual files.
-
-The authors hereby grant permission to use, copy, modify, distribute,
-and license this software and its documentation for any purpose, provided
-that existing copyright notices are retained in all copies and that this
-notice is included verbatim in any distributions. No written agreement,
-license, or royalty fee is required for any of the authorized uses.
-Modifications to this software may be copyrighted by their authors
-and need not follow the licensing terms described here, provided that
-the new terms are clearly indicated on the first page of each file where
-they apply.
-
-IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
-FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
-ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
-DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
-THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
-IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
-NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
-MODIFICATIONS.
-
-GOVERNMENT USE: If you are acquiring this software on behalf of the
-U.S. government, the Government shall have only "Restricted Rights"
-in the software and related documentation as defined in the Federal 
-Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
-are acquiring the software on behalf of the Department of Defense, the
-software shall be classified as "Commercial Computer Software" and the
-Government shall have only "Restricted Rights" as defined in Clause
-252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing, the
-authors grant the U.S. Government and others acting in its behalf
-permission to use and distribute the software in accordance with the
-terms specified in this license.
-*/
-
-/* Mimics XAllocColor. Allocate a read-only colormap entry. */
-
-static int
-alloc_color (GdkColormap  *cmap,
-	     PALETTEENTRY *color,
-	     guint        *pixelp)
-{
-  PALETTEENTRY entry, close_entry;
-  COLORREF new_pixel;
-  UINT index;
-  GdkColormapPrivateWin32 *cmapp = GDK_WIN32_COLORMAP_DATA (cmap);
-  gint i;
-    
-  entry = *color;
-  entry.peFlags = 0;
-
-  new_pixel = RGB (entry.peRed, entry.peGreen, entry.peBlue);
-
-  switch (cmap->visual->type)
-    {
-    case GDK_VISUAL_PSEUDO_COLOR:
-      /* Find the nearest existing palette entry. */
-      index = GetNearestPaletteIndex (cmapp->hpal, new_pixel);
-      GetPaletteEntries (cmapp->hpal, index, 1, &close_entry);
-
-      GDK_NOTE (COLORMAP,
-		g_print ("alloc_color: new_pixel=%06lx index=%d=%02x close=%06lx\n",
-			 new_pixel, index, index,
-			 RGB (close_entry.peRed, close_entry.peGreen, close_entry.peBlue)));
-
-      if (new_pixel != RGB (close_entry.peRed, close_entry.peGreen,
-			    close_entry.peBlue))
-	{
-	  /* Not a perfect match. */
-	  if (cmapp->use[index] == GDK_WIN32_PE_AVAILABLE)
-	    {
-	      /* It was a nonused entry anyway, so we can use it, and
-	       * set it to the correct color.
-	       */
-	      GDK_NOTE (COLORMAP, g_print ("... was free\n"));
-	      GDI_CALL (SetPaletteEntries, (cmapp->hpal, index, 1, &entry));
-	    }
-	  else
-	    {
-	      /* The close entry found is in use, so search for a
-	       * available slot.
-	       */
-	      gboolean done = FALSE;
-	      for (i = 0; i < cmap->size; i++)
-		if (cmapp->use[i] == GDK_WIN32_PE_AVAILABLE)
-		  {
-		    /* An available slot, use it. */
-		    GDK_NOTE (COLORMAP,
-			      g_print ("... use free slot %d%s\n",
-				       i, (i >= cmapp->current_size) ?
-				       ", will resize palette" : ""));
-		    if (i >= cmapp->current_size)
-		      {
-			if (!ResizePalette (cmapp->hpal, i + 1))
-			  {
-			    WIN32_GDI_FAILED ("ResizePalette");
-			    break;
-			  }
-			cmapp->current_size = i + 1;
-		      }
-		    if (!SetPaletteEntries (cmapp->hpal, i, 1, &entry))
-		      {
-			WIN32_GDI_FAILED ("SetPaletteEntries");
-			i = cmap->size;
-		      }
-		    else
-		      {
-			done = TRUE;
-			index = i;
-		      }
-		    break;
-		  }
-	      if (!done)
-		{
-		  /* No free slots available, or failed to resize
-		   * palette or set palette entry.
-		   */
-		  GDK_NOTE (COLORMAP, g_print ("... failure\n"));
-		  return FALSE;
-		}
-	    }
-	}
-      else
-	{
-	  /* We got a match, so use it. */
-	}
-
-      *pixelp = index;
-      cmapp->use[index] = GDK_WIN32_PE_INUSE;
-      GDK_NOTE (COLORMAP, g_print ("alloc_color: %p: "
-				   "index=%3d=%02x for %02x %02x %02x: "
-				   "%02x %02x %02x\n",
-				   cmapp->hpal, index, index,
-				   entry.peRed, entry.peGreen, entry.peBlue,
-				   color->peRed, color->peGreen, color->peBlue));
-      return TRUE;
-
-    case GDK_VISUAL_STATIC_COLOR:
-      /* Find the nearest existing palette entry. */
-      index = GetNearestPaletteIndex (cmapp->hpal, new_pixel);
-      GetPaletteEntries (cmapp->hpal, index, 1, &close_entry);
-      *color = close_entry;
-      *pixelp = index;
-      GDK_NOTE (COLORMAP, g_print ("alloc_color %p: "
-				   "index=%3d=%02x for %02x %02x %02x: "
-				   "%02x %02x %02x\n",
-				   cmapp->hpal, index, index,
-				   entry.peRed, entry.peGreen, entry.peBlue,
-				   color->peRed, color->peGreen, color->peBlue));
-      return TRUE;
-
-    case GDK_VISUAL_TRUE_COLOR:
-      /* Determine what color will actually be used on non-colormap systems. */
-
-      *pixelp = GetNearestColor (_gdk_display_hdc, new_pixel);
-      color->peRed = GetRValue (*pixelp);
-      color->peGreen = GetGValue (*pixelp);
-      color->peBlue = GetBValue (*pixelp);
-      return TRUE;
-
-    default:
-      g_assert_not_reached ();
-      return FALSE;
-    }
-}
-
-/* Mimics XFreeColors. */
-
-static void
-free_colors (GdkColormap *cmap,
-	     gulong  	 *pixels,
-	     gint    	  npixels,
-	     gulong  	  planes)
-{
-  PALETTEENTRY pe;
-  GdkColormapPrivateWin32 *cmapp = GDK_WIN32_COLORMAP_DATA (cmap);
-  gint i;
-#ifdef G_ENABLE_DEBUG
-  gint set_black_count = 0;
-#endif
-  gboolean *cleared_entries;
-
-  cleared_entries = g_new0 (gboolean, cmap->size);
-
-  /* We don't have to do anything for non-palette devices. */
-  
-  switch (cmap->visual->type)
-    {
-    case GDK_VISUAL_GRAYSCALE:
-    case GDK_VISUAL_PSEUDO_COLOR:
-      for (i = 0; i < npixels; i++)
-	{
-	  if (pixels[i] >= cmap->size)
-	    ; /* Nothing */
-	  else if (cmapp->use[pixels[i]] == GDK_WIN32_PE_STATIC)
-	    ; /* Nothing either*/
-	  else
-	    {
-	      cmapp->use[pixels[i]] = GDK_WIN32_PE_AVAILABLE;
-	      cleared_entries[pixels[i]] = TRUE;
-	    }
-	}
-      for (i = cmapp->current_size - 1; i >= 0; i--)
-	if (cmapp->use[i] != GDK_WIN32_PE_AVAILABLE)
-	  break;
-      if (i < cmapp->current_size - 1)
-	{
-	  GDK_NOTE (COLORMAP, g_print ("free_colors: hpal=%p resize=%d\n",
-				       cmapp->hpal, i + 1));
-	  if (!ResizePalette (cmapp->hpal, i + 1))
-	    WIN32_GDI_FAILED ("ResizePalette");
-	  else
-	    cmapp->current_size = i + 1;
-	}
-      pe.peRed = pe.peGreen = pe.peBlue = pe.peFlags = 0;
-      for (i = 0; i < cmapp->current_size; i++)
-	{
-	  if (cleared_entries[i])
-	    {
-	      GDI_CALL (SetPaletteEntries, (cmapp->hpal, i, 1, &pe));
-	      GDK_NOTE (COLORMAP, set_black_count++);
-	    }
-	}
-#if 0
-      GDK_NOTE (COLORMAP, _gdk_win32_print_hpalette (cmapp->hpal));
-#else
-      GDK_NOTE (COLORMAP, (set_black_count > 0 ?
-			   g_print ("free_colors: %d (%d) set to black\n",
-				    set_black_count, cmapp->current_size)
-			   : (void) 0));
-#endif
-      g_free (cleared_entries);
-
-      break;
-
-    default:
-      g_assert_not_reached ();
-    }
-}
-
-/* Mimics XCreateColormap. */
-
-static void
-create_colormap (GdkColormap *cmap,
-		 gboolean     writeable)
-{
-  struct {
-    LOGPALETTE pal;
-    PALETTEENTRY pe[256-1];
-  } lp;
-  HPALETTE hpal;
-  GdkColormapPrivateWin32 *cmapp = GDK_WIN32_COLORMAP_DATA (cmap);
-  gint i;
-
-  /* Allocate a starting palette with all the static colors. */
-  hpal = GetStockObject (DEFAULT_PALETTE);
-  lp.pal.palVersion = 0x300;
-  lp.pal.palNumEntries = GetPaletteEntries (hpal, 0, 256, lp.pal.palPalEntry);
-
-  if (cmap->visual->type == GDK_VISUAL_STATIC_COLOR &&
-      cmap->visual->depth == 4)
-    {
-      /* Use only 16 colors */
-      for (i = 8; i < 16; i++)
-	lp.pal.palPalEntry[i] = lp.pal.palPalEntry[i+4];
-      lp.pal.palNumEntries = 16;
-    }
-
-  for (i = 0; i < lp.pal.palNumEntries; i++)
-    lp.pal.palPalEntry[i].peFlags = 0;
-  GDK_NOTE (COLORMAP, (g_print ("Default palette %p: %d entries\n",
-				hpal, lp.pal.palNumEntries),
-		       _gdk_win32_print_paletteentries (lp.pal.palPalEntry,
-						       lp.pal.palNumEntries)));
-  DeleteObject (hpal);
-  
-  /* For writeable colormaps, allow all 256 entries to be set. They won't
-   * set all 256 system palette entries anyhow, of course, but we shouldn't
-   * let the app see that, I think.
-   */
-  if (writeable)
-    cmapp->current_size = 0;
-  else
-    cmapp->current_size = lp.pal.palNumEntries;
-
-  cmapp->private_val = writeable;
-
-  if (!(cmapp->hpal = CreatePalette (&lp.pal)))
-    WIN32_GDI_FAILED ("CreatePalette");
-  else
-    GDK_NOTE (COLORMAP, g_print ("Created palette %p\n", cmapp->hpal));
-
-  switch (cmap->visual->type)
-    {
-    case GDK_VISUAL_PSEUDO_COLOR:
-      cmapp->use = g_new (GdkWin32PalEntryState, cmap->size);
-
-      /* Mark static colors in use. */
-      for (i = 0; i < cmapp->current_size; i++)
-	{
-	  cmapp->use[i] = GDK_WIN32_PE_STATIC;
-	  cmapp->info[i].ref_count = G_MAXUINT/2;
-	}
-      /* Mark rest not in use */
-      for (; i < cmap->size; i++)
-	cmapp->use[i] = GDK_WIN32_PE_AVAILABLE;
-      break;
-
-    default:
-      break;
-    }
-}
-
-static void
-sync_colors (GdkColormap *colormap)
-{
-  PALETTEENTRY *pe;
-  GdkColormapPrivateWin32 *private = GDK_WIN32_COLORMAP_DATA (colormap);
-  gint nlookup;
-  gint i;
-  
-  pe = g_new (PALETTEENTRY, colormap->size);
-  nlookup = GetPaletteEntries (private->hpal, 0, colormap->size, pe);
-	  
-  GDK_NOTE (COLORMAP, (g_print ("sync_colors: %p hpal=%p: %d entries\n",
-				private, private->hpal, nlookup),
-		       _gdk_win32_print_paletteentries (pe, nlookup)));
-	  
-  for (i = 0; i < nlookup; i++)
-    {
-      colormap->colors[i].pixel = i;
-      colormap->colors[i].red = (pe[i].peRed * 65535) / 255;
-      colormap->colors[i].green = (pe[i].peGreen * 65535) / 255;
-      colormap->colors[i].blue = (pe[i].peBlue * 65535) / 255;
-    }
-  
-  for ( ; i < colormap->size; i++)
-    {
-      colormap->colors[i].pixel = i;
-      colormap->colors[i].red = 0;
-      colormap->colors[i].green = 0;
-      colormap->colors[i].blue = 0;
-    }
-  
-  g_free (pe);
-}
-
-GdkColormap*
-gdk_colormap_new (GdkVisual *visual,
-		  gboolean   private_cmap)
-{
-  GdkColormap *colormap;
-  GdkColormapPrivateWin32 *private;
-
-  g_return_val_if_fail (visual != NULL, NULL);
-
-  colormap = g_object_new (gdk_colormap_get_type (), NULL);
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  colormap->visual = visual;
-
-  colormap->size = visual->colormap_size;
-
-  switch (visual->type)
-    {
-    case GDK_VISUAL_GRAYSCALE:
-    case GDK_VISUAL_PSEUDO_COLOR:
-      private->info = g_new0 (GdkColorInfo, colormap->size);
-      colormap->colors = g_new (GdkColor, colormap->size);
-      
-      private->hash = g_hash_table_new ((GHashFunc) gdk_color_hash,
-					(GEqualFunc) gdk_color_equal);
-      
-      create_colormap (colormap, private_cmap);
-
-      if (private_cmap)
-	{
-	  sync_colors (colormap);
-#if 0 /* XXX is this needed or not? Seems redundant */
-	  gdk_colormap_change (colormap, colormap->size);
-#endif
-	}
-      break;
-
-    case GDK_VISUAL_STATIC_GRAY:
-    case GDK_VISUAL_STATIC_COLOR:
-      create_colormap (colormap, FALSE);
-      colormap->colors = g_new (GdkColor, colormap->size);
-      sync_colors (colormap);
-      break;
-
-    case GDK_VISUAL_TRUE_COLOR:
-      break;
-
-    default:
-      g_assert_not_reached ();
-    }
-
-  return colormap;
-}
-
-GdkColormap*
-gdk_screen_get_system_colormap (GdkScreen *screen)
-{
-  static GdkColormap *colormap = NULL;
-  GdkColormapPrivateWin32 *private;
-
-  g_return_val_if_fail (screen == _gdk_screen, NULL);
-
-  if (!colormap)
-    {
-      colormap = g_object_new (gdk_colormap_get_type (), NULL);
-      private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-      colormap->visual = gdk_visual_get_system ();
-
-      colormap->size = colormap->visual->colormap_size;
-
-      private->private_val = FALSE;
-
-      switch (colormap->visual->type)
-	{
-	case GDK_VISUAL_GRAYSCALE:
-	case GDK_VISUAL_PSEUDO_COLOR:
-	  private->info = g_new0 (GdkColorInfo, colormap->size);
-	  private->hash = g_hash_table_new ((GHashFunc) gdk_color_hash,
-					    (GEqualFunc) gdk_color_equal);
-	  /* Fallthrough */
-
-	case GDK_VISUAL_STATIC_GRAY:
-	case GDK_VISUAL_STATIC_COLOR:
-	  create_colormap (colormap, FALSE);
-
-	  colormap->colors = g_new (GdkColor, colormap->size);
-	  sync_colors (colormap);
-	  break;
-
-	case GDK_VISUAL_TRUE_COLOR:
-	  break;
-
-	default:
-	  g_assert_not_reached ();
-	}
-    }
-
-  return colormap;
-}
-
-gint
-gdk_colormap_get_system_size (void)
-{
-  return gdk_colormap_get_system ()->size;
-}
-
-void
-gdk_colormap_change (GdkColormap *colormap,
-		     gint         ncolors)
-{
-  GdkColormapPrivateWin32 *cmapp;
-  PALETTEENTRY *pe;
-  int i;
-
-  g_return_if_fail (GDK_IS_COLORMAP (colormap));
-
-  cmapp = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  GDK_NOTE (COLORMAP, g_print ("gdk_colormap_change: hpal=%p ncolors=%d\n",
-			       cmapp->hpal, ncolors));
-
-  switch (colormap->visual->type)
-    {
-    case GDK_VISUAL_GRAYSCALE:
-    case GDK_VISUAL_PSEUDO_COLOR:
-      pe = g_new (PALETTEENTRY, ncolors);
-
-      for (i = 0; i < ncolors; i++)
-	{
-	  pe[i].peRed = (colormap->colors[i].red >> 8);
-	  pe[i].peGreen = (colormap->colors[i].green >> 8);
-	  pe[i].peBlue = (colormap->colors[i].blue >> 8);
-	  pe[i].peFlags = 0;
-	}
-
-      GDI_CALL (SetPaletteEntries, (cmapp->hpal, 0, ncolors, pe));
-      g_free (pe);
-      break;
-
-    default:
-      break;
-    }
-}
-
-gboolean
-gdk_colors_alloc (GdkColormap   *colormap,
-		  gboolean       contiguous,
-		  gulong        *planes,
-		  gint           nplanes,
-		  gulong        *pixels,
-		  gint           npixels)
-{
-  GdkColormapPrivateWin32 *private;
-  gint return_val;
-  gint i;
-
-  g_return_val_if_fail (GDK_IS_COLORMAP (colormap), FALSE);
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  return_val = alloc_color_cells (colormap, contiguous,
-				  planes, nplanes, pixels, npixels);
-
-  if (return_val)
-    {
-      for (i = 0; i < npixels; i++)
-	{
-	  private->info[pixels[i]].ref_count++;
-	  private->info[pixels[i]].flags |= GDK_COLOR_WRITEABLE;
-	}
-    }
-
-  return return_val != 0;
-}
-
-void
-gdk_colors_free (GdkColormap *colormap,
-		 gulong      *in_pixels,
-		 gint         in_npixels,
-		 gulong       planes)
-{
-  GdkColormapPrivateWin32 *private;
-  gulong *pixels;
-  gint npixels = 0;
-  gint i;
-
-  g_return_if_fail (GDK_IS_COLORMAP (colormap));
-  g_return_if_fail (in_pixels != NULL);
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  if ((colormap->visual->type != GDK_VISUAL_PSEUDO_COLOR) &&
-      (colormap->visual->type != GDK_VISUAL_GRAYSCALE))
-    return;
-  
-  pixels = g_new (gulong, in_npixels);
-
-  for (i = 0; i < in_npixels; i++)
-    {
-      gulong pixel = in_pixels[i];
-      
-      if (private->use[pixel] == GDK_WIN32_PE_STATIC)
-	continue;
-
-      if (private->info[pixel].ref_count)
-	{
-	  private->info[pixel].ref_count--;
-
-	  if (private->info[pixel].ref_count == 0)
-	    {
-	      pixels[npixels++] = pixel;
-	      if (!(private->info[pixel].flags & GDK_COLOR_WRITEABLE))
-		g_hash_table_remove (private->hash, &colormap->colors[pixel]);
-	      private->info[pixel].flags = 0;
-	    }
-	}
-    }
-
-  if (npixels)
-    free_colors (colormap, pixels, npixels, planes);
-
-  g_free (pixels);
-}
-
-void
-gdk_colormap_free_colors (GdkColormap    *colormap,
-			  const GdkColor *colors,
-			  gint            ncolors)
-{
-  gulong *pixels;
-  gint i;
-
-  g_return_if_fail (GDK_IS_COLORMAP (colormap));
-  g_return_if_fail (colors != NULL);
-
-  if ((colormap->visual->type != GDK_VISUAL_PSEUDO_COLOR) &&
-      (colormap->visual->type != GDK_VISUAL_GRAYSCALE))
-    return;
-
-  pixels = g_new (gulong, ncolors);
-
-  for (i = 0; i < ncolors; i++)
-    pixels[i] =  colors[i].pixel;
-
-  gdk_colors_free (colormap, pixels, ncolors, 0);
-
-  g_free (pixels);
-}
-
-/********************
- * Color allocation *
- ********************/
-
-/* Try to allocate a single color using alloc_color. If it succeeds,
- * cache the result in our colormap, and store in ret.
- */
-static gboolean 
-gdk_colormap_alloc1 (GdkColormap *colormap,
-		     GdkColor    *color,
-		     GdkColor    *ret)
-{
-  GdkColormapPrivateWin32 *private;
-  PALETTEENTRY pe;
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  pe.peRed = color->red >> 8;
-  pe.peGreen = color->green >> 8;
-  pe.peBlue = color->blue >> 8;
-
-  if (alloc_color (colormap, &pe, &ret->pixel))
-    {
-      ret->red = (pe.peRed * 65535) / 255;
-      ret->green = (pe.peGreen * 65535) / 255;
-      ret->blue = (pe.peBlue * 65535) / 255;
-      
-      if ((guint) ret->pixel < colormap->size)
-	{
-	  if (private->info[ret->pixel].ref_count) /* got a duplicate */
-	    {
-	    }
-	  else
-	    {
-	      colormap->colors[ret->pixel] = *color;
-	      colormap->colors[ret->pixel].pixel = ret->pixel;
-	      private->info[ret->pixel].ref_count = 1;
-
-	      g_hash_table_insert (private->hash,
-				   &colormap->colors[ret->pixel],
-				   &colormap->colors[ret->pixel]);
-	    }
-	}
-      return TRUE;
-    }
-  return FALSE;
-}
-
-static gint
-gdk_colormap_alloc_colors_writeable (GdkColormap *colormap,
-				     GdkColor    *colors,
-				     gint         ncolors,
-				     gboolean     writeable,
-				     gboolean     best_match,
-				     gboolean    *success)
-{
-  GdkColormapPrivateWin32 *private;
-  gulong *pixels;
-  gboolean status;
-  gint i, index;
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  if (private->private_val)
-    {
-      index = 0;
-      for (i=0; i<ncolors; i++)
-	{
-	  while ((index < colormap->size) &&
-		 (private->info[index].ref_count != 0))
-	    index++;
-	  
-	  if (index < colormap->size)
-	    {
-	      colors[i].pixel = index;
-	      success[i] = TRUE;
-	      private->info[index].ref_count++;
-	      private->info[i].flags |= GDK_COLOR_WRITEABLE;
-	    }
-	  else
-	    break;
-	}
-      return i;
-    }
-  else
-    {
-      pixels = g_new (gulong, ncolors);
-
-      /* Allocation of a writeable color cells */
-      status =  alloc_color_cells (colormap, FALSE, NULL, 0, pixels, ncolors);
-      if (status)
-	{
-	  for (i = 0; i < ncolors; i++)
-	    {
-	      colors[i].pixel = pixels[i];
-	      private->info[pixels[i]].ref_count++;
-	      private->info[pixels[i]].flags |= GDK_COLOR_WRITEABLE;
-	    }
-	}
-      
-      g_free (pixels);
-
-      return status ? ncolors : 0; 
-    }
-}
-
-static gint
-gdk_colormap_alloc_colors_private (GdkColormap *colormap,
-				   GdkColor    *colors,
-				   gint         ncolors,
-				   gboolean     writeable,
-				   gboolean     best_match,
-				   gboolean    *success)
-{
-  GdkColormapPrivateWin32 *cmapp;
-  gint i, index;
-  PALETTEENTRY pe;
-  gint nremaining = 0;
-  
-  cmapp = GDK_WIN32_COLORMAP_DATA (colormap);
-  index = -1;
-
-  /* First, store the colors we have room for */
-
-  index = 0;
-  for (i = 0; i < ncolors; i++)
-    {
-      if (!success[i])
-	{
-	  while ((index < colormap->size) &&
-		 (cmapp->info[index].ref_count != 0))
-	    index++;
-
-	  if (index < colormap->size)
-	    {
-	      if (index >= cmapp->current_size)
-		{
-		  if (!ResizePalette (cmapp->hpal, index + 1))
-		    {
-		      WIN32_GDI_FAILED ("ResizePalette");
-		      nremaining++;
-		    }
-		  else
-		    cmapp->current_size = index + 1;
-		}
-	      if (index < cmapp->current_size)
-		{
-		  pe.peRed = colors[i].red >> 8;
-		  pe.peBlue = colors[i].blue >> 8;
-		  pe.peGreen = colors[i].green >> 8;
-		  pe.peFlags = 0;
-		  
-		  if (!SetPaletteEntries (cmapp->hpal, index, 1, &pe))
-		    {
-		      WIN32_GDI_FAILED ("SetPaletteEntries");
-		      nremaining++;
-		    }
-		  else
-		    {
-		      success[i] = TRUE;
-
-		      colors[i].pixel = index;
-		      colormap->colors[index] = colors[i];
-		      cmapp->info[index].ref_count++;
-		    }
-		}
-	    }
-	  else
-	    nremaining++;
-	}
-    }
-  
-  if (nremaining > 0 && best_match)
-    {
-      /* Get best matches for remaining colors */
-
-      gchar *available = g_new (gchar, colormap->size);
-      for (i = 0; i < colormap->size; i++)
-	available[i] = TRUE;
-
-      for (i=0; i<ncolors; i++)
-	{
-	  if (!success[i])
-	    {
-	      index = gdk_colormap_match_color (colormap, 
-						&colors[i], 
-						available);
-	      if (index != -1)
-		{
-		  colors[i] = colormap->colors[index];
-		  cmapp->info[index].ref_count++;
-
-		  success[i] = TRUE;
-		  nremaining--;
-		}
-	    }
-	}
-      g_free (available);
-    }
-
-  return (ncolors - nremaining);
-}
-
-static gint
-gdk_colormap_alloc_colors_shared (GdkColormap *colormap,
-				  GdkColor    *colors,
-				  gint         ncolors,
-				  gboolean     writeable,
-				  gboolean     best_match,
-				  gboolean    *success)
-{
-  GdkColormapPrivateWin32 *private;
-  gint i, index;
-  gint nremaining = 0;
-  gint nfailed = 0;
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-  index = -1;
-
-  for (i = 0; i < ncolors; i++)
-    {
-      if (!success[i])
-	{
-	  if (gdk_colormap_alloc1 (colormap, &colors[i], &colors[i]))
-	    success[i] = TRUE;
-	  else
-	    nremaining++;
-	}
-    }
-
-
-  if (nremaining > 0 && best_match)
-    {
-      gchar *available = g_new (gchar, colormap->size);
-      for (i = 0; i < colormap->size; i++)
-	available[i] = ((private->info[i].ref_count == 0) ||
-			!(private->info[i].flags & GDK_COLOR_WRITEABLE));
-      while (nremaining > 0)
-	{
-	  for (i = 0; i < ncolors; i++)
-	    {
-	      if (!success[i])
-		{
-		  index = gdk_colormap_match_color (colormap, &colors[i], available);
-		  if (index != -1)
-		    {
-		      if (private->info[index].ref_count)
-			{
-			  private->info[index].ref_count++;
-			  colors[i] = colormap->colors[index];
-			  success[i] = TRUE;
-			  nremaining--;
-			}
-		      else
-			{
-			  if (gdk_colormap_alloc1 (colormap, 
-						   &colormap->colors[index],
-						   &colors[i]))
-			    {
-			      success[i] = TRUE;
-			      nremaining--;
-			      break;
-			    }
-			  else
-			    {
-			      available[index] = FALSE;
-			    }
-			}
-		    }
-		  else
-		    {
-		      nfailed++;
-		      nremaining--;
-		      success[i] = 2; /* flag as permanent failure */
-		    }
-		}
-	    }
-	}
-      g_free (available);
-    }
-
-  /* Change back the values we flagged as permanent failures */
-  if (nfailed > 0)
-    {
-      for (i = 0; i < ncolors; i++)
-	if (success[i] == 2)
-	  success[i] = FALSE;
-      nremaining = nfailed;
-    }
-  
-  return (ncolors - nremaining);
-}
-
-static gint
-gdk_colormap_alloc_colors_pseudocolor (GdkColormap *colormap,
-				       GdkColor    *colors,
-				       gint         ncolors,
-				       gboolean     writeable,
-				       gboolean     best_match,
-				       gboolean    *success)
-{
-  GdkColormapPrivateWin32 *private;
-  GdkColor *lookup_color;
-  gint i;
-  gint nremaining = 0;
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  /* Check for an exact match among previously allocated colors */
-
-  for (i = 0; i < ncolors; i++)
-    {
-      if (!success[i])
-	{
-	  lookup_color = g_hash_table_lookup (private->hash, &colors[i]);
-	  if (lookup_color)
-	    {
-	      private->info[lookup_color->pixel].ref_count++;
-	      colors[i].pixel = lookup_color->pixel;
-	      success[i] = TRUE;
-	    }
-	  else
-	    nremaining++;
-	}
-    }
-
-  /* If that failed, we try to allocate a new color, or approxmiate
-   * with what we can get if best_match is TRUE.
-   */
-  if (nremaining > 0)
-    {
-      if (private->private_val)
-	return gdk_colormap_alloc_colors_private (colormap, colors, ncolors, writeable, best_match, success);
-      else
-	return gdk_colormap_alloc_colors_shared (colormap, colors, ncolors, writeable, best_match, success);
-    }
-  else
-    return 0;
-}
-
-gint
-gdk_colormap_alloc_colors (GdkColormap *colormap,
-			   GdkColor    *colors,
-			   gint         ncolors,
-			   gboolean     writeable,
-			   gboolean     best_match,
-			   gboolean    *success)
-{
-  GdkColormapPrivateWin32 *private;
-  GdkVisual *visual;
-  gint i;
-  gint nremaining = 0;
-  PALETTEENTRY pe;
-
-  g_return_val_if_fail (GDK_IS_COLORMAP (colormap), FALSE);
-  g_return_val_if_fail (colors != NULL, FALSE);
-  g_return_val_if_fail (success != NULL, ncolors);
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  for (i = 0; i < ncolors; i++)
-    success[i] = FALSE;
-
-  switch (colormap->visual->type)
-    {
-    case GDK_VISUAL_PSEUDO_COLOR:
-    case GDK_VISUAL_GRAYSCALE:
-      if (writeable)
-	return gdk_colormap_alloc_colors_writeable (colormap, colors, ncolors,
-						    writeable, best_match, success);
-      else
-	return gdk_colormap_alloc_colors_pseudocolor (colormap, colors, ncolors,
-						    writeable, best_match, success);
-      break;
-
-    case GDK_VISUAL_TRUE_COLOR:
-      visual = colormap->visual;
-
-      for (i = 0; i < ncolors; i++)
-	{
-	  colors[i].pixel =
-	    (((colors[i].red >> (16 - visual->red_prec)) << visual->red_shift) +
-	     ((colors[i].green >> (16 - visual->green_prec)) << visual->green_shift) +
-	     ((colors[i].blue >> (16 - visual->blue_prec)) << visual->blue_shift));
-	  success[i] = TRUE;
-	}
-      break;
-
-    case GDK_VISUAL_STATIC_GRAY:
-    case GDK_VISUAL_STATIC_COLOR:
-      for (i = 0; i < ncolors; i++)
-	{
-	  pe.peRed = colors[i].red >> 8;
-	  pe.peGreen = colors[i].green >> 8;
-	  pe.peBlue = colors[i].blue >> 8;
-	  if (alloc_color (colormap, &pe, &colors[i].pixel))
-	    success[i] = TRUE;
-	  else
-	    nremaining++;
-	}
-      break;
-
-    case GDK_VISUAL_DIRECT_COLOR:
-      g_assert_not_reached ();
-    }
-
-  return nremaining;
-}
-
-void
-gdk_colormap_query_color (GdkColormap *colormap,
-			  gulong       pixel,
-			  GdkColor    *result)
-{
-  GdkVisual *visual;
-
-  g_return_if_fail (GDK_IS_COLORMAP (colormap));
-  
-  visual = gdk_colormap_get_visual (colormap);
-
-  switch (visual->type)
-    {
-    case GDK_VISUAL_DIRECT_COLOR:
-    case GDK_VISUAL_TRUE_COLOR:
-      result->red = 65535. * (double)((pixel & visual->red_mask) >> visual->red_shift) / ((1 << visual->red_prec) - 1);
-      result->green = 65535. * (double)((pixel & visual->green_mask) >> visual->green_shift) / ((1 << visual->green_prec) - 1);
-      result->blue = 65535. * (double)((pixel & visual->blue_mask) >> visual->blue_shift) / ((1 << visual->blue_prec) - 1);
-      break;
-
-    case GDK_VISUAL_STATIC_GRAY:
-    case GDK_VISUAL_GRAYSCALE:
-      result->red = result->green = result->blue = 65535. * (double)pixel/((1<<visual->depth) - 1);
-      break;
-
-    case GDK_VISUAL_STATIC_COLOR:
-    case GDK_VISUAL_PSEUDO_COLOR:
-      result->red = colormap->colors[pixel].red;
-      result->green = colormap->colors[pixel].green;
-      result->blue = colormap->colors[pixel].blue;
-      break;
-
-    default:
-      g_assert_not_reached ();
-      break;
-    }
-}
-
-gboolean
-gdk_color_change (GdkColormap *colormap,
-		  GdkColor    *color)
-{
-  GdkColormapPrivateWin32 *private;
-  PALETTEENTRY pe;
-
-  g_return_val_if_fail (GDK_IS_COLORMAP (colormap), FALSE);
-  g_return_val_if_fail (color != NULL, FALSE);
-
-  private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  if (color->pixel < 0 || color->pixel >= colormap->size)
-    return FALSE;
-
-  if (private->use[color->pixel] == GDK_WIN32_PE_STATIC)
-    return FALSE;
-
-  pe.peRed = color->red >> 8;
-  pe.peGreen = color->green >> 8;
-  pe.peBlue = color->blue >> 8;
-
-  GDI_CALL (SetPaletteEntries, (private->hpal, color->pixel, 1, &pe));
-
-  return TRUE;
-}
-
-static gint
-gdk_colormap_match_color (GdkColormap *cmap,
-			  GdkColor    *color,
-			  const gchar *available)
-{
-  GdkColor *colors;
-  guint sum, min;
-  gint rdiff, gdiff, bdiff;
-  gint i, index;
-
-  g_return_val_if_fail (cmap != NULL, 0);
-  g_return_val_if_fail (color != NULL, 0);
-
-  colors = cmap->colors;
-  min = 3 * (65536);
-  index = -1;
-
-  for (i = 0; i < cmap->size; i++)
-    {
-      if ((!available) || (available && available[i]))
-	{
-	  rdiff = (color->red - colors[i].red);
-	  gdiff = (color->green - colors[i].green);
-	  bdiff = (color->blue - colors[i].blue);
-
-	  sum = ABS (rdiff) + ABS (gdiff) + ABS (bdiff);
-
-	  if (sum < min)
-	    {
-	      index = i;
-	      min = sum;
-	    }
-	}
-    }
-
-  return index;
-}
-
-GdkScreen*
-gdk_colormap_get_screen (GdkColormap *cmap)
-{
-  g_return_val_if_fail (GDK_IS_COLORMAP (cmap), NULL);
-
-  return _gdk_screen;
-}
-
diff --git a/gdk/win32/gdkcursor-win32.c b/gdk/win32/gdkcursor-win32.c
deleted file mode 100644
index 11f32f6..0000000
--- a/gdk/win32/gdkcursor-win32.c
+++ /dev/null
@@ -1,994 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#define GDK_PIXBUF_ENABLE_BACKEND /* Ugly? */
-#include "gdkdisplay.h"
-#include "gdkscreen.h"
-#include "gdkcursor.h"
-#include "gdkprivate-win32.h"
-
-#ifdef __MINGW32__
-#include <w32api.h>
-#endif
-
-#include "xcursors.h"
-
-#if (defined(__MINGW32__) && (__W32API_MAJOR_VERSION < 3 || (__W32API_MAJOR_VERSION == 3 && __W32API_MINOR_VERSION < 8))) || (defined(_MSC_VER) && (WINVER < 0x0500))
-typedef struct { 
-  DWORD        bV5Size; 
-  LONG         bV5Width; 
-  LONG         bV5Height; 
-  WORD         bV5Planes; 
-  WORD         bV5BitCount; 
-  DWORD        bV5Compression; 
-  DWORD        bV5SizeImage; 
-  LONG         bV5XPelsPerMeter; 
-  LONG         bV5YPelsPerMeter; 
-  DWORD        bV5ClrUsed; 
-  DWORD        bV5ClrImportant; 
-  DWORD        bV5RedMask; 
-  DWORD        bV5GreenMask; 
-  DWORD        bV5BlueMask; 
-  DWORD        bV5AlphaMask; 
-  DWORD        bV5CSType; 
-  CIEXYZTRIPLE bV5Endpoints; 
-  DWORD        bV5GammaRed; 
-  DWORD        bV5GammaGreen; 
-  DWORD        bV5GammaBlue; 
-  DWORD        bV5Intent; 
-  DWORD        bV5ProfileData; 
-  DWORD        bV5ProfileSize; 
-  DWORD        bV5Reserved; 
-} BITMAPV5HEADER;
-#endif
-
-static HCURSOR
-hcursor_from_type (GdkCursorType cursor_type)
-{
-  gint i, j, x, y, ofs;
-  HCURSOR rv;
-  gint w, h;
-  guchar *and_plane, *xor_plane;
-
-  if (cursor_type != GDK_BLANK_CURSOR)
-    {
-      for (i = 0; i < G_N_ELEMENTS (cursors); i++)
-	if (cursors[i].type == cursor_type)
-	  break;
-
-      if (i >= G_N_ELEMENTS (cursors) || !cursors[i].name)
-	return NULL;
-
-      /* Use real Win32 cursor if possible */
-      if (cursors[i].builtin)
-	return LoadCursor (NULL, cursors[i].builtin);
-    }
-  
-  w = GetSystemMetrics (SM_CXCURSOR);
-  h = GetSystemMetrics (SM_CYCURSOR);
-
-  and_plane = g_malloc ((w/8) * h);
-  memset (and_plane, 0xff, (w/8) * h);
-  xor_plane = g_malloc ((w/8) * h);
-  memset (xor_plane, 0, (w/8) * h);
-
-  if (cursor_type != GDK_BLANK_CURSOR)
-    {
-
-#define SET_BIT(v,b)  (v |= (1 << b))
-#define RESET_BIT(v,b)  (v &= ~(1 << b))
-
-      for (j = 0, y = 0; y < cursors[i].height && y < h ; y++)
-	{
-	  ofs = (y * w) / 8;
-	  j = y * cursors[i].width;
-	  
-	  for (x = 0; x < cursors[i].width && x < w ; x++, j++)
-	    {
-	      gint pofs = ofs + x / 8;
-	      guchar data = (cursors[i].data[j/4] & (0xc0 >> (2 * (j%4)))) >> (2 * (3 - (j%4)));
-	      gint bit = 7 - (j % cursors[i].width) % 8;
-	      
-	      if (data)
-		{
-		  RESET_BIT (and_plane[pofs], bit);
-		  if (data == 1)
-		    SET_BIT (xor_plane[pofs], bit);
-		}
-	    }
-	}
-
-#undef SET_BIT
-#undef RESET_BIT
-
-      rv = CreateCursor (_gdk_app_hmodule, cursors[i].hotx, cursors[i].hoty,
-			 w, h, and_plane, xor_plane);
-    }
-  else
-    {
-      rv = CreateCursor (_gdk_app_hmodule, 0, 0,
-			 w, h, and_plane, xor_plane);
-    }
-  if (rv == NULL)
-    WIN32_API_FAILED ("CreateCursor");
-  g_free (and_plane);
-  g_free (xor_plane);
-  
-  return rv;
-}
-
-static GdkCursor*
-cursor_new_from_hcursor (HCURSOR       hcursor,
-			 GdkCursorType cursor_type)
-{
-  GdkCursorPrivate *private;
-  GdkCursor *cursor;
-
-  private = g_new (GdkCursorPrivate, 1);
-  private->hcursor = hcursor;
-  cursor = (GdkCursor*) private;
-  cursor->type = cursor_type;
-  cursor->ref_count = 1;
-
-  return cursor;
-}
-
-GdkCursor*
-gdk_cursor_new_for_display (GdkDisplay   *display,
-			    GdkCursorType cursor_type)
-{
-  HCURSOR hcursor;
-
-  g_return_val_if_fail (display == _gdk_display, NULL);
-
-  hcursor = hcursor_from_type (cursor_type);
-
-  if (hcursor == NULL)
-    g_warning ("gdk_cursor_new_for_display: no cursor %d found", cursor_type);
-  else
-    GDK_NOTE (CURSOR, g_print ("gdk_cursor_new_for_display: %d: %p\n",
-			       cursor_type, hcursor));
-
-  return cursor_new_from_hcursor (hcursor, cursor_type);
-}
-
-static gboolean
-color_is_white (const GdkColor *color)
-{
-  return (color->red == 0xFFFF
-	  && color->green == 0xFFFF
-	  && color->blue == 0xFFFF);
-}
-
-GdkCursor*
-gdk_cursor_new_from_pixmap (GdkPixmap      *source,
-			    GdkPixmap      *mask,
-			    const GdkColor *fg,
-			    const GdkColor *bg,
-			    gint            x,
-			    gint            y)
-{
-  GdkPixmapImplWin32 *source_impl, *mask_impl;
-  guchar *source_bits, *mask_bits;
-  gint source_bpl, mask_bpl;
-  HCURSOR hcursor;
-  guchar *p, *q, *xor_mask, *and_mask;
-  gint width, height, cursor_width, cursor_height;
-  guchar residue;
-  gint ix, iy;
-  const gboolean bg_is_white = color_is_white (bg);
-  
-  g_return_val_if_fail (GDK_IS_PIXMAP (source), NULL);
-  g_return_val_if_fail (GDK_IS_PIXMAP (mask), NULL);
-  g_return_val_if_fail (fg != NULL, NULL);
-  g_return_val_if_fail (bg != NULL, NULL);
-
-  /* Flush outstanding GDI ops before accessing pixmap->bits */
-  GdiFlush ();
-
-  source_impl = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (source)->impl);
-  mask_impl = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (mask)->impl);
-
-  g_return_val_if_fail (source_impl->width == mask_impl->width
-			&& source_impl->height == mask_impl->height,
-			NULL);
-  width = source_impl->width;
-  height = source_impl->height;
-  cursor_width = GetSystemMetrics (SM_CXCURSOR);
-  cursor_height = GetSystemMetrics (SM_CYCURSOR);
-
-  g_return_val_if_fail (width <= cursor_width && height <= cursor_height,
-			NULL);
-
-  residue = (1 << ((8-(width%8))%8)) - 1;
-
-  source_bits = source_impl->bits;
-  mask_bits = mask_impl->bits;
-
-  g_return_val_if_fail (GDK_PIXMAP_OBJECT (source)->depth == 1
-  			&& GDK_PIXMAP_OBJECT (mask)->depth == 1,
-			NULL);
-
-  source_bpl = ((width - 1)/32 + 1)*4;
-  mask_bpl = ((mask_impl->width - 1)/32 + 1)*4;
-
-  GDK_NOTE (CURSOR, {
-      g_print ("gdk_cursor_new_from_pixmap: source=%p:\n",
-	       source_impl->parent_instance.handle);
-      for (iy = 0; iy < height; iy++)
-	{
-	  if (iy == 16)
-	    break;
-
-	  p = source_bits + iy*source_bpl;
-	  for (ix = 0; ix < width; ix++)
-	    {
-	      if (ix == 79)
-		break;
-	      g_print ("%c", ".X"[((*p)>>(7-(ix%8)))&1]);
-	      if ((ix%8) == 7)
-		p++;
-	    }
-	  g_print ("\n");
-	}
-      g_print ("...mask=%p:\n", mask_impl->parent_instance.handle);
-      for (iy = 0; iy < height; iy++)
-	{
-	  if (iy == 16)
-	    break;
-
-	  p = mask_bits + iy*source_bpl;
-	  for (ix = 0; ix < width; ix++)
-	    {
-	      if (ix == 79)
-		break;
-	      g_print ("%c", ".X"[((*p)>>(7-(ix%8)))&1]);
-	      if ((ix%8) == 7)
-		p++;
-	    }
-	  g_print ("\n");
-	}
-    });
-
-  /* Such complex bit manipulation for this simple task, sigh.
-   * The X cursor and Windows cursor concepts are quite different.
-   * We assume here that we are always called with fg == black and
-   * bg == white, *or* the other way around. Random colours won't work.
-   * (Well, you will get a cursor, but not in those colours.)
-   */
-
-  /* Note: The comments below refer to the case fg==black and
-   * bg==white, as that was what was implemented first. The fg==white
-   * (the "if (fg->pixel)" branches) case was added later.
-   */
-
-  /* First set masked-out source bits, as all source bits matter on Windoze.
-   * As we invert them below, they will be clear in the final xor_mask.
-   */
-  for (iy = 0; iy < height; iy++)
-    {
-      p = source_bits + iy*source_bpl;
-      q = mask_bits + iy*mask_bpl;
-      
-      for (ix = 0; ix < ((width-1)/8+1); ix++)
-	if (bg_is_white)
-	  *p++ |= ~(*q++);
-	else
-	  *p++ &= *q++;
-    }
-
-  /* XOR mask is initialized to zero */
-  xor_mask = g_malloc0 (cursor_width/8 * cursor_height);
-
-  for (iy = 0; iy < height; iy++)
-    {
-      p = source_bits + iy*source_bpl;
-      q = xor_mask + iy*cursor_width/8;
-
-      for (ix = 0; ix < ((width-1)/8+1); ix++)
-	if (bg_is_white)
-	  *q++ = ~(*p++);
-	else
-	  *q++ = *p++;
-
-      q[-1] &= ~residue;	/* Clear left-over bits */
-    }
-      
-  /* AND mask is initialized to ones */
-  and_mask = g_malloc (cursor_width/8 * cursor_height);
-  memset (and_mask, 0xFF, cursor_width/8 * cursor_height);
-
-  for (iy = 0; iy < height; iy++)
-    {
-      p = mask_bits + iy*mask_bpl;
-      q = and_mask + iy*cursor_width/8;
-
-      for (ix = 0; ix < ((width-1)/8+1); ix++)
-	*q++ = ~(*p++);
-
-      q[-1] |= residue;	/* Set left-over bits */
-    }
-      
-  hcursor = CreateCursor (_gdk_app_hmodule, x, y, cursor_width, cursor_height,
-			  and_mask, xor_mask);
-
-  GDK_NOTE (CURSOR, g_print ("gdk_cursor_new_from_pixmap: "
-			     "%p (%dx%d) %p (%dx%d) = %p (%dx%d)\n",
-			     GDK_PIXMAP_HBITMAP (source),
-			     source_impl->width, source_impl->height,
-			     GDK_PIXMAP_HBITMAP (mask),
-			     mask_impl->width, mask_impl->height,
-			     hcursor, cursor_width, cursor_height));
-
-  g_free (xor_mask);
-  g_free (and_mask);
-
-  return cursor_new_from_hcursor (hcursor, GDK_CURSOR_IS_PIXMAP);
-}
-
-/* FIXME: The named cursors below are presumably not really useful, as
- * the names are Win32-specific. No GTK+ application developed on Unix
- * (and most cross-platform GTK+ apps are developed on Unix) is going
- * to look for cursors under these Win32 names anyway.
- *
- * Would the following make any sense: The ms-windows theme engine
- * calls some (to-be-defined private) API here in gdk/win32 to
- * register the relevant cursors used by the currently active XP
- * visual style under the names that libgtk uses to look for them
- * ("color-picker", "dnd-ask", "dnd-copy", etc), and then when libgtk
- * asks for those we return the ones registered by the ms-windows
- * theme engine, if any.
- */
-
-static struct {
-  char *name;
-  char *id;
-} default_cursors[] = {
-  { "appstarting", IDC_APPSTARTING },
-  { "arrow", IDC_ARROW },
-  { "cross", IDC_CROSS },
-#ifdef IDC_HAND
-  { "hand",  IDC_HAND },
-#endif
-  { "help",  IDC_HELP },
-  { "ibeam", IDC_IBEAM },
-  { "sizeall", IDC_SIZEALL },
-  { "sizenesw", IDC_SIZENESW },
-  { "sizens", IDC_SIZENS },
-  { "sizenwse", IDC_SIZENWSE },
-  { "sizewe", IDC_SIZEWE },
-  { "uparrow", IDC_UPARROW },
-  { "wait", IDC_WAIT }
-};
-
-GdkCursor*  
-gdk_cursor_new_from_name (GdkDisplay  *display,
-			  const gchar *name)
-{
-  HCURSOR hcursor = NULL;
-  int i;
-
-  g_return_val_if_fail (display == _gdk_display, NULL);
-
-  for (i = 0; i < G_N_ELEMENTS(default_cursors); i++)
-    {
-      if (0 == strcmp(default_cursors[i].name, name))
-        hcursor = LoadCursor (NULL, default_cursors[i].id);
-    }
-  /* allow to load named cursor resources linked into the executable */
-  if (!hcursor)
-    hcursor = LoadCursor (_gdk_app_hmodule, name);
-
-  if (hcursor)
-    return cursor_new_from_hcursor (hcursor, GDK_X_CURSOR);
-
-  return NULL;
-}
-
-void
-_gdk_cursor_destroy (GdkCursor *cursor)
-{
-  GdkCursorPrivate *private;
-
-  g_return_if_fail (cursor != NULL);
-  private = (GdkCursorPrivate *) cursor;
-
-  GDK_NOTE (CURSOR, g_print ("_gdk_cursor_destroy: %p\n",
-			     (cursor->type == GDK_CURSOR_IS_PIXMAP) ? private->hcursor : 0));
-
-  if (GetCursor () == private->hcursor)
-    SetCursor (NULL);
-
-  if (!DestroyCursor (private->hcursor))
-    WIN32_API_FAILED ("DestroyCursor");
-
-  g_free (private);
-}
-
-GdkDisplay *
-gdk_cursor_get_display (GdkCursor *cursor)
-{
-  return gdk_display_get_default ();
-}
-
-GdkPixbuf *
-gdk_win32_icon_to_pixbuf_libgtk_only (HICON hicon)
-{
-  GdkPixbuf *pixbuf = NULL;
-  ICONINFO ii;
-  struct
-  {
-    BITMAPINFOHEADER bi;
-    RGBQUAD colors[2];
-  } bmi;
-  HDC hdc;
-  guchar *pixels, *bits;
-  gchar buf[32];
-  gint rowstride, x, y, w, h;
-
-  if (!GDI_CALL (GetIconInfo, (hicon, &ii)))
-    return NULL;
-
-  if (!(hdc = CreateCompatibleDC (NULL)))
-    {
-      WIN32_GDI_FAILED ("CreateCompatibleDC");
-      goto out0;
-    }
-
-  memset (&bmi, 0, sizeof (bmi));
-  bmi.bi.biSize = sizeof (bmi.bi);
-
-  if (ii.hbmColor != NULL)
-    {
-      /* Colour cursor */
-
-      gboolean no_alpha;
-      
-      if (!GDI_CALL (GetDIBits, (hdc, ii.hbmColor, 0, 1, NULL, (BITMAPINFO *)&bmi, DIB_RGB_COLORS)))
-	goto out1;
-
-      w = bmi.bi.biWidth;
-      h = bmi.bi.biHeight;
-
-      bmi.bi.biBitCount = 32;
-      bmi.bi.biCompression = BI_RGB;
-      bmi.bi.biHeight = -h;
-
-      bits = g_malloc0 (4 * w * h);
-      
-      /* color data */
-      if (!GDI_CALL (GetDIBits, (hdc, ii.hbmColor, 0, h, bits, (BITMAPINFO *)&bmi, DIB_RGB_COLORS)))
-	goto out2;
-
-      pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, w, h);
-      pixels = gdk_pixbuf_get_pixels (pixbuf);
-      rowstride = gdk_pixbuf_get_rowstride (pixbuf);
-      no_alpha = TRUE;
-      for (y = 0; y < h; y++)
-	{
-	  for (x = 0; x < w; x++)
-	    {
-	      pixels[2] = bits[(x+y*w) * 4];
-	      pixels[1] = bits[(x+y*w) * 4 + 1];
-	      pixels[0] = bits[(x+y*w) * 4 + 2];
-	      pixels[3] = bits[(x+y*w) * 4 + 3];
-	      if (no_alpha && pixels[3] > 0)
-		no_alpha = FALSE;
-	      pixels += 4;
-	    }
-	  pixels += (w * 4 - rowstride);
-	}
-
-      /* mask */
-      if (no_alpha &&
-	  GDI_CALL (GetDIBits, (hdc, ii.hbmMask, 0, h, bits, (BITMAPINFO *)&bmi, DIB_RGB_COLORS)))
-	{
-	  pixels = gdk_pixbuf_get_pixels (pixbuf);
-	  for (y = 0; y < h; y++)
-	    {
-	      for (x = 0; x < w; x++)
-		{
-		  pixels[3] = 255 - bits[(x + y * w) * 4];
-		  pixels += 4;
-		}
-	      pixels += (w * 4 - rowstride);
-	    }
-	}
-    }
-  else
-    {
-      /* B&W cursor */
-
-      int bpl;
-
-      if (!GDI_CALL (GetDIBits, (hdc, ii.hbmMask, 0, 0, NULL, (BITMAPINFO *)&bmi, DIB_RGB_COLORS)))
-	goto out1;
-
-      w = bmi.bi.biWidth;
-      h = ABS (bmi.bi.biHeight) / 2;
-      
-      bits = g_malloc0 (4 * w * h);
-      
-      /* masks */
-      if (!GDI_CALL (GetDIBits, (hdc, ii.hbmMask, 0, h*2, bits, (BITMAPINFO *)&bmi, DIB_RGB_COLORS)))
-	goto out2;
-
-      pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, w, h);
-      pixels = gdk_pixbuf_get_pixels (pixbuf);
-      rowstride = gdk_pixbuf_get_rowstride (pixbuf);
-      bpl = ((w-1)/32 + 1)*4;
-#if 0
-      for (y = 0; y < h*2; y++)
-	{
-	  for (x = 0; x < w; x++)
-	    {
-	      const gint bit = 7 - (x % 8);
-	      printf ("%c ", ((bits[bpl*y+x/8])&(1<<bit)) ? ' ' : 'X');
-	    }
-	  printf ("\n");
-	}
-#endif
-
-      for (y = 0; y < h; y++)
-	{
-	  const guchar *andp, *xorp;
-	  if (bmi.bi.biHeight < 0)
-	    {
-	      andp = bits + bpl*y;
-	      xorp = bits + bpl*(h+y);
-	    }
-	  else
-	    {
-	      andp = bits + bpl*(h-y-1);
-	      xorp = bits + bpl*(h+h-y-1);
-	    }
-	  for (x = 0; x < w; x++)
-	    {
-	      const gint bit = 7 - (x % 8);
-	      if ((*andp) & (1<<bit))
-		{
-		  if ((*xorp) & (1<<bit))
-		    pixels[2] = pixels[1] = pixels[0] = 0xFF;
-		  else
-		    pixels[2] = pixels[1] = pixels[0] = 0;
-		  pixels[3] = 0xFF;
-		}
-	      else
-		{
-		  pixels[2] = pixels[1] = pixels[0] = 0;
-		  pixels[3] = 0;
-		}
-	      pixels += 4;
-	      if (bit == 0)
-		{
-		  andp++;
-		  xorp++;
-		}
-	    }
-	  pixels += (w * 4 - rowstride);
-	}
-    }
-
-  g_snprintf (buf, sizeof (buf), "%ld", ii.xHotspot);
-  gdk_pixbuf_set_option (pixbuf, "x_hot", buf);
-
-  g_snprintf (buf, sizeof (buf), "%ld", ii.yHotspot);
-  gdk_pixbuf_set_option (pixbuf, "y_hot", buf);
-
-  /* release temporary resources */
- out2:
-  g_free (bits);
- out1:
-  DeleteDC (hdc);
- out0:
-  DeleteObject (ii.hbmColor);
-  DeleteObject (ii.hbmMask);
-
-  return pixbuf;
-}
-
-GdkPixbuf*  
-gdk_cursor_get_image (GdkCursor *cursor)
-{
-  g_return_val_if_fail (cursor != NULL, NULL);
-
-  return gdk_win32_icon_to_pixbuf_libgtk_only (((GdkCursorPrivate *) cursor)->hcursor);
-}
-
-GdkCursor *
-gdk_cursor_new_from_pixbuf (GdkDisplay *display, 
-			    GdkPixbuf  *pixbuf,
-			    gint        x,
-			    gint        y)
-{
-  HCURSOR hcursor;
-
-  g_return_val_if_fail (display == _gdk_display, NULL);
-  g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
-  g_return_val_if_fail (0 <= x && x < gdk_pixbuf_get_width (pixbuf), NULL);
-  g_return_val_if_fail (0 <= y && y < gdk_pixbuf_get_height (pixbuf), NULL);
-
-  hcursor = _gdk_win32_pixbuf_to_hcursor (pixbuf, x, y);
-  if (!hcursor)
-    return NULL;
-  return cursor_new_from_hcursor (hcursor, GDK_CURSOR_IS_PIXMAP);
-}
-
-gboolean 
-gdk_display_supports_cursor_alpha (GdkDisplay    *display)
-{
-  g_return_val_if_fail (display == _gdk_display, FALSE);
-
-  return _gdk_win32_pixbuf_to_hicon_supports_alpha ();
-}
-
-gboolean 
-gdk_display_supports_cursor_color (GdkDisplay    *display)
-{
-  g_return_val_if_fail (display == _gdk_display, FALSE);
-
-  return TRUE;
-}
-
-guint     
-gdk_display_get_default_cursor_size (GdkDisplay    *display)
-{
-  g_return_val_if_fail (display == _gdk_display, 0);
-  
-  return MIN (GetSystemMetrics (SM_CXCURSOR), GetSystemMetrics (SM_CYCURSOR));
-}
-
-void     
-gdk_display_get_maximal_cursor_size (GdkDisplay *display,
-				     guint       *width,
-				     guint       *height)
-{
-  g_return_if_fail (display == _gdk_display);
-  
-  if (width)
-    *width = GetSystemMetrics (SM_CXCURSOR);
-  if (height)
-    *height = GetSystemMetrics (SM_CYCURSOR);
-}
-
-
-/* Convert a pixbuf to an HICON (or HCURSOR).  Supports alpha under
- * Windows XP, thresholds alpha otherwise.  Also used from
- * gdkwindow-win32.c for creating application icons.
- */
-
-static HBITMAP
-create_alpha_bitmap (gint     size,
-		     guchar **outdata)
-{
-  BITMAPV5HEADER bi;
-  HDC hdc;
-  HBITMAP hBitmap;
-
-  ZeroMemory (&bi, sizeof (BITMAPV5HEADER));
-  bi.bV5Size = sizeof (BITMAPV5HEADER);
-  bi.bV5Height = bi.bV5Width = size;
-  bi.bV5Planes = 1;
-  bi.bV5BitCount = 32;
-  bi.bV5Compression = BI_BITFIELDS;
-  /* The following mask specification specifies a supported 32 BPP
-   * alpha format for Windows XP (BGRA format).
-   */
-  bi.bV5RedMask   = 0x00FF0000;
-  bi.bV5GreenMask = 0x0000FF00;
-  bi.bV5BlueMask  = 0x000000FF;
-  bi.bV5AlphaMask = 0xFF000000;
-
-  /* Create the DIB section with an alpha channel. */
-  hdc = GetDC (NULL);
-  if (!hdc)
-    {
-      WIN32_GDI_FAILED ("GetDC");
-      return NULL;
-    }
-  hBitmap = CreateDIBSection (hdc, (BITMAPINFO *)&bi, DIB_RGB_COLORS,
-			      (PVOID *) outdata, NULL, (DWORD)0);
-  if (hBitmap == NULL)
-    WIN32_GDI_FAILED ("CreateDIBSection");
-  ReleaseDC (NULL, hdc);
-
-  return hBitmap;
-}
-
-static HBITMAP
-create_color_bitmap (gint     size,
-		     guchar **outdata,
-		     gint     bits)
-{
-  struct {
-    BITMAPV4HEADER bmiHeader;
-    RGBQUAD bmiColors[2];
-  } bmi;
-  HDC hdc;
-  HBITMAP hBitmap;
-
-  ZeroMemory (&bmi, sizeof (bmi));
-  bmi.bmiHeader.bV4Size = sizeof (BITMAPV4HEADER);
-  bmi.bmiHeader.bV4Height = bmi.bmiHeader.bV4Width = size;
-  bmi.bmiHeader.bV4Planes = 1;
-  bmi.bmiHeader.bV4BitCount = bits;
-  bmi.bmiHeader.bV4V4Compression = BI_RGB;
-
-  /* when bits is 1, these will be used.
-   * bmiColors[0] already zeroed from ZeroMemory()
-   */
-  bmi.bmiColors[1].rgbBlue = 0xFF;
-  bmi.bmiColors[1].rgbGreen = 0xFF;
-  bmi.bmiColors[1].rgbRed = 0xFF;
-
-  hdc = GetDC (NULL);
-  if (!hdc)
-    {
-      WIN32_GDI_FAILED ("GetDC");
-      return NULL;
-    }
-  hBitmap = CreateDIBSection (hdc, (BITMAPINFO *)&bmi, DIB_RGB_COLORS,
-			      (PVOID *) outdata, NULL, (DWORD)0);
-  if (hBitmap == NULL)
-    WIN32_GDI_FAILED ("CreateDIBSection");
-  ReleaseDC (NULL, hdc);
-
-  return hBitmap;
-}
-
-static gboolean
-pixbuf_to_hbitmaps_alpha_winxp (GdkPixbuf *pixbuf,
-				HBITMAP   *color,
-				HBITMAP   *mask)
-{
-  /* Based on code from
-   * http://www.dotnet247.com/247reference/msgs/13/66301.aspx
-   */
-  HBITMAP hColorBitmap, hMaskBitmap;
-  guchar *indata, *inrow;
-  guchar *colordata, *colorrow, *maskdata, *maskbyte;
-  gint width, height, size, i, i_offset, j, j_offset, rowstride;
-  guint maskstride, mask_bit;
-
-  width = gdk_pixbuf_get_width (pixbuf); /* width of icon */
-  height = gdk_pixbuf_get_height (pixbuf); /* height of icon */
-
-  /* The bitmaps are created square */
-  size = MAX (width, height);
-
-  hColorBitmap = create_alpha_bitmap (size, &colordata);
-  if (!hColorBitmap)
-    return FALSE;
-  hMaskBitmap = create_color_bitmap (size, &maskdata, 1);
-  if (!hMaskBitmap)
-    {
-      DeleteObject (hColorBitmap);
-      return FALSE;
-    }
-
-  /* MSDN says mask rows are aligned to "LONG" boundaries */
-  maskstride = (((size + 31) & ~31) >> 3);
-
-  indata = gdk_pixbuf_get_pixels (pixbuf);
-  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
-
-  if (width > height)
-    {
-      i_offset = 0;
-      j_offset = (width - height) / 2;
-    }
-  else
-    {
-      i_offset = (height - width) / 2;
-      j_offset = 0;
-    }
-
-  for (j = 0; j < height; j++)
-    {
-      colorrow = colordata + 4*(j+j_offset)*size + 4*i_offset;
-      maskbyte = maskdata + (j+j_offset)*maskstride + i_offset/8;
-      mask_bit = (0x80 >> (i_offset % 8));
-      inrow = indata + (height-j-1)*rowstride;
-      for (i = 0; i < width; i++)
-	{
-	  colorrow[4*i+0] = inrow[4*i+2];
-	  colorrow[4*i+1] = inrow[4*i+1];
-	  colorrow[4*i+2] = inrow[4*i+0];
-	  colorrow[4*i+3] = inrow[4*i+3];
-	  if (inrow[4*i+3] == 0)
-	    maskbyte[0] |= mask_bit;	/* turn ON bit */
-	  else
-	    maskbyte[0] &= ~mask_bit;	/* turn OFF bit */
-	  mask_bit >>= 1;
-	  if (mask_bit == 0)
-	    {
-	      mask_bit = 0x80;
-	      maskbyte++;
-	    }
-	}
-    }
-
-  *color = hColorBitmap;
-  *mask = hMaskBitmap;
-
-  return TRUE;
-}
-
-static gboolean
-pixbuf_to_hbitmaps_normal (GdkPixbuf *pixbuf,
-			   HBITMAP   *color,
-			   HBITMAP   *mask)
-{
-  /* Based on code from
-   * http://www.dotnet247.com/247reference/msgs/13/66301.aspx
-   */
-  HBITMAP hColorBitmap, hMaskBitmap;
-  guchar *indata, *inrow;
-  guchar *colordata, *colorrow, *maskdata, *maskbyte;
-  gint width, height, size, i, i_offset, j, j_offset, rowstride, nc, bmstride;
-  gboolean has_alpha;
-  guint maskstride, mask_bit;
-
-  width = gdk_pixbuf_get_width (pixbuf); /* width of icon */
-  height = gdk_pixbuf_get_height (pixbuf); /* height of icon */
-
-  /* The bitmaps are created square */
-  size = MAX (width, height);
-
-  hColorBitmap = create_color_bitmap (size, &colordata, 24);
-  if (!hColorBitmap)
-    return FALSE;
-  hMaskBitmap = create_color_bitmap (size, &maskdata, 1);
-  if (!hMaskBitmap)
-    {
-      DeleteObject (hColorBitmap);
-      return FALSE;
-    }
-
-  /* rows are always aligned on 4-byte boundarys */
-  bmstride = size * 3;
-  if (bmstride % 4 != 0)
-    bmstride += 4 - (bmstride % 4);
-
-  /* MSDN says mask rows are aligned to "LONG" boundaries */
-  maskstride = (((size + 31) & ~31) >> 3);
-
-  indata = gdk_pixbuf_get_pixels (pixbuf);
-  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
-  nc = gdk_pixbuf_get_n_channels (pixbuf);
-  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
-
-  if (width > height)
-    {
-      i_offset = 0;
-      j_offset = (width - height) / 2;
-    }
-  else
-    {
-      i_offset = (height - width) / 2;
-      j_offset = 0;
-    }
-
-  for (j = 0; j < height; j++)
-    {
-      colorrow = colordata + (j+j_offset)*bmstride + 3*i_offset;
-      maskbyte = maskdata + (j+j_offset)*maskstride + i_offset/8;
-      mask_bit = (0x80 >> (i_offset % 8));
-      inrow = indata + (height-j-1)*rowstride;
-      for (i = 0; i < width; i++)
-	{
-	  if (has_alpha && inrow[nc*i+3] < 128)
-	    {
-	      colorrow[3*i+0] = colorrow[3*i+1] = colorrow[3*i+2] = 0;
-	      maskbyte[0] |= mask_bit;	/* turn ON bit */
-	    }
-	  else
-	    {
-	      colorrow[3*i+0] = inrow[nc*i+2];
-	      colorrow[3*i+1] = inrow[nc*i+1];
-	      colorrow[3*i+2] = inrow[nc*i+0];
-	      maskbyte[0] &= ~mask_bit;	/* turn OFF bit */
-	    }
-	  mask_bit >>= 1;
-	  if (mask_bit == 0)
-	    {
-	      mask_bit = 0x80;
-	      maskbyte++;
-	    }
-	}
-    }
-
-  *color = hColorBitmap;
-  *mask = hMaskBitmap;
-
-  return TRUE;
-}
-
-static HICON
-pixbuf_to_hicon (GdkPixbuf *pixbuf,
-		 gboolean   is_icon,
-		 gint       x,
-		 gint       y)
-{
-  ICONINFO ii;
-  HICON icon;
-  gboolean success;
-
-  if (pixbuf == NULL)
-    return NULL;
-
-  if (_gdk_win32_pixbuf_to_hicon_supports_alpha() && gdk_pixbuf_get_has_alpha (pixbuf))
-    success = pixbuf_to_hbitmaps_alpha_winxp (pixbuf, &ii.hbmColor, &ii.hbmMask);
-  else
-    success = pixbuf_to_hbitmaps_normal (pixbuf, &ii.hbmColor, &ii.hbmMask);
-
-  if (!success)
-    return NULL;
-
-  ii.fIcon = is_icon;
-  ii.xHotspot = x;
-  ii.yHotspot = y;
-  icon = CreateIconIndirect (&ii);
-  DeleteObject (ii.hbmColor);
-  DeleteObject (ii.hbmMask);
-  return icon;
-}
-
-HICON
-_gdk_win32_pixbuf_to_hicon (GdkPixbuf *pixbuf)
-{
-  return pixbuf_to_hicon (pixbuf, TRUE, 0, 0);
-}
-
-HICON
-_gdk_win32_pixbuf_to_hcursor (GdkPixbuf *pixbuf,
-			      gint       x_hotspot,
-			      gint       y_hotspot)
-{
-  return pixbuf_to_hicon (pixbuf, FALSE, x_hotspot, y_hotspot);
-}
-
-gboolean
-_gdk_win32_pixbuf_to_hicon_supports_alpha (void)
-{
-  static gboolean is_win_xp=FALSE, is_win_xp_checked=FALSE;
-
-  if (!is_win_xp_checked)
-    {
-      OSVERSIONINFO version;
-
-      is_win_xp_checked = TRUE;
-
-      memset (&version, 0, sizeof (version));
-      version.dwOSVersionInfoSize = sizeof (version);
-      is_win_xp = GetVersionEx (&version)
-	&& version.dwPlatformId == VER_PLATFORM_WIN32_NT
-	&& (version.dwMajorVersion > 5
-	    || (version.dwMajorVersion == 5 && version.dwMinorVersion >= 1));
-    }
-  return is_win_xp;
-}
-
-HICON
-gdk_win32_pixbuf_to_hicon_libgtk_only (GdkPixbuf *pixbuf)
-{
-  return _gdk_win32_pixbuf_to_hicon (pixbuf);
-}
diff --git a/gdk/win32/gdkdisplay-win32.c b/gdk/win32/gdkdisplay-win32.c
deleted file mode 100644
index 7447525..0000000
--- a/gdk/win32/gdkdisplay-win32.c
+++ /dev/null
@@ -1,572 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 2002,2005 Hans Breuer
- * Copyright (C) 2003 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include "gdk.h"
-#include "gdkprivate-win32.h"
-
-#define HAVE_MONITOR_INFO
-
-#if defined(_MSC_VER) && (WINVER < 0x500) && (WINVER > 0x0400)
-#include <multimon.h>
-#elif defined(_MSC_VER) && (WINVER <= 0x0400)
-#undef HAVE_MONITOR_INFO
-#endif
-
-void
-_gdk_windowing_set_default_display (GdkDisplay *display)
-{
-  g_assert (display == NULL || _gdk_display == display);
-}
-
-gulong
-_gdk_windowing_window_get_next_serial (GdkDisplay *display)
-{
-	return 0;
-}
-
-#ifdef HAVE_MONITOR_INFO
-static BOOL CALLBACK
-count_monitor (HMONITOR hmonitor,
-	       HDC      hdc,
-	       LPRECT   rect,
-	       LPARAM   data)
-{
-  gint *n = (gint *) data;
-
-  (*n)++;
-
-  return TRUE;
-}
-
-static BOOL CALLBACK
-enum_monitor (HMONITOR hmonitor,
-	      HDC      hdc,
-	      LPRECT   rect,
-	      LPARAM   data)
-{
-  /* The struct MONITORINFOEX definition is for some reason different
-   * in the winuser.h bundled with mingw64 from that in MSDN and the
-   * official 32-bit mingw (the MONITORINFO part is in a separate "mi"
-   * member). So to keep this easily compileable with either, repeat
-   * the MSDN definition it here.
-   */
-  typedef struct tagMONITORINFOEXA2 {
-    DWORD cbSize;
-    RECT  rcMonitor;
-    RECT  rcWork;
-    DWORD dwFlags;
-    CHAR szDevice[CCHDEVICENAME];
-  } MONITORINFOEXA2;
-
-  MONITORINFOEXA2 monitor_info;
-  HDC hDC;
-
-  gint *index = (gint *) data;
-  GdkWin32Monitor *monitor;
-
-  if (*index >= _gdk_num_monitors)
-    {
-      (*index) += 1;
-
-      return TRUE;
-    }
-
-  monitor = _gdk_monitors + *index;
-
-  monitor_info.cbSize = sizeof (MONITORINFOEX);
-  GetMonitorInfoA (hmonitor, (MONITORINFO *) &monitor_info);
-
-#ifndef MONITORINFOF_PRIMARY
-#define MONITORINFOF_PRIMARY 1
-#endif
-
-  monitor->name = g_strdup (monitor_info.szDevice);
-  hDC = CreateDCA ("DISPLAY", monitor_info.szDevice, NULL, NULL);
-  monitor->width_mm = GetDeviceCaps (hDC, HORZSIZE);
-  monitor->height_mm = GetDeviceCaps (hDC, VERTSIZE);
-  DeleteDC (hDC);
-  monitor->rect.x = monitor_info.rcMonitor.left;
-  monitor->rect.y = monitor_info.rcMonitor.top;
-  monitor->rect.width = monitor_info.rcMonitor.right - monitor_info.rcMonitor.left;
-  monitor->rect.height = monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top;
-
-  if (monitor_info.dwFlags & MONITORINFOF_PRIMARY &&
-      *index != 0)
-    {
-      /* Put primary monitor at index 0, just in case somebody needs
-       * to know which one is the primary.
-       */
-      GdkWin32Monitor temp = *monitor;
-      *monitor = _gdk_monitors[0];
-      _gdk_monitors[0] = temp;
-    }
-
-  (*index)++;
-
-  return TRUE;
-}
-#endif /* HAVE_MONITOR_INFO */
-
-void
-_gdk_monitor_init (void)
-{
-#ifdef HAVE_MONITOR_INFO
-  gint i, index;
-
-  /* In case something happens between monitor counting and monitor
-   * enumeration, repeat until the count matches up.
-   * enum_monitor is coded to ignore any monitors past _gdk_num_monitors.
-   */
-  do
-  {
-    _gdk_num_monitors = 0;
-
-    EnumDisplayMonitors (NULL, NULL, count_monitor, (LPARAM) &_gdk_num_monitors);
-
-    _gdk_monitors = g_renew (GdkWin32Monitor, _gdk_monitors, _gdk_num_monitors);
-
-    index = 0;
-    EnumDisplayMonitors (NULL, NULL, enum_monitor, (LPARAM) &index);
-  } while (index != _gdk_num_monitors);
-
-  _gdk_offset_x = G_MININT;
-  _gdk_offset_y = G_MININT;
-
-  /* Calculate offset */
-  for (i = 0; i < _gdk_num_monitors; i++)
-    {
-      _gdk_offset_x = MAX (_gdk_offset_x, -_gdk_monitors[i].rect.x);
-      _gdk_offset_y = MAX (_gdk_offset_y, -_gdk_monitors[i].rect.y);
-    }
-  GDK_NOTE (MISC, g_print ("Multi-monitor offset: (%d,%d)\n",
-			   _gdk_offset_x, _gdk_offset_y));
-
-  /* Translate monitor coords into GDK coordinate space */
-  for (i = 0; i < _gdk_num_monitors; i++)
-    {
-      _gdk_monitors[i].rect.x += _gdk_offset_x;
-      _gdk_monitors[i].rect.y += _gdk_offset_y;
-      GDK_NOTE (MISC, g_print ("Monitor %d: %dx%d@%+d%+d\n",
-			       i, _gdk_monitors[i].rect.width,
-			       _gdk_monitors[i].rect.height,
-			       _gdk_monitors[i].rect.x,
-			       _gdk_monitors[i].rect.y));
-    }
-#else
-  HDC hDC;
-
-  _gdk_num_monitors = 1;
-  _gdk_monitors = g_renew (GdkWin32Monitor, _gdk_monitors, 1);
-
-  _gdk_monitors[0].name = g_strdup ("DISPLAY");
-  hDC = GetDC (NULL);
-  _gdk_monitors[0].width_mm = GetDeviceCaps (hDC, HORZSIZE);
-  _gdk_monitors[0].height_mm = GetDeviceCaps (hDC, VERTSIZE);
-  ReleaseDC (NULL, hDC);
-  _gdk_monitors[0].rect.x = 0;
-  _gdk_monitors[0].rect.y = 0;
-  _gdk_monitors[0].rect.width = GetSystemMetrics (SM_CXSCREEN);
-  _gdk_monitors[0].rect.height = GetSystemMetrics (SM_CYSCREEN);
-  _gdk_offset_x = 0;
-  _gdk_offset_y = 0;
-#endif
-}
-
-GdkDisplay *
-gdk_display_open (const gchar *display_name)
-{
-  GDK_NOTE (MISC, g_print ("gdk_display_open: %s\n", (display_name ? display_name : "NULL")));
-
-  if (display_name == NULL ||
-      g_ascii_strcasecmp (display_name,
-			  gdk_display_get_name (_gdk_display)) == 0)
-    {
-      if (_gdk_display != NULL)
-	{
-	  GDK_NOTE (MISC, g_print ("... return _gdk_display\n"));
-	  return _gdk_display;
-	}
-    }
-  else
-    {
-      GDK_NOTE (MISC, g_print ("... return NULL\n"));
-      return NULL;
-    }
-
-  _gdk_display = g_object_new (GDK_TYPE_DISPLAY, NULL);
-  _gdk_screen = g_object_new (GDK_TYPE_SCREEN, NULL);
-
-  _gdk_monitor_init ();
-  _gdk_visual_init ();
-  gdk_screen_set_default_colormap (_gdk_screen,
-                                   gdk_screen_get_system_colormap (_gdk_screen));
-  _gdk_windowing_window_init (_gdk_screen);
-  _gdk_windowing_image_init ();
-  _gdk_events_init ();
-  _gdk_input_init (_gdk_display);
-  _gdk_dnd_init ();
-
-  /* Precalculate display name */
-  (void) gdk_display_get_name (_gdk_display);
-
-  g_signal_emit_by_name (gdk_display_manager_get (),
-			 "display_opened", _gdk_display);
-
-  GDK_NOTE (MISC, g_print ("... _gdk_display now set up\n"));
-
-  return _gdk_display;
-}
-
-const gchar *
-gdk_display_get_name (GdkDisplay *display)
-{
-  HDESK hdesk = GetThreadDesktop (GetCurrentThreadId ());
-  char dummy;
-  char *desktop_name;
-  HWINSTA hwinsta = GetProcessWindowStation ();
-  char *window_station_name;
-  DWORD n;
-  DWORD session_id;
-  char *display_name;
-  static const char *display_name_cache = NULL;
-  typedef BOOL (WINAPI *PFN_ProcessIdToSessionId) (DWORD, DWORD *);
-  PFN_ProcessIdToSessionId processIdToSessionId;
-
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-
-  if (display_name_cache != NULL)
-    return display_name_cache;
-
-  n = 0;
-  GetUserObjectInformation (hdesk, UOI_NAME, &dummy, 0, &n);
-  if (n == 0)
-    desktop_name = "Default";
-  else
-    {
-      n++;
-      desktop_name = g_alloca (n + 1);
-      memset (desktop_name, 0, n + 1);
-
-      if (!GetUserObjectInformation (hdesk, UOI_NAME, desktop_name, n, &n))
-	desktop_name = "Default";
-    }
-
-  n = 0;
-  GetUserObjectInformation (hwinsta, UOI_NAME, &dummy, 0, &n);
-  if (n == 0)
-    window_station_name = "WinSta0";
-  else
-    {
-      n++;
-      window_station_name = g_alloca (n + 1);
-      memset (window_station_name, 0, n + 1);
-
-      if (!GetUserObjectInformation (hwinsta, UOI_NAME, window_station_name, n, &n))
-	window_station_name = "WinSta0";
-    }
-
-  processIdToSessionId = (PFN_ProcessIdToSessionId) GetProcAddress (GetModuleHandle ("kernel32.dll"), "ProcessIdToSessionId");
-  if (!processIdToSessionId || !processIdToSessionId (GetCurrentProcessId (), &session_id))
-    session_id = 0;
-
-  display_name = g_strdup_printf ("%ld\\%s\\%s",
-				  session_id,
-				  window_station_name,
-				  desktop_name);
-
-  GDK_NOTE (MISC, g_print ("gdk_display_get_name: %s\n", display_name));
-
-  display_name_cache = display_name;
-
-  return display_name_cache;
-}
-
-gint
-gdk_display_get_n_screens (GdkDisplay *display)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), 0);
-
-  return 1;
-}
-
-GdkScreen *
-gdk_display_get_screen (GdkDisplay *display,
-			gint        screen_num)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-  g_return_val_if_fail (screen_num == 0, NULL);
-
-  return _gdk_screen;
-}
-
-GdkScreen *
-gdk_display_get_default_screen (GdkDisplay *display)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-
-  return _gdk_screen;
-}
-
-GdkWindow *
-gdk_display_get_default_group (GdkDisplay *display)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-
-  g_warning ("gdk_display_get_default_group not yet implemented");
-
-  return NULL;
-}
-
-gboolean
-gdk_display_supports_selection_notification (GdkDisplay *display)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
-
-  return TRUE;
-}
-
-static HWND _hwnd_next_viewer = NULL;
-static int debug_indent = 0;
-
-/*
- * maybe this should be integrated with the default message loop - or maybe not ;-)
- */
-static LRESULT CALLBACK
-inner_clipboard_window_procedure (HWND   hwnd,
-                                  UINT   message,
-                                  WPARAM wparam,
-                                  LPARAM lparam)
-{
-  switch (message)
-    {
-    case WM_DESTROY: /* remove us from chain */
-      {
-        ChangeClipboardChain (hwnd, _hwnd_next_viewer);
-        PostQuitMessage (0);
-        return 0;
-      }
-    case WM_CHANGECBCHAIN:
-      {
-        HWND hwndRemove = (HWND) wparam; /* handle of window being removed */
-        HWND hwndNext   = (HWND) lparam; /* handle of next window in chain */
-
-        if (hwndRemove == _hwnd_next_viewer)
-          _hwnd_next_viewer = hwndNext == hwnd ? NULL : hwndNext;
-        else if (_hwnd_next_viewer != NULL)
-          return SendMessage (_hwnd_next_viewer, message, wparam, lparam);
-
-        return 0;
-      }
-#ifdef WM_CLIPBOARDUPDATE
-    case WM_CLIPBOARDUPDATE:
-#endif
-    case WM_DRAWCLIPBOARD:
-      {
-        int success;
-        HWND hwndOwner;
-#ifdef G_ENABLE_DEBUG
-        UINT nFormat = 0;
-#endif
-        GdkEvent *event;
-        GdkWindow *owner;
-
-        success = OpenClipboard (hwnd);
-        g_return_val_if_fail (success, 0);
-        hwndOwner = GetClipboardOwner ();
-        owner = gdk_win32_window_lookup_for_display (_gdk_display, hwndOwner);
-        if (owner == NULL)
-          owner = gdk_win32_window_foreign_new_for_display (_gdk_display, hwndOwner);
-
-        GDK_NOTE (DND, g_print (" drawclipboard owner: %p", hwndOwner));
-
-#ifdef G_ENABLE_DEBUG
-        if (_gdk_debug_flags & GDK_DEBUG_DND)
-          {
-            while ((nFormat = EnumClipboardFormats (nFormat)) != 0)
-              g_print ("%s ", _gdk_win32_cf_to_string (nFormat));
-          }
-#endif
-
-        GDK_NOTE (DND, g_print (" \n"));
-
-
-        event = gdk_event_new (GDK_OWNER_CHANGE);
-        event->owner_change.window = _gdk_root;
-        event->owner_change.owner = owner;
-        event->owner_change.reason = GDK_OWNER_CHANGE_NEW_OWNER;
-        event->owner_change.selection = GDK_SELECTION_CLIPBOARD;
-        event->owner_change.time = _gdk_win32_get_next_tick (0);
-        event->owner_change.selection_time = GDK_CURRENT_TIME;
-        _gdk_win32_append_event (event);
-
-        CloseClipboard ();
-
-        if (_hwnd_next_viewer != NULL)
-          return SendMessage (_hwnd_next_viewer, message, wparam, lparam);
-
-        /* clear error to avoid confusing SetClipboardViewer() return */
-        SetLastError (0);
-        return 0;
-      }
-    default:
-      /* Otherwise call DefWindowProcW(). */
-      GDK_NOTE (EVENTS, g_print (" DefWindowProcW"));
-      return DefWindowProc (hwnd, message, wparam, lparam);
-    }
-}
-
-static LRESULT CALLBACK
-_clipboard_window_procedure (HWND   hwnd,
-                             UINT   message,
-                             WPARAM wparam,
-                             LPARAM lparam)
-{
-  LRESULT retval;
-
-  GDK_NOTE (EVENTS, g_print ("%s%*s%s %p",
-			     (debug_indent > 0 ? "\n" : ""),
-			     debug_indent, "",
-			     _gdk_win32_message_to_string (message), hwnd));
-  debug_indent += 2;
-  retval = inner_clipboard_window_procedure (hwnd, message, wparam, lparam);
-  debug_indent -= 2;
-
-  GDK_NOTE (EVENTS, g_print (" => %I64d%s", (gint64) retval, (debug_indent == 0 ? "\n" : "")));
-
-  return retval;
-}
-
-/*
- * Creates a hidden window and adds it to the clipboard chain
- */
-static HWND
-_gdk_win32_register_clipboard_notification (void)
-{
-  WNDCLASS wclass = { 0, };
-  HWND     hwnd;
-  ATOM     klass;
-
-  wclass.lpszClassName = "GdkClipboardNotification";
-  wclass.lpfnWndProc   = _clipboard_window_procedure;
-  wclass.hInstance     = _gdk_app_hmodule;
-
-  klass = RegisterClass (&wclass);
-  if (!klass)
-    return NULL;
-
-  hwnd = CreateWindow (MAKEINTRESOURCE (klass),
-                       NULL, WS_POPUP,
-                       0, 0, 0, 0, NULL, NULL,
-                       _gdk_app_hmodule, NULL);
-  if (!hwnd)
-    goto failed;
-
-  SetLastError (0);
-  _hwnd_next_viewer = SetClipboardViewer (hwnd);
-
-  if (_hwnd_next_viewer == NULL && GetLastError() != 0)
-    goto failed;
-
-  /* FIXME: http://msdn.microsoft.com/en-us/library/ms649033(v=VS.85).aspx */
-  /* This is only supported by Vista, and not yet by mingw64 */
-  /* if (AddClipboardFormatListener (hwnd) == FALSE) */
-  /*   goto failed; */
-
-  return hwnd;
-
-failed:
-  g_critical ("Failed to install clipboard viewer");
-  UnregisterClass (MAKEINTRESOURCE (klass), _gdk_app_hmodule);
-  return NULL;
-}
-
-gboolean
-gdk_display_request_selection_notification (GdkDisplay *display,
-                                            GdkAtom     selection)
-
-{
-  static HWND hwndViewer = NULL;
-  gboolean ret = FALSE;
-
-  GDK_NOTE (DND,
-            g_print ("gdk_display_request_selection_notification (..., %s)",
-                     gdk_atom_name (selection)));
-
-  if (selection == GDK_SELECTION_CLIPBOARD ||
-      selection == GDK_SELECTION_PRIMARY)
-    {
-      if (!hwndViewer)
-        {
-          hwndViewer = _gdk_win32_register_clipboard_notification ();
-          GDK_NOTE (DND, g_print (" registered"));
-        }
-      ret = (hwndViewer != NULL);
-    }
-  else
-    {
-      GDK_NOTE (DND, g_print (" unsupported"));
-      ret = FALSE;
-    }
-
-  GDK_NOTE (DND, g_print (" -> %s\n", ret ? "TRUE" : "FALSE"));
-  return ret;
-}
-
-gboolean
-gdk_display_supports_clipboard_persistence (GdkDisplay *display)
-{
-  return FALSE;
-}
-
-void
-gdk_display_store_clipboard (GdkDisplay    *display,
-			     GdkWindow     *clipboard_window,
-			     guint32        time_,
-			     const GdkAtom *targets,
-			     gint           n_targets)
-{
-}
-
-gboolean
-gdk_display_supports_shapes (GdkDisplay *display)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
-
-  return TRUE;
-}
-
-gboolean
-gdk_display_supports_input_shapes (GdkDisplay *display)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
-
-  /* Not yet implemented. See comment in
-   * gdk_window_input_shape_combine_mask().
-   */
-
-  return FALSE;
-}
-
-gboolean
-gdk_display_supports_composite (GdkDisplay *display)
-{
-  return FALSE;
-}
diff --git a/gdk/win32/gdkdnd-win32.c b/gdk/win32/gdkdnd-win32.c
deleted file mode 100644
index ec2377c..0000000
--- a/gdk/win32/gdkdnd-win32.c
+++ /dev/null
@@ -1,2461 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1999 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 2001 Archaeopteryx Software Inc.
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/.
- */
-
-#include "config.h"
-#include <string.h>
-
-#include <io.h>
-#include <fcntl.h>
-
-/*
- * Comment from the old OLE2 DND code that is being merged in. Note
- * that this comment might not fully reflect reality as the code
- * obviously will have to be modified in this merge. Especially the
- * talk about supporting other than UTF-8 text is bogus, that will not
- * happen.
- *
- * Support for OLE-2 drag and drop added at Archaeopteryx Software, 2001
- * For more information, contact Stephan R.A. Deibel (sdeibel@archaeopteryx.com)
- *
- * Notes on implementation:
- *
- * This is a first pass at OLE2 support. It only supports text and unicode text
- * data types, and file list dnd (which is handled seperately as it predates OLE2
- * both in this implementation and on Windows in general).
- *
- * As such, the data type conversion from gdk selection targets to OLE2 CF_* data
- * type specifiers is partially hardwired. Fixing this is complicated by (a) the
- * fact that the widget's declared selection types aren't accessible in calls here
- * that need to declare the corresponding OLE2 data types, and (b) there isn't a
- * 1-1 correspondence between gdk target types and OLE2 types. The former needs
- * some redesign in gtk dnd (something a gdk/gtk expert should do; I have tried
- * and failed!). As an example of the latter: gdk STRING, TEXT, COMPOUND_TEXT map
- * to CF_TEXT, CF_OEMTEXT, and CF_UNICODETEXT but as a group and with conversions
- * necessary for various combinations. Currently, the code here (and in
- * gdkdnd-win32.c) can handle gdk STRING and TEXT but not COMPOUND_TEXT, and OLE2
- * CF_TEXT and CF_UNICODETEXT but not CF_OEMTEXT. The necessary conversions are
- * supplied by the implementation here.
- *
- * Note that in combination with another hack originated by Archaeopteryx
- * Software, the text conversions here may go to utf-8 unicode as the standard
- * within-gtk target or to single-byte ascii when the USE_ACP_TEXT compilation
- * flag is TRUE. This mode was added to support applications that aren't using
- * utf-8 across the gtk/gdk API but instead use single-byte ascii according to
- * the current Windows code page. See gdkim-win32.c for more info on that.
- *
- */
- 
-/* The mingw.org compiler does not export GUIDS in it's import library. To work
- * around that, define INITGUID to have the GUIDS declared. */
-#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
-#define INITGUID
-#endif
-
-#include "gdkdnd.h"
-#include "gdkproperty.h"
-#include "gdkinternals.h"
-#include "gdkprivate-win32.h"
-
-#include <ole2.h>
-
-#include <shlobj.h>
-#include <shlguid.h>
-
-#include <gdk/gdk.h>
-#include <glib/gstdio.h>
-
-typedef struct _GdkDragContextPrivateWin32 GdkDragContextPrivateWin32;
-
-typedef enum {
-  GDK_DRAG_STATUS_DRAG,
-  GDK_DRAG_STATUS_MOTION_WAIT,
-  GDK_DRAG_STATUS_ACTION_WAIT,
-  GDK_DRAG_STATUS_DROP
-} GdkDragStatus;
-
-/* Structure that holds information about a drag in progress.
- * this is used on both source and destination sides.
- */
-struct _GdkDragContextPrivateWin32 {
-  gboolean being_finalized;
-  gint ref_count;
-  IUnknown *iface;
-  DWORD last_key_state;
-  POINT last_pt;		/* Coordinates from last event */
-  guint drag_status : 4;	/* Current status of drag */
-  guint drop_failed : 1;	/* Whether the drop was unsuccessful */
-};
-
-#define PRIVATE_DATA(context) ((GdkDragContextPrivateWin32 *) GDK_DRAG_CONTEXT (context)->windowing_data)
-
-static GList *contexts;
-static GdkDragContext *current_dest_drag = NULL;
-
-static void gdk_drag_context_init       (GdkDragContext      *dragcontext);
-static void gdk_drag_context_class_init (GdkDragContextClass *klass);
-static void gdk_drag_context_finalize   (GObject              *object);
-
-static gpointer parent_class = NULL;
-
-static gboolean use_ole2_dnd = FALSE;
-
-G_DEFINE_TYPE (GdkDragContext, gdk_drag_context, G_TYPE_OBJECT)
-
-static void
-gdk_drag_context_init (GdkDragContext *dragcontext)
-{
-  GdkDragContextPrivateWin32 *private;
-
-  private = G_TYPE_INSTANCE_GET_PRIVATE (dragcontext,
-					 GDK_TYPE_DRAG_CONTEXT,
-					 GdkDragContextPrivateWin32);
-
-  dragcontext->windowing_data = private;
-
-  if (!use_ole2_dnd)
-    {
-      contexts = g_list_prepend (contexts, dragcontext);
-    }
-  else
-    {
-      private->being_finalized = FALSE;
-      private->ref_count = 1;
-      private->iface = NULL;
-    }
-
-  GDK_NOTE (DND, g_print ("gdk_drag_context_init %p\n", dragcontext));
-}
-
-static void
-gdk_drag_context_class_init (GdkDragContextClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  parent_class = g_type_class_peek_parent (klass);
-
-  object_class->finalize = gdk_drag_context_finalize;
-
-  g_type_class_add_private (object_class, sizeof (GdkDragContextPrivateWin32));
-}
-
-static void
-gdk_drag_context_finalize (GObject *object)
-{
-  GdkDragContext *context = GDK_DRAG_CONTEXT (object);
-
-  GDK_NOTE (DND, g_print ("gdk_drag_context_finalize %p\n", object));
-
-  g_list_free (context->targets);
-
-  if (context->source_window)
-    g_object_unref (context->source_window);
-
-  if (context->dest_window)
-    g_object_unref (context->dest_window);
-
-  if (!use_ole2_dnd)
-    {
-      contexts = g_list_remove (contexts, context);
-
-      if (context == current_dest_drag)
-	current_dest_drag = NULL;
-    }
-  else
-    {
-      GdkDragContextPrivateWin32 *private = PRIVATE_DATA (context);
-      if (private->iface)
-	{
-	  private->being_finalized = TRUE;
-	  private->iface->lpVtbl->Release (private->iface);
-	  private->iface = NULL;
-	}
-    }
-
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-/* Drag Contexts */
-
-GdkDragContext *
-gdk_drag_context_new (void)
-{
-  return g_object_new (GDK_TYPE_DRAG_CONTEXT, NULL);
-}
-
-void
-gdk_drag_context_ref (GdkDragContext *context)
-{
-  g_return_if_fail (GDK_IS_DRAG_CONTEXT (context));
-
-  g_object_ref (context);
-}
-
-void
-gdk_drag_context_unref (GdkDragContext *context)
-{
-  g_return_if_fail (GDK_IS_DRAG_CONTEXT (context));
-
-  g_object_unref (context);
-}
-
-static GdkDragContext *
-gdk_drag_context_find (gboolean   is_source,
-		       GdkWindow *source,
-		       GdkWindow *dest)
-{
-  GList *tmp_list = contexts;
-  GdkDragContext *context;
-  GdkDragContextPrivateWin32 *private;
-
-  while (tmp_list)
-    {
-      context = (GdkDragContext *)tmp_list->data;
-      private = PRIVATE_DATA (context);
-
-      if ((!context->is_source == !is_source) &&
-	  ((source == NULL) || (context->source_window && (context->source_window == source))) &&
-	  ((dest == NULL) || (context->dest_window && (context->dest_window == dest))))
-	return context;
-
-      tmp_list = tmp_list->next;
-    }
-
-  return NULL;
-}
-
-#define PRINT_GUID(guid) \
-  g_print ("%.08lx-%.04x-%.04x-%.02x%.02x-%.02x%.02x%.02x%.02x%.02x%.02x", \
-	   ((gulong *)  guid)[0], \
-	   ((gushort *) guid)[2], \
-	   ((gushort *) guid)[3], \
-	   ((guchar *)  guid)[8], \
-	   ((guchar *)  guid)[9], \
-	   ((guchar *)  guid)[10], \
-	   ((guchar *)  guid)[11], \
-	   ((guchar *)  guid)[12], \
-	   ((guchar *)  guid)[13], \
-	   ((guchar *)  guid)[14], \
-	   ((guchar *)  guid)[15]);
-
-
-static FORMATETC *formats;
-static int nformats;
-
-typedef struct {
-  IDropTarget idt;
-  GdkDragContext *context;
-} target_drag_context;
-
-typedef struct {
-  IDropSource ids;
-  GdkDragContext *context;
-} source_drag_context;
-
-typedef struct {
-  IDataObject ido;
-  int ref_count;
-  GdkDragContext *context;
-} data_object;
-
-typedef struct {
-  IEnumFORMATETC ief;
-  int ref_count;
-  int ix;
-} enum_formats;
-
-static source_drag_context *pending_src_context = NULL;
-static IDataObject *dnd_data = NULL;
-
-static enum_formats *enum_formats_new (void);
-
-/* map windows -> target drag contexts. The table
- * owns a ref to both objects.
- */
-static GHashTable* target_ctx_for_window = NULL;
-
-static ULONG STDMETHODCALLTYPE
-idroptarget_addref (LPDROPTARGET This)
-{
-  target_drag_context *ctx = (target_drag_context *) This;
-  GdkDragContextPrivateWin32 *private = PRIVATE_DATA (ctx->context);
-  int ref_count = ++private->ref_count;
-
-  GDK_NOTE (DND, g_print ("idroptarget_addref %p %d\n", This, ref_count));
-  g_object_ref (G_OBJECT (ctx->context));
-
-  return ref_count;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idroptarget_queryinterface (LPDROPTARGET This,
-			    REFIID       riid,
-			    LPVOID      *ppvObject)
-{
-  GDK_NOTE (DND, {
-      g_print ("idroptarget_queryinterface %p ", This);
-      PRINT_GUID (riid);
-    });
-
-  *ppvObject = NULL;
-
-  if (IsEqualGUID (riid, &IID_IUnknown))
-    {
-      GDK_NOTE (DND, g_print ("...IUnknown S_OK\n"));
-      idroptarget_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else if (IsEqualGUID (riid, &IID_IDropTarget))
-    {
-      GDK_NOTE (DND, g_print ("...IDropTarget S_OK\n"));
-      idroptarget_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else
-    {
-      GDK_NOTE (DND, g_print ("...E_NOINTERFACE\n"));
-      return E_NOINTERFACE;
-    }
-}
-
-static ULONG STDMETHODCALLTYPE
-idroptarget_release (LPDROPTARGET This)
-{
-  target_drag_context *ctx = (target_drag_context *) This;
-  GdkDragContextPrivateWin32 *private = PRIVATE_DATA (ctx->context);
-  int ref_count = --private->ref_count;
-
-  GDK_NOTE (DND, g_print ("idroptarget_release %p %d\n", This, ref_count));
-
-  if (!private->being_finalized)
-    g_object_unref (G_OBJECT (ctx->context));
-
-  if (ref_count == 0)
-    g_free (This);
-
-  return ref_count;
-}
-
-#if 0
-
-static GdkAtom
-cf_to_atom (CLIPFORMAT cf)
-{
-  switch (cf)
-    {
-    case CF_UNICODETEXT:
-      return _utf8_string;
-    case CF_HDROP:
-      return _text_uri_list;
-    case CF_DIB:
-      return _image_bmp;
-    }
-
-  if (cf == _cf_url)
-    return _text_uri_list;
-
-  if (cf == _cf_html_format || cf == _cf_text_html)
-    return _text_html;
-
-  return GDK_NONE;
-}
-
-#endif
-
-static GdkDragAction
-get_suggested_action (DWORD grfKeyState)
-{
-  /* This is the yucky Windows standard: Force link action if both
-   * Control and Alt are down, copy if Control is down alone, move if
-   * Alt is down alone, or use default of move within the app or copy
-   * when origin of the drag is in another app.
-   */
-  if (grfKeyState & MK_CONTROL && grfKeyState & MK_SHIFT)
-    return GDK_ACTION_LINK; /* Link action not supported */
-  else if (grfKeyState & MK_CONTROL)
-    return GDK_ACTION_COPY;
-  else if (grfKeyState & MK_ALT)
-    return GDK_ACTION_MOVE;
-#if 0 /* Default is always copy for now */
-  else if (_dnd_source_state == GDK_WIN32_DND_DRAGGING)
-    return GDK_ACTION_MOVE;
-#endif
-  else
-    return GDK_ACTION_COPY;
-  /* Any way to determine when to add in DROPEFFECT_SCROLL? */
-}
-
-/* Process pending events -- we don't want to service non-GUI events
- * forever so do one iteration and then do more only if there's a
- * pending GDK event.
- */
-static void
-process_pending_events ()
-{
-  g_main_context_iteration (NULL, FALSE);
-  while (_gdk_event_queue_find_first (_gdk_display))
-    g_main_context_iteration (NULL, FALSE);
-}
-
-static DWORD
-drop_effect_for_action (GdkDragAction action)
-{
-  switch (action)
-    {
-    case GDK_ACTION_MOVE:
-      return DROPEFFECT_MOVE;
-    case GDK_ACTION_LINK:
-      return DROPEFFECT_LINK;
-    case GDK_ACTION_COPY:
-      return DROPEFFECT_COPY;
-    default:
-      return DROPEFFECT_NONE;
-    }
-}
-
-static void
-dnd_event_put (GdkEventType    type,
-	       GdkDragContext *context,
-	       const POINTL    pt,
-	       gboolean        to_dest_window)
-{
-  GdkEvent e;
-  e.type = type;
-  if (to_dest_window)
-    e.dnd.window = context->dest_window;
-  else
-    e.dnd.window = context->source_window;
-  e.dnd.send_event = FALSE;
-  e.dnd.context = context;
-  e.dnd.time = GDK_CURRENT_TIME;
-  e.dnd.x_root = pt.x + _gdk_offset_x;
-  e.dnd.y_root = pt.x + _gdk_offset_y;
-
-  g_object_ref (e.dnd.context);
-  if (e.dnd.window != NULL)
-    g_object_ref (e.dnd.window);
-
-  GDK_NOTE (EVENTS, _gdk_win32_print_event (&e));
-  gdk_event_put (&e);
-}
-
-static HRESULT STDMETHODCALLTYPE
-idroptarget_dragenter (LPDROPTARGET This,
-		       LPDATAOBJECT pDataObj,
-		       DWORD        grfKeyState,
-		       POINTL       pt,
-		       LPDWORD      pdwEffect)
-{
-  target_drag_context *ctx = (target_drag_context *) This;
-
-  GDK_NOTE (DND, g_print ("idroptarget_dragenter %p S_OK\n", This));
-
-  ctx->context->suggested_action = get_suggested_action (grfKeyState);
-  dnd_event_put (GDK_DRAG_ENTER, ctx->context, pt, TRUE);
-  process_pending_events ();
-  *pdwEffect = drop_effect_for_action (ctx->context->action);
-
-  /* Assume that target can accept the data: In fact it may fail but
-   * we are not really set up to query the target!
-   */
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idroptarget_dragover (LPDROPTARGET This,
-		      DWORD        grfKeyState,
-		      POINTL       pt,
-		      LPDWORD      pdwEffect)
-{
-  target_drag_context *ctx = (target_drag_context *) This;
-
-  GDK_NOTE (DND, g_print ("idroptarget_dragover %p S_OK\n", This));
-
-  ctx->context->suggested_action = get_suggested_action (grfKeyState);
-  dnd_event_put (GDK_DRAG_MOTION, ctx->context, pt, TRUE);
-  process_pending_events ();
-  *pdwEffect = drop_effect_for_action (ctx->context->action);
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idroptarget_dragleave (LPDROPTARGET This)
-{
-  target_drag_context *ctx = (target_drag_context *) This;
-  POINTL pt = { 0, 0 };
-
-  GDK_NOTE (DND, g_print ("idroptarget_dragleave %p S_OK\n", This));
-
-  dnd_event_put (GDK_DRAG_LEAVE, ctx->context, pt, TRUE);
-  process_pending_events ();
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idroptarget_drop (LPDROPTARGET This,
-		  LPDATAOBJECT pDataObj,
-		  DWORD        grfKeyState,
-		  POINTL       pt,
-		  LPDWORD      pdwEffect)
-{
-  target_drag_context *ctx = (target_drag_context *) This;
-
-  GDK_NOTE (DND, g_print ("idroptarget_drop %p ", This));
-
-  if (pDataObj == NULL)
-    {
-      GDK_NOTE (DND, g_print ("E_POINTER\n"));
-      return E_POINTER;
-    }
-
-  dnd_data = pDataObj;
-
-  ctx->context->suggested_action = get_suggested_action (grfKeyState);
-  dnd_event_put (GDK_DROP_START, ctx->context, pt, TRUE);
-  process_pending_events ();
-
-  dnd_data = NULL;
-
-  /* Notify OLE of copy or move */
-  if (_dnd_target_state != GDK_WIN32_DND_DROPPED)
-    *pdwEffect = DROPEFFECT_NONE;
-  else
-    *pdwEffect = drop_effect_for_action (ctx->context->action);
-
-  GDK_NOTE (DND, g_print ("S_OK\n"));
-
-  return S_OK;
-}
-
-static ULONG STDMETHODCALLTYPE
-idropsource_addref (LPDROPSOURCE This)
-{
-  source_drag_context *ctx = (source_drag_context *) This;
-  GdkDragContextPrivateWin32 *private = PRIVATE_DATA (ctx->context);
-  int ref_count = ++private->ref_count;
-
-  GDK_NOTE (DND, g_print ("idropsource_addref %p %d\n", This, ref_count));
-  g_object_ref (G_OBJECT (ctx->context));
-
-  return ref_count;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idropsource_queryinterface (LPDROPSOURCE This,
-			    REFIID       riid,
-			    LPVOID      *ppvObject)
-{
-  GDK_NOTE (DND, {
-      g_print ("idropsource_queryinterface %p ", This);
-      PRINT_GUID (riid);
-    });
-
-  *ppvObject = NULL;
-
-  if (IsEqualGUID (riid, &IID_IUnknown))
-    {
-      GDK_NOTE (DND, g_print ("...IUnknown S_OK\n"));
-      idropsource_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else if (IsEqualGUID (riid, &IID_IDropSource))
-    {
-      GDK_NOTE (DND, g_print ("...IDropSource S_OK\n"));
-      idropsource_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else
-    {
-      GDK_NOTE (DND, g_print ("...E_NOINTERFACE\n"));
-      return E_NOINTERFACE;
-    }
-}
-
-static ULONG STDMETHODCALLTYPE
-idropsource_release (LPDROPSOURCE This)
-{
-  source_drag_context *ctx = (source_drag_context *) This;
-  GdkDragContextPrivateWin32 *private = PRIVATE_DATA (ctx->context);
-  int ref_count = --private->ref_count;
-
-  GDK_NOTE (DND, g_print ("idropsource_release %p %d\n", This, ref_count));
-
-  if (!private->being_finalized)
-    g_object_unref (G_OBJECT (ctx->context));
-
-  if (ref_count == 0)
-    g_free (This);
-
-  return ref_count;
-}
-
-/* Emit GDK events for any changes in mouse events or control key
- * state since the last recorded state. Return true if any events
- * have been emitted and false otherwise.
- */
-static gboolean
-send_change_events (GdkDragContext *ctx,
-		    DWORD           key_state,
-		    gboolean        esc_pressed)
-{
-  GdkDragContextPrivateWin32 *private = PRIVATE_DATA (ctx);
-  POINT pt;
-  gboolean changed = FALSE;
-  HWND hwnd = GDK_WINDOW_HWND (ctx->source_window);
-  LPARAM lparam;
-  WPARAM wparam;
-
-  if (!API_CALL (GetCursorPos, (&pt)))
-    return FALSE;
-
-  if (!API_CALL (ScreenToClient, (hwnd, &pt)))
-    return FALSE;
-
-  if (pt.x != private->last_pt.x || pt.y != private->last_pt.y ||
-      key_state != private->last_key_state)
-    {
-      lparam = MAKELPARAM (pt.x, pt.y);
-      wparam = key_state;
-      if (pt.x != private->last_pt.x || pt.y != private->last_pt.y)
-	{
-	  GDK_NOTE (DND, g_print ("Sending WM_MOUSEMOVE (%ld,%ld)\n", pt.x, pt.y));
-      	  SendMessage (hwnd, WM_MOUSEMOVE, wparam, lparam);
-	}
-
-      if ((key_state & MK_LBUTTON) != (private->last_key_state & MK_LBUTTON))
-	{
-	  if (key_state & MK_LBUTTON)
-	    SendMessage (hwnd, WM_LBUTTONDOWN, wparam, lparam);
-	  else
-	    SendMessage (hwnd, WM_LBUTTONUP, wparam, lparam);
-	}
-      if ((key_state & MK_MBUTTON) != (private->last_key_state & MK_MBUTTON))
-	{
-	  if (key_state & MK_MBUTTON)
-	    SendMessage (hwnd, WM_MBUTTONDOWN, wparam, lparam);
-	  else
-	    SendMessage (hwnd, WM_MBUTTONUP, wparam, lparam);
-	}
-      if ((key_state & MK_RBUTTON) != (private->last_key_state & MK_RBUTTON))
-	{
-	  if (key_state & MK_RBUTTON)
-	    SendMessage (hwnd, WM_RBUTTONDOWN, wparam, lparam);
-	  else
-	    SendMessage (hwnd, WM_RBUTTONUP, wparam, lparam);
-	}
-      if ((key_state & MK_CONTROL) != (private->last_key_state & MK_CONTROL))
-	{
-	  if (key_state & MK_CONTROL)
-	    SendMessage (hwnd, WM_KEYDOWN, VK_CONTROL, 0);
-	  else
-	    SendMessage (hwnd, WM_KEYUP, VK_CONTROL, 0);
-	}
-      if ((key_state & MK_SHIFT) != (private->last_key_state & MK_SHIFT))
-	{
-	  if (key_state & MK_CONTROL)
-	    SendMessage (hwnd, WM_KEYDOWN, VK_SHIFT, 0);
-	  else
-	    SendMessage (hwnd, WM_KEYUP, VK_SHIFT, 0);
-	}
-
-      changed = TRUE;
-      private->last_key_state = key_state;
-      private->last_pt = pt;
-    }
-
-  if (esc_pressed)
-    {
-      GDK_NOTE (DND, g_print ("Sending a escape key down message to %p\n", hwnd));
-      SendMessage (hwnd, WM_KEYDOWN, VK_ESCAPE, 0);
-      changed = TRUE;
-    }
-
-  return changed;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idropsource_querycontinuedrag (LPDROPSOURCE This,
-			       BOOL         fEscapePressed,
-			       DWORD        grfKeyState)
-{
-  source_drag_context *ctx = (source_drag_context *) This;
-
-  GDK_NOTE (DND, g_print ("idropsource_querycontinuedrag %p ", This));
-
-  if (send_change_events (ctx->context, grfKeyState, fEscapePressed))
-    process_pending_events ();
-
-  if (_dnd_source_state == GDK_WIN32_DND_DROPPED)
-    {
-      GDK_NOTE (DND, g_print ("DRAGDROP_S_DROP\n"));
-      return DRAGDROP_S_DROP;
-    }
-  else if (_dnd_source_state == GDK_WIN32_DND_NONE)
-    {
-      GDK_NOTE (DND, g_print ("DRAGDROP_S_CANCEL\n"));
-      return DRAGDROP_S_CANCEL;
-    }
-  else
-    {
-      GDK_NOTE (DND, g_print ("S_OK\n"));
-      return S_OK;
-    }
-}
-
-static HRESULT STDMETHODCALLTYPE
-idropsource_givefeedback (LPDROPSOURCE This,
-			  DWORD        dwEffect)
-{
-  source_drag_context *ctx = (source_drag_context *) This;
-  GdkDragAction suggested_action;
-
-  GDK_NOTE (DND, g_print ("idropsource_givefeedback %p DRAGDROP_S_USEDEFAULTCURSORS\n", This));
-
-  if (dwEffect == DROPEFFECT_MOVE)
-    suggested_action = GDK_ACTION_MOVE;
-  else
-    suggested_action = GDK_ACTION_COPY;
-  ctx->context->action = suggested_action;
-
-  if (dwEffect == DROPEFFECT_NONE)
-    {
-      if (ctx->context->dest_window != NULL)
-	{
-	  g_object_unref (ctx->context->dest_window);
-	  ctx->context->dest_window = NULL;
-	}
-    }
-  else
-    {
-      if (ctx->context->dest_window == NULL)
-	ctx->context->dest_window = g_object_ref (_gdk_root);
-    }
-
-  return DRAGDROP_S_USEDEFAULTCURSORS;
-}
-
-static ULONG STDMETHODCALLTYPE
-idataobject_addref (LPDATAOBJECT This)
-{
-  data_object *dobj = (data_object *) This;
-  int ref_count = ++dobj->ref_count;
-
-  GDK_NOTE (DND, g_print ("idataobject_addref %p %d\n", This, ref_count));
-
-  return ref_count;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_queryinterface (LPDATAOBJECT This,
-			    REFIID       riid,
-			    LPVOID      *ppvObject)
-{
-  GDK_NOTE (DND, {
-      g_print ("idataobject_queryinterface %p ", This);
-      PRINT_GUID (riid);
-    });
-
-  *ppvObject = NULL;
-
-  if (IsEqualGUID (riid, &IID_IUnknown))
-    {
-      GDK_NOTE (DND, g_print ("...IUnknown S_OK\n"));
-      idataobject_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else if (IsEqualGUID (riid, &IID_IDataObject))
-    {
-      GDK_NOTE (DND, g_print ("...IDataObject S_OK\n"));
-      idataobject_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else
-    {
-      GDK_NOTE (DND, g_print ("...E_NOINTERFACE\n"));
-      return E_NOINTERFACE;
-    }
-}
-
-static ULONG STDMETHODCALLTYPE
-idataobject_release (LPDATAOBJECT This)
-{
-  data_object *dobj = (data_object *) This;
-  int ref_count = --dobj->ref_count;
-
-  GDK_NOTE (DND, g_print ("idataobject_release %p %d\n", This, ref_count));
-
-  if (ref_count == 0)
-    g_free (This);
-
-  return ref_count;
-}
-
-static HRESULT
-query (LPDATAOBJECT This,
-       LPFORMATETC  pFormatEtc)
-{
-  int i;
-
-  if (!pFormatEtc)
-    return DV_E_FORMATETC;
-
-  if (pFormatEtc->lindex != -1)
-    return DV_E_LINDEX;
-
-  if ((pFormatEtc->tymed & TYMED_HGLOBAL) == 0)
-    return DV_E_TYMED;
-
-  if ((pFormatEtc->dwAspect & DVASPECT_CONTENT) == 0)
-    return DV_E_DVASPECT;
-
-  for (i = 0; i < nformats; i++)
-    if (pFormatEtc->cfFormat == formats[i].cfFormat)
-      return S_OK;
-
-  return DV_E_FORMATETC;
-}
-
-static FORMATETC *active_pFormatEtc = NULL;
-static STGMEDIUM *active_pMedium = NULL;
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_getdata (LPDATAOBJECT This,
-		     LPFORMATETC  pFormatEtc,
-		     LPSTGMEDIUM  pMedium)
-{
-  data_object *ctx = (data_object *) This;
-  GdkAtom target;
-  HRESULT hr;
-  GdkEvent e;
-
-  GDK_NOTE (DND, g_print ("idataobject_getdata %p %s ",
-			  This, _gdk_win32_cf_to_string (pFormatEtc->cfFormat)));
-
-  /* Check whether we can provide requested format */
-  hr = query (This, pFormatEtc);
-  if (hr != S_OK)
-    return hr;
-
-  /* Append a GDK_SELECTION_GET event and then hope the app sets the
-   * property associated with the _gdk_ole2_dnd atom
-   */
-
-  active_pFormatEtc = pFormatEtc;
-  active_pMedium = pMedium;
-
-  target = GDK_TARGET_STRING;
-
-  e.type = GDK_SELECTION_REQUEST;
-  e.selection.window = ctx->context->source_window;
-  e.selection.send_event = FALSE; /* ??? */
-  /* FIXME: Should really both selection and property be _gdk_ole2_dnd? */
-  e.selection.selection = _gdk_ole2_dnd;
-  /* FIXME: Target? */
-  e.selection.target = _utf8_string;
-  e.selection.property = _gdk_ole2_dnd;
-  e.selection.time = GDK_CURRENT_TIME;
-
-  g_object_ref (e.selection.window);
-
-  GDK_NOTE (EVENTS, _gdk_win32_print_event (&e));
-  gdk_event_put (&e);
-  process_pending_events ();
-
-  active_pFormatEtc = NULL;
-  active_pMedium = NULL;
-
-  if (pMedium->hGlobal == NULL) {
-    return E_UNEXPECTED;
-  }
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_getdatahere (LPDATAOBJECT This,
-			 LPFORMATETC  pFormatEtc,
-			 LPSTGMEDIUM  pMedium)
-{
-  GDK_NOTE (DND, g_print ("idataobject_getdatahere %p %s E_UNEXPECTED\n",
-			  This, _gdk_win32_cf_to_string (pFormatEtc->cfFormat)));
-
-  return E_UNEXPECTED;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_querygetdata (LPDATAOBJECT This,
-			  LPFORMATETC  pFormatEtc)
-{
-  HRESULT hr;
-
-  hr = query (This, pFormatEtc);
-
-#define CASE(x) case x: g_print (#x)
-  GDK_NOTE (DND, {
-      g_print ("idataobject_querygetdata %p %s \n",
-	       This, _gdk_win32_cf_to_string (pFormatEtc->cfFormat));
-      switch (hr)
-	{
-	CASE (DV_E_FORMATETC);
-	CASE (DV_E_LINDEX);
-	CASE (DV_E_TYMED);
-	CASE (DV_E_DVASPECT);
-	CASE (S_OK);
-	default: g_print ("%#lx", hr);
-	}
-    });
-
-  return hr;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_getcanonicalformatetc (LPDATAOBJECT This,
-				   LPFORMATETC  pFormatEtcIn,
-				   LPFORMATETC  pFormatEtcOut)
-{
-  GDK_NOTE (DND, g_print ("idataobject_getcanonicalformatetc %p E_UNEXPECTED\n", This));
-
-  return E_UNEXPECTED;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_setdata (LPDATAOBJECT This,
-		     LPFORMATETC  pFormatEtc,
-		     LPSTGMEDIUM  pMedium,
-		     BOOL         fRelease)
-{
-  GDK_NOTE (DND, g_print ("idataobject_setdata %p %s E_UNEXPECTED\n",
-			  This, _gdk_win32_cf_to_string (pFormatEtc->cfFormat)));
-
-  return E_UNEXPECTED;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_enumformatetc (LPDATAOBJECT     This,
-			   DWORD            dwDirection,
-			   LPENUMFORMATETC *ppEnumFormatEtc)
-{
-  GDK_NOTE (DND, g_print ("idataobject_enumformatetc %p ", This));
-
-  if (dwDirection != DATADIR_GET)
-    {
-      GDK_NOTE (DND, g_print ("E_NOTIMPL\n"));
-      return E_NOTIMPL;
-    }
-
-  *ppEnumFormatEtc = &enum_formats_new ()->ief;
-
-  GDK_NOTE (DND, g_print ("%p S_OK\n", *ppEnumFormatEtc));
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_dadvise (LPDATAOBJECT This,
-		     LPFORMATETC  pFormatetc,
-		     DWORD        advf,
-		     LPADVISESINK pAdvSink,
-		     DWORD       *pdwConnection)
-{
-  GDK_NOTE (DND, g_print ("idataobject_dadvise %p E_NOTIMPL\n", This));
-
-  return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_dunadvise (LPDATAOBJECT This,
-		       DWORD         dwConnection)
-{
-  GDK_NOTE (DND, g_print ("idataobject_dunadvise %p E_NOTIMPL\n", This));
-
-  return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE
-idataobject_enumdadvise (LPDATAOBJECT    This,
-			 LPENUMSTATDATA *ppenumAdvise)
-{
-  GDK_NOTE (DND, g_print ("idataobject_enumdadvise %p OLE_E_ADVISENOTSUPPORTED\n", This));
-
-  return OLE_E_ADVISENOTSUPPORTED;
-}
-
-static ULONG STDMETHODCALLTYPE
-ienumformatetc_addref (LPENUMFORMATETC This)
-{
-  enum_formats *en = (enum_formats *) This;
-  int ref_count = ++en->ref_count;
-
-  GDK_NOTE (DND, g_print ("ienumformatetc_addref %p %d\n", This, ref_count));
-
-  return ref_count;
-}
-
-static HRESULT STDMETHODCALLTYPE
-ienumformatetc_queryinterface (LPENUMFORMATETC This,
-			       REFIID          riid,
-			       LPVOID         *ppvObject)
-{
-  GDK_NOTE (DND, {
-      g_print ("ienumformatetc_queryinterface %p", This);
-      PRINT_GUID (riid);
-    });
-
-  *ppvObject = NULL;
-
-  if (IsEqualGUID (riid, &IID_IUnknown))
-    {
-      GDK_NOTE (DND, g_print ("...IUnknown S_OK\n"));
-      ienumformatetc_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else if (IsEqualGUID (riid, &IID_IEnumFORMATETC))
-    {
-      GDK_NOTE (DND, g_print ("...IEnumFORMATETC S_OK\n"));
-      ienumformatetc_addref (This);
-      *ppvObject = This;
-      return S_OK;
-    }
-  else
-    {
-      GDK_NOTE (DND, g_print ("...E_NOINTERFACE\n"));
-      return E_NOINTERFACE;
-    }
-}
-
-static ULONG STDMETHODCALLTYPE
-ienumformatetc_release (LPENUMFORMATETC This)
-{
-  enum_formats *en = (enum_formats *) This;
-  int ref_count = --en->ref_count;
-
-  GDK_NOTE (DND, g_print ("ienumformatetc_release %p %d\n", This, ref_count));
-
-  if (ref_count == 0)
-    g_free (This);
-
-  return ref_count;
-}
-
-static HRESULT STDMETHODCALLTYPE
-ienumformatetc_next (LPENUMFORMATETC This,
-		     ULONG	     celt,
-		     LPFORMATETC     elts,
-		     ULONG	    *nelt)
-{
-  enum_formats *en = (enum_formats *) This;
-  int i, n;
-
-  GDK_NOTE (DND, g_print ("ienumformatetc_next %p %d %ld ", This, en->ix, celt));
-
-  n = 0;
-  for (i = 0; i < celt; i++)
-    {
-      if (en->ix >= nformats)
-	break;
-      elts[i] = formats[en->ix++];
-      n++;
-    }
-
-  if (nelt != NULL)
-    *nelt = n;
-
-  GDK_NOTE (DND, g_print ("%s\n", (n == celt) ? "S_OK" : "S_FALSE"));
-
-  if (n == celt)
-    return S_OK;
-  else
-    return S_FALSE;
-}
-
-static HRESULT STDMETHODCALLTYPE
-ienumformatetc_skip (LPENUMFORMATETC This,
-		     ULONG	     celt)
-{
-  enum_formats *en = (enum_formats *) This;
-
-  GDK_NOTE (DND, g_print ("ienumformatetc_skip %p %d %ld S_OK\n", This, en->ix, celt));
-
-  en->ix += celt;
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-ienumformatetc_reset (LPENUMFORMATETC This)
-{
-  enum_formats *en = (enum_formats *) This;
-
-  GDK_NOTE (DND, g_print ("ienumformatetc_reset %p S_OK\n", This));
-
-  en->ix = 0;
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-ienumformatetc_clone (LPENUMFORMATETC  This,
-		      LPENUMFORMATETC *ppEnumFormatEtc)
-{
-  enum_formats *en = (enum_formats *) This;
-  enum_formats *new;
-
-  GDK_NOTE (DND, g_print ("ienumformatetc_clone %p S_OK\n", This));
-
-  new = enum_formats_new ();
-
-  new->ix = en->ix;
-
-  *ppEnumFormatEtc = &new->ief;
-
-  return S_OK;
-}
-
-static IDropTargetVtbl idt_vtbl = {
-  idroptarget_queryinterface,
-  idroptarget_addref,
-  idroptarget_release,
-  idroptarget_dragenter,
-  idroptarget_dragover,
-  idroptarget_dragleave,
-  idroptarget_drop
-};
-
-static IDropSourceVtbl ids_vtbl = {
-  idropsource_queryinterface,
-  idropsource_addref,
-  idropsource_release,
-  idropsource_querycontinuedrag,
-  idropsource_givefeedback
-};
-
-static IDataObjectVtbl ido_vtbl = {
-  idataobject_queryinterface,
-  idataobject_addref,
-  idataobject_release,
-  idataobject_getdata,
-  idataobject_getdatahere,
-  idataobject_querygetdata,
-  idataobject_getcanonicalformatetc,
-  idataobject_setdata,
-  idataobject_enumformatetc,
-  idataobject_dadvise,
-  idataobject_dunadvise,
-  idataobject_enumdadvise
-};
-
-static IEnumFORMATETCVtbl ief_vtbl = {
-  ienumformatetc_queryinterface,
-  ienumformatetc_addref,
-  ienumformatetc_release,
-  ienumformatetc_next,
-  ienumformatetc_skip,
-  ienumformatetc_reset,
-  ienumformatetc_clone
-};
-
-
-static target_drag_context *
-target_context_new (GdkWindow *window)
-{
-  target_drag_context *result;
-  GdkDragContextPrivateWin32 *private;
-
-  result = g_new0 (target_drag_context, 1);
-
-  result->idt.lpVtbl = &idt_vtbl;
-
-  result->context = gdk_drag_context_new ();
-  result->context->protocol = GDK_DRAG_PROTO_OLE2;
-  result->context->is_source = FALSE;
-
-  result->context->source_window = NULL;
-
-  result->context->dest_window = window;
-  g_object_ref (window);
-
-  /* FIXME: result->context->targets? */
-
-  result->context->actions = GDK_ACTION_DEFAULT | GDK_ACTION_COPY | GDK_ACTION_MOVE;
-  result->context->suggested_action = GDK_ACTION_MOVE;
-  result->context->action = GDK_ACTION_MOVE;
-
-  private = result->context->windowing_data;
-  private->iface = (IUnknown *) &result->idt;
-  idroptarget_addref (&result->idt);
-
-  GDK_NOTE (DND, g_print ("target_context_new: %p\n", result));
-
-  return result;
-}
-
-static source_drag_context *
-source_context_new (GdkWindow *window,
-		    GList     *targets)
-{
-  source_drag_context *result;
-  GdkDragContextPrivateWin32 *private;
-
-  result = g_new0 (source_drag_context, 1);
-
-  result->ids.lpVtbl = &ids_vtbl;
-
-  result->context = gdk_drag_context_new ();
-  result->context->protocol = GDK_DRAG_PROTO_OLE2;
-  result->context->is_source = TRUE;
-
-  result->context->source_window = window;
-  g_object_ref (window);
-
-  result->context->dest_window = NULL;
-  result->context->targets = g_list_copy (targets);
-
-  private = result->context->windowing_data;
-  private->iface = (IUnknown *) &result->ids;
-  idropsource_addref (&result->ids);
-
-  GDK_NOTE (DND, g_print ("source_context_new: %p\n", result));
-
-  return result;
-}
-
-static data_object *
-data_object_new (GdkDragContext *context)
-{
-  data_object *result;
-
-  result = g_new0 (data_object, 1);
-
-  result->ido.lpVtbl = &ido_vtbl;
-  result->ref_count = 1;
-  result->context = context;
-
-  GDK_NOTE (DND, g_print ("data_object_new: %p\n", result));
-
-  return result;
-}
-
-static enum_formats *
-enum_formats_new (void)
-{
-  enum_formats *result;
-
-  result = g_new0 (enum_formats, 1);
-
-  result->ief.lpVtbl = &ief_vtbl;
-  result->ref_count = 1;
-  result->ix = 0;
-
-  return result;
-}
-
-void
-_gdk_win32_ole2_dnd_property_change (GdkAtom       type,
-				     gint          format,
-				     const guchar *data,
-				     gint          nelements)
-{
-  if (use_ole2_dnd)
-    {
-      HGLOBAL hdata = NULL;
-
-      if (active_pFormatEtc == NULL || active_pMedium == NULL)
-	return;
-
-      /* Set up the data buffer for wide character text request */
-      if (active_pFormatEtc->cfFormat == CF_UNICODETEXT)
-	{
-	  gunichar2 *wdata;
-	  glong wlen;
-
-	  wdata = g_utf8_to_utf16 ((const char *) data, -1, NULL, &wlen, NULL);
-	  hdata = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (wlen + 1) * 2);
-	  if (hdata)
-	    {
-	      wchar_t *ptr = (wchar_t *) GlobalLock(hdata);
-	      memcpy (ptr, wdata, (wlen + 1) * 2);
-	      GlobalUnlock(hdata);
-	    }
-	  g_free (wdata);
-	}
-      else
-	g_warning ("Only text handled for now");
-
-      /* Pack up data */
-      active_pMedium->tymed = TYMED_HGLOBAL;
-      active_pMedium->hGlobal = hdata;
-      active_pMedium->pUnkForRelease = 0;
-    }
-}
-
-/* From MS Knowledge Base article Q130698 */
-
-static gboolean
-resolve_link (HWND     hWnd,
-	      wchar_t *link,
-	      gchar  **lpszPath)
-{
-  WIN32_FILE_ATTRIBUTE_DATA wfad;
-  HRESULT hr;
-  IShellLinkW *pslW = NULL;
-  IPersistFile *ppf = NULL;
-
-  /* Check if the file is empty first because IShellLink::Resolve for
-   * some reason succeeds with an empty file and returns an empty
-   * "link target". (#524151)
-   */
-    if (!GetFileAttributesExW (link, GetFileExInfoStandard, &wfad) ||
-	(wfad.nFileSizeHigh == 0 && wfad.nFileSizeLow == 0))
-      return FALSE;
-
-  /* Assume failure to start with: */
-  *lpszPath = 0;
-
-  /* Call CoCreateInstance to obtain the IShellLink interface
-   * pointer. This call fails if CoInitialize is not called, so it is
-   * assumed that CoInitialize has been called.
-   */
-
-  hr = CoCreateInstance (&CLSID_ShellLink,
-			 NULL,
-			 CLSCTX_INPROC_SERVER,
-			 &IID_IShellLinkW,
-			 (LPVOID *)&pslW);
-
-  if (SUCCEEDED (hr))
-   {
-     /* The IShellLink interface supports the IPersistFile
-      * interface. Get an interface pointer to it.
-      */
-     hr = pslW->lpVtbl->QueryInterface (pslW,
-					&IID_IPersistFile,
-					(LPVOID *) &ppf);
-   }
-
-  if (SUCCEEDED (hr))
-    {
-      /* Load the file. */
-      hr = ppf->lpVtbl->Load (ppf, link, STGM_READ);
-    }
-
-  if (SUCCEEDED (hr))
-    {
-      /* Resolve the link by calling the Resolve()
-       * interface function.
-       */
-      hr = pslW->lpVtbl->Resolve (pslW, hWnd, SLR_ANY_MATCH | SLR_NO_UI);
-    }
-
-  if (SUCCEEDED (hr))
-    {
-      wchar_t wtarget[MAX_PATH];
-
-      hr = pslW->lpVtbl->GetPath (pslW, wtarget, MAX_PATH, NULL, 0);
-      if (SUCCEEDED (hr))
-	*lpszPath = g_utf16_to_utf8 (wtarget, -1, NULL, NULL, NULL);
-    }
-
-  if (ppf)
-    ppf->lpVtbl->Release (ppf);
-
-  if (pslW)
-    pslW->lpVtbl->Release (pslW);
-
-  return SUCCEEDED (hr);
-}
-
-#if 0
-
-/* Check for filenames like C:\Users\tml\AppData\Local\Temp\d5qtkvvs.bmp */
-static gboolean
-filename_looks_tempish (const char *filename)
-{
-  char *dirname;
-  char *p;
-  const char *q;
-  gboolean retval = FALSE;
-
-  dirname = g_path_get_dirname (filename);
-
-  p = dirname;
-  q = g_get_tmp_dir ();
-
-  while (*p && *q &&
-	 ((G_IS_DIR_SEPARATOR (*p) && G_IS_DIR_SEPARATOR (*q)) ||
-	  g_ascii_tolower (*p) == g_ascii_tolower (*q)))
-    p++, q++;
-
-  if (!*p && !*q)
-    retval = TRUE;
-
-  g_free (dirname);
-
-  return retval;
-}
-
-static gboolean
-close_it (gpointer data)
-{
-  close (GPOINTER_TO_INT (data));
-
-  return FALSE;
-}
-
-#endif
-
-static GdkFilterReturn
-gdk_dropfiles_filter (GdkXEvent *xev,
-		      GdkEvent  *event,
-		      gpointer   data)
-{
-  GdkDragContext *context;
-  GString *result;
-  MSG *msg = (MSG *) xev;
-  HANDLE hdrop;
-  POINT pt;
-  gint nfiles, i;
-  gchar *fileName, *linkedFile;
-
-  if (msg->message == WM_DROPFILES)
-    {
-      GDK_NOTE (DND, g_print ("WM_DROPFILES: %p\n", msg->hwnd));
-
-      context = gdk_drag_context_new ();
-      context->protocol = GDK_DRAG_PROTO_WIN32_DROPFILES;
-      context->is_source = FALSE;
-
-      context->source_window = _gdk_root;
-      g_object_ref (context->source_window);
-
-      context->dest_window = event->any.window;
-      g_object_ref (context->dest_window);
-
-      /* WM_DROPFILES drops are always file names */
-      context->targets =
-	g_list_append (NULL, _text_uri_list);
-      context->actions = GDK_ACTION_COPY;
-      context->suggested_action = GDK_ACTION_COPY;
-      current_dest_drag = context;
-
-      event->dnd.type = GDK_DROP_START;
-      event->dnd.context = current_dest_drag;
-
-      hdrop = (HANDLE) msg->wParam;
-      DragQueryPoint (hdrop, &pt);
-      ClientToScreen (msg->hwnd, &pt);
-
-      event->dnd.x_root = pt.x + _gdk_offset_x;
-      event->dnd.y_root = pt.y + _gdk_offset_y;
-      event->dnd.time = _gdk_win32_get_next_tick (msg->time);
-
-      nfiles = DragQueryFile (hdrop, 0xFFFFFFFF, NULL, 0);
-
-      result = g_string_new (NULL);
-      for (i = 0; i < nfiles; i++)
-	{
-	  gchar *uri;
-	  wchar_t wfn[MAX_PATH];
-
-	  DragQueryFileW (hdrop, i, wfn, MAX_PATH);
-	  fileName = g_utf16_to_utf8 (wfn, -1, NULL, NULL, NULL);
-
-	  /* Resolve shortcuts */
-	  if (resolve_link (msg->hwnd, wfn, &linkedFile))
-	    {
-	      uri = g_filename_to_uri (linkedFile, NULL, NULL);
-	      if (uri != NULL)
-		{
-		  g_string_append (result, uri);
-		  GDK_NOTE (DND, g_print ("... %s link to %s: %s\n",
-					  fileName, linkedFile, uri));
-		  g_free (uri);
-		}
-	      g_free (fileName);
-	      fileName = linkedFile;
-	    }
-	  else
-	    {
-	      uri = g_filename_to_uri (fileName, NULL, NULL);
-	      if (uri != NULL)
-		{
-		  g_string_append (result, uri);
-		  GDK_NOTE (DND, g_print ("... %s: %s\n", fileName, uri));
-		  g_free (uri);
-		}
-	    }
-
-#if 0
-	  /* Awful hack to recognize temp files corresponding to
-	   * images dragged from Firefox... Open the file right here
-	   * so that it is less likely that Firefox manages to delete
-	   * it before the GTK+-using app (typically GIMP) has opened
-	   * it.
-	   *
-	   * Not compiled in for now, because it means images dragged
-	   * from Firefox would stay around in the temp folder which
-	   * is not what Firefox intended. I don't feel comfortable
-	   * with that, both from a geenral sanity point of view, and
-	   * from a privacy point of view. It's better to wait for
-	   * Firefox to fix the problem, for instance by deleting the
-	   * temp file after a longer delay, or to wait until we
-	   * implement the OLE2_DND...
-	   */
-	  if (filename_looks_tempish (fileName))
-	    {
-	      int fd = g_open (fileName, _O_RDONLY|_O_BINARY, 0);
-	      if (fd == -1)
-		{
-		  GDK_NOTE (DND, g_print ("Could not open %s, maybe an image dragged from Firefox that it already deleted\n", fileName));
-		}
-	      else
-		{
-		  GDK_NOTE (DND, g_print ("Opened %s as %d so that Firefox won't delete it\n", fileName, fd));
-		  g_timeout_add_seconds (1, close_it, GINT_TO_POINTER (fd));
-		}
-	    }
-#endif
-
-	  g_free (fileName);
-	  g_string_append (result, "\015\012");
-	}
-      _gdk_dropfiles_store (result->str);
-      g_string_free (result, FALSE);
-
-      DragFinish (hdrop);
-
-      return GDK_FILTER_TRANSLATE;
-    }
-  else
-    return GDK_FILTER_CONTINUE;
-}
-
-static void
-add_format (GArray *fmts,
-	    CLIPFORMAT cf)
-{
-  FORMATETC fmt;
-
-  fmt.cfFormat = cf;
-  fmt.ptd = NULL;
-  fmt.dwAspect = DVASPECT_CONTENT;
-  fmt.lindex = -1;
-  fmt.tymed = TYMED_HGLOBAL;
-
-  g_array_append_val (fmts, fmt);
-}
-
-
-void
-_gdk_dnd_init (void)
-{
-  if (getenv ("GDK_WIN32_USE_EXPERIMENTAL_OLE2_DND"))
-    use_ole2_dnd = TRUE;
-
-  if (use_ole2_dnd)
-    {
-      HRESULT hr;
-      GArray *fmts;
-
-      hr = OleInitialize (NULL);
-
-      if (! SUCCEEDED (hr))
-	g_error ("OleInitialize failed");
-
-      fmts = g_array_new (FALSE, FALSE, sizeof (FORMATETC));
-
-      /* The most important presumably */
-      add_format (fmts, CF_UNICODETEXT);
-
-      /* Used for GTK+ internal DND, I think was the intent? Anyway, code below assumes
-       * this is at index 1.
-       */
-      add_format (fmts, CF_GDIOBJFIRST);
-
-      add_format (fmts, CF_HDROP);
-
-      add_format (fmts, _cf_png);
-      add_format (fmts, CF_DIB);
-
-      add_format (fmts, _cf_url);
-      add_format (fmts, _cf_html_format);
-      add_format (fmts, _cf_text_html);
-
-      nformats = fmts->len;
-      formats = (FORMATETC*) g_array_free (fmts, FALSE);
-
-      target_ctx_for_window = g_hash_table_new (g_direct_hash, g_direct_equal);
-    }
-}
-
-void
-_gdk_win32_dnd_exit (void)
-{
-  if (use_ole2_dnd)
-    {
-      OleUninitialize ();
-    }
-}
-
-/* Source side */
-
-static void
-local_send_leave (GdkDragContext *context,
-		  guint32         time)
-{
-  GdkEvent tmp_event;
-
-  GDK_NOTE (DND, g_print ("local_send_leave: context=%p current_dest_drag=%p\n",
-			  context,
-			  current_dest_drag));
-
-  if ((current_dest_drag != NULL) &&
-      (current_dest_drag->protocol == GDK_DRAG_PROTO_LOCAL) &&
-      (current_dest_drag->source_window == context->source_window))
-    {
-      tmp_event.dnd.type = GDK_DRAG_LEAVE;
-      tmp_event.dnd.window = context->dest_window;
-      /* Pass ownership of context to the event */
-      tmp_event.dnd.send_event = FALSE;
-      tmp_event.dnd.context = current_dest_drag;
-      tmp_event.dnd.time = GDK_CURRENT_TIME; /* FIXME? */
-
-      current_dest_drag = NULL;
-
-      GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-      gdk_event_put (&tmp_event);
-    }
-}
-
-static void
-local_send_enter (GdkDragContext *context,
-		  guint32         time)
-{
-  GdkEvent tmp_event;
-  GdkDragContextPrivateWin32 *private;
-  GdkDragContext *new_context;
-
-  GDK_NOTE (DND, g_print ("local_send_enter: context=%p current_dest_drag=%p\n",
-			  context,
-			  current_dest_drag));
-
-  private = PRIVATE_DATA (context);
-
-  if (current_dest_drag != NULL)
-    {
-      g_object_unref (G_OBJECT (current_dest_drag));
-      current_dest_drag = NULL;
-    }
-
-  new_context = gdk_drag_context_new ();
-  new_context->protocol = GDK_DRAG_PROTO_LOCAL;
-  new_context->is_source = FALSE;
-
-  new_context->source_window = context->source_window;
-  g_object_ref (new_context->source_window);
-
-  new_context->dest_window = context->dest_window;
-  g_object_ref (new_context->dest_window);
-
-  new_context->targets = g_list_copy (context->targets);
-
-  gdk_window_set_events (new_context->source_window,
-			 gdk_window_get_events (new_context->source_window) |
-			 GDK_PROPERTY_CHANGE_MASK);
-  new_context->actions = context->actions;
-
-  tmp_event.type = GDK_DRAG_ENTER;
-  tmp_event.dnd.window = context->dest_window;
-  tmp_event.dnd.send_event = FALSE;
-  tmp_event.dnd.context = new_context;
-  tmp_event.dnd.time = GDK_CURRENT_TIME; /* FIXME? */
-
-  current_dest_drag = new_context;
-
-  GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-  gdk_event_put (&tmp_event);
-}
-
-static void
-local_send_motion (GdkDragContext *context,
-		   gint            x_root,
-		   gint            y_root,
-		   GdkDragAction   action,
-		   guint32         time)
-{
-  GdkEvent tmp_event;
-
-  GDK_NOTE (DND, g_print ("local_send_motion: context=%p (%d,%d) current_dest_drag=%p\n",
-			  context, x_root, y_root,
-			  current_dest_drag));
-
-  if ((current_dest_drag != NULL) &&
-      (current_dest_drag->protocol == GDK_DRAG_PROTO_LOCAL) &&
-      (current_dest_drag->source_window == context->source_window))
-    {
-      tmp_event.type = GDK_DRAG_MOTION;
-      tmp_event.dnd.window = current_dest_drag->dest_window;
-      tmp_event.dnd.send_event = FALSE;
-      tmp_event.dnd.context = current_dest_drag;
-      tmp_event.dnd.time = time;
-
-      current_dest_drag->suggested_action = action;
-
-      tmp_event.dnd.x_root = x_root;
-      tmp_event.dnd.y_root = y_root;
-
-      PRIVATE_DATA (current_dest_drag)->last_pt.x = x_root - _gdk_offset_x;
-      PRIVATE_DATA (current_dest_drag)->last_pt.y = y_root - _gdk_offset_y;
-
-      PRIVATE_DATA (context)->drag_status = GDK_DRAG_STATUS_MOTION_WAIT;
-
-      GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-      gdk_event_put (&tmp_event);
-    }
-}
-
-static void
-local_send_drop (GdkDragContext *context,
-		 guint32         time)
-{
-  GdkEvent tmp_event;
-
-  GDK_NOTE (DND, g_print ("local_send_drop: context=%p current_dest_drag=%p\n",
-			  context,
-			  current_dest_drag));
-
-  if ((current_dest_drag != NULL) &&
-      (current_dest_drag->protocol == GDK_DRAG_PROTO_LOCAL) &&
-      (current_dest_drag->source_window == context->source_window))
-    {
-      GdkDragContextPrivateWin32 *private;
-      private = PRIVATE_DATA (current_dest_drag);
-
-      /* Pass ownership of context to the event */
-      tmp_event.type = GDK_DROP_START;
-      tmp_event.dnd.window = current_dest_drag->dest_window;
-      tmp_event.dnd.send_event = FALSE;
-      tmp_event.dnd.context = current_dest_drag;
-      tmp_event.dnd.time = GDK_CURRENT_TIME;
-
-      tmp_event.dnd.x_root = private->last_pt.x + _gdk_offset_x;
-      tmp_event.dnd.y_root = private->last_pt.y + _gdk_offset_y;
-
-      current_dest_drag = NULL;
-
-      GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-      gdk_event_put (&tmp_event);
-    }
-
-}
-
-static void
-gdk_drag_do_leave (GdkDragContext *context,
-		   guint32         time)
-{
-  if (context->dest_window)
-    {
-      GDK_NOTE (DND, g_print ("gdk_drag_do_leave\n"));
-
-      if (!use_ole2_dnd)
-	{
-	  if (context->protocol == GDK_DRAG_PROTO_LOCAL)
-	    local_send_leave (context, time);
-	}
-
-      g_object_unref (context->dest_window);
-      context->dest_window = NULL;
-    }
-}
-
-GdkDragContext *
-gdk_drag_begin (GdkWindow *window,
-		GList     *targets)
-{
-  if (!use_ole2_dnd)
-    {
-      GdkDragContext *new_context;
-
-      g_return_val_if_fail (window != NULL, NULL);
-
-      new_context = gdk_drag_context_new ();
-
-      new_context->is_source = TRUE;
-
-      new_context->source_window = window;
-      g_object_ref (window);
-
-      new_context->targets = g_list_copy (targets);
-      new_context->actions = 0;
-
-      return new_context;
-    }
-  else
-    {
-      source_drag_context *ctx;
-
-      g_return_val_if_fail (window != NULL, NULL);
-
-      GDK_NOTE (DND, g_print ("gdk_drag_begin\n"));
-
-      ctx = source_context_new (window, targets);
-
-      _dnd_source_state = GDK_WIN32_DND_PENDING;
-
-      pending_src_context = ctx;
-      g_object_ref (ctx->context);
-
-      return ctx->context;
-    }
-}
-
-void
-_gdk_win32_dnd_do_dragdrop (void)
-{
-  if (use_ole2_dnd)
-    {
-      GdkDragContext* drag_ctx;
-      GdkDragContextPrivateWin32 *private;
-      BYTE kbd_state[256];
-      data_object *dobj;
-      HRESULT hr;
-      DWORD dwEffect;
-#if 0
-      HGLOBAL global;
-      STGMEDIUM medium;
-#endif
-
-      if (pending_src_context == NULL)
-	return;
-
-      drag_ctx = pending_src_context->context;
-      private = PRIVATE_DATA (drag_ctx);
-
-      dobj = data_object_new (drag_ctx);
-
-      API_CALL (GetCursorPos, (&private->last_pt));
-      API_CALL (ScreenToClient, (GDK_WINDOW_HWND (drag_ctx->source_window), &private->last_pt));
-      private->last_key_state = 0;
-      API_CALL (GetKeyboardState, (kbd_state));
-
-      if (kbd_state[VK_CONTROL])
-	private->last_key_state |= MK_CONTROL;
-      if (kbd_state[VK_SHIFT])
-	private->last_key_state |= MK_SHIFT;
-      if (kbd_state[VK_LBUTTON])
-	private->last_key_state |= MK_LBUTTON;
-      if (kbd_state[VK_MBUTTON])
-	private->last_key_state |= MK_MBUTTON;
-      if (kbd_state[VK_RBUTTON])
-	private->last_key_state |= MK_RBUTTON;
-
-#if 0
-      global = GlobalAlloc (GMEM_FIXED, sizeof (ctx));
-
-      memcpy (&global, ctx, sizeof (ctx));
-
-      medium.tymed = TYMED_HGLOBAL;
-      medium.hGlobal = global;
-      medium.pUnkForRelease = NULL;
-
-      /* FIXME I wish I remember what I was thinking of here, i.e. what
-       * the formats[1] signifies, i.e. the CF_GDIOBJFIRST FORMATETC?
-       */
-      dobj->ido.lpVtbl->SetData (&dobj->ido, &formats[1], &medium, TRUE);
-#endif
-
-      /* Start dragging with mainloop inside the OLE2 API. Exits only when done */
-
-      GDK_NOTE (DND, g_print ("Calling DoDragDrop\n"));
-
-      _gdk_win32_begin_modal_call ();
-      hr = DoDragDrop (&dobj->ido, &pending_src_context->ids,
-		       DROPEFFECT_COPY | DROPEFFECT_MOVE,
-		       &dwEffect);
-      _gdk_win32_end_modal_call ();
-
-      GDK_NOTE (DND, g_print ("DoDragDrop returned %s\n",
-			      (hr == DRAGDROP_S_DROP ? "DRAGDROP_S_DROP" :
-			       (hr == DRAGDROP_S_CANCEL ? "DRAGDROP_S_CANCEL" :
-				(hr == E_UNEXPECTED ? "E_UNEXPECTED" :
-				 g_strdup_printf ("%#.8lx", hr))))));
-
-      /* Delete dnd selection after successful move */
-      if (hr == DRAGDROP_S_DROP && dwEffect == DROPEFFECT_MOVE)
-	{
-	  GdkEvent tmp_event;
-
-	  tmp_event.type = GDK_SELECTION_REQUEST;
-	  tmp_event.selection.window = drag_ctx->source_window;
-	  tmp_event.selection.send_event = FALSE;
-	  tmp_event.selection.selection = _gdk_ole2_dnd;
-	  tmp_event.selection.target = _delete;
-	  tmp_event.selection.property = _gdk_ole2_dnd; /* ??? */
-	  tmp_event.selection.time = GDK_CURRENT_TIME; /* ??? */
-	  g_object_ref (tmp_event.selection.window);
-
-	  GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-	  gdk_event_put (&tmp_event);
-	}
-
-#if 0
-      // Send a GDK_DROP_FINISHED to the source window
-      GetCursorPos (&pt);
-      ptl.x = pt.x;
-      ptl.y = pt.y;
-      if ( pending_src_context != NULL && pending_src_context->context != NULL
-	   && pending_src_context->context->source_window != NULL )
-	push_dnd_event (GDK_DROP_FINISHED, pending_src_context->context, ptl, FALSE);
-#endif
-
-      dobj->ido.lpVtbl->Release (&dobj->ido);
-      if (pending_src_context != NULL)
-	{
-	  pending_src_context->ids.lpVtbl->Release (&pending_src_context->ids);
-	  pending_src_context = NULL;
-	}
-    }
-}
-
-GdkNativeWindow
-gdk_drag_get_protocol_for_display (GdkDisplay      *display,
-				   GdkNativeWindow  xid,
-				   GdkDragProtocol *protocol)
-{
-  GdkWindow *window;
-
-  window = gdk_window_lookup (xid);
-  if (window &&
-      gdk_window_get_window_type (window) != GDK_WINDOW_FOREIGN)
-    {
-      if (g_object_get_data (G_OBJECT (window), "gdk-dnd-registered") != NULL)
-	{
-	  if (use_ole2_dnd)
-	    *protocol = GDK_DRAG_PROTO_OLE2;
-	  else
-	    *protocol = GDK_DRAG_PROTO_LOCAL;
-
-	  return xid;
-	}
-    }
-
-  return 0;
-}
-
-typedef struct {
-  gint x;
-  gint y;
-  HWND ignore;
-  HWND result;
-} find_window_enum_arg;
-
-static BOOL CALLBACK
-find_window_enum_proc (HWND   hwnd,
-                       LPARAM lparam)
-{
-  RECT rect;
-  POINT tl, br;
-  find_window_enum_arg *a = (find_window_enum_arg *) lparam;
-
-  if (hwnd == a->ignore)
-    return TRUE;
-
-  if (!IsWindowVisible (hwnd))
-    return TRUE;
-
-  tl.x = tl.y = 0;
-  ClientToScreen (hwnd, &tl);
-  GetClientRect (hwnd, &rect);
-  br.x = rect.right;
-  br.y = rect.bottom;
-  ClientToScreen (hwnd, &br);
-
-  if (a->x >= tl.x && a->y >= tl.y && a->x < br.x && a->y < br.y)
-    {
-      a->result = hwnd;
-      return FALSE;
-    }
-  else
-    return TRUE;
-}
-
-void
-gdk_drag_find_window_for_screen (GdkDragContext  *context,
-				 GdkWindow       *drag_window,
-				 GdkScreen       *screen,
-				 gint             x_root,
-				 gint             y_root,
-				 GdkWindow      **dest_window,
-				 GdkDragProtocol *protocol)
-{
-  GdkWindow *dw;
-  find_window_enum_arg a;
-
-  a.x = x_root - _gdk_offset_x;
-  a.y = y_root - _gdk_offset_y;
-  a.ignore = drag_window ? GDK_WINDOW_HWND (drag_window) : NULL;
-  a.result = NULL;
-
-  EnumWindows (find_window_enum_proc, (LPARAM) &a);
-
-  if (a.result == NULL)
-    *dest_window = NULL;
-  else
-    {
-      dw = gdk_win32_handle_table_lookup (a.result);
-      if (dw)
-        {
-          *dest_window = gdk_window_get_toplevel (dw);
-          g_object_ref (*dest_window);
-        }
-      else
-        *dest_window = gdk_window_foreign_new_for_display (_gdk_display, a.result);
-
-      if (use_ole2_dnd)
-        *protocol = GDK_DRAG_PROTO_OLE2;
-      else if (context->source_window)
-        *protocol = GDK_DRAG_PROTO_LOCAL;
-      else
-        *protocol = GDK_DRAG_PROTO_WIN32_DROPFILES;
-    }
-
-  GDK_NOTE (DND,
-	    g_print ("gdk_drag_find_window: %p %+d%+d: %p: %p %s\n",
-		     (drag_window ? GDK_WINDOW_HWND (drag_window) : NULL),
-		     x_root, y_root,
-		     a.result,
-		     (*dest_window ? GDK_WINDOW_HWND (*dest_window) : NULL),
-		     _gdk_win32_drag_protocol_to_string (*protocol)));
-}
-
-gboolean
-gdk_drag_motion (GdkDragContext *context,
-		 GdkWindow      *dest_window,
-		 GdkDragProtocol protocol,
-		 gint            x_root,
-		 gint            y_root,
-		 GdkDragAction   suggested_action,
-		 GdkDragAction   possible_actions,
-		 guint32         time)
-{
-  GdkDragContextPrivateWin32 *private;
-
-  g_return_val_if_fail (context != NULL, FALSE);
-
-  context->actions = possible_actions;
-
-  GDK_NOTE (DND, g_print ("gdk_drag_motion: %s suggested=%s, possible=%s\n"
-			  " context=%p:{actions=%s,suggested=%s,action=%s}\n",
-			  _gdk_win32_drag_protocol_to_string (protocol),
-			  _gdk_win32_drag_action_to_string (suggested_action),
-			  _gdk_win32_drag_action_to_string (possible_actions),
-			  context,
-			  _gdk_win32_drag_action_to_string (context->actions),
-			  _gdk_win32_drag_action_to_string (context->suggested_action),
-			  _gdk_win32_drag_action_to_string (context->action)));
-
-  private = PRIVATE_DATA (context);
-
-  if (!use_ole2_dnd)
-    {
-      if (context->dest_window == dest_window)
-	{
-	  GdkDragContext *dest_context;
-
-	  dest_context = gdk_drag_context_find (FALSE,
-						context->source_window,
-						dest_window);
-
-	  if (dest_context)
-	    dest_context->actions = context->actions;
-
-	  context->suggested_action = suggested_action;
-	}
-      else
-	{
-	  GdkEvent tmp_event;
-
-	  /* Send a leave to the last destination */
-	  gdk_drag_do_leave (context, time);
-	  private->drag_status = GDK_DRAG_STATUS_DRAG;
-
-	  /* Check if new destination accepts drags, and which protocol */
-	  if (dest_window)
-	    {
-	      context->dest_window = dest_window;
-	      g_object_ref (context->dest_window);
-	      context->protocol = protocol;
-
-	      switch (protocol)
-		{
-		case GDK_DRAG_PROTO_LOCAL:
-		  local_send_enter (context, time);
-		  break;
-
-		default:
-		  break;
-		}
-	      context->suggested_action = suggested_action;
-	    }
-	  else
-	    {
-	      context->dest_window = NULL;
-	      context->action = 0;
-	    }
-
-	  /* Push a status event, to let the client know that
-	   * the drag changed
-	   */
-	  tmp_event.type = GDK_DRAG_STATUS;
-	  tmp_event.dnd.window = context->source_window;
-	  /* We use this to signal a synthetic status. Perhaps
-	   * we should use an extra field...
-	   */
-	  tmp_event.dnd.send_event = TRUE;
-
-	  tmp_event.dnd.context = context;
-	  tmp_event.dnd.time = time;
-
-	  GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-	  gdk_event_put (&tmp_event);
-	}
-
-      /* Send a drag-motion event */
-
-      private->last_pt.x = x_root - _gdk_offset_x;
-      private->last_pt.y = y_root - _gdk_offset_y;
-
-      if (context->dest_window)
-	{
-	  if (private->drag_status == GDK_DRAG_STATUS_DRAG)
-	    {
-	      switch (context->protocol)
-		{
-		case GDK_DRAG_PROTO_LOCAL:
-		  local_send_motion (context, x_root, y_root, suggested_action, time);
-		  break;
-
-		case GDK_DRAG_PROTO_NONE:
-		  g_warning ("GDK_DRAG_PROTO_NONE is not valid in gdk_drag_motion()");
-		  break;
-
-		default:
-		  break;
-		}
-	    }
-	  else
-	    {
-	      GDK_NOTE (DND, g_print (" returning TRUE\n"
-				      " context=%p:{actions=%s,suggested=%s,action=%s}\n",
-				      context,
-				      _gdk_win32_drag_action_to_string (context->actions),
-				      _gdk_win32_drag_action_to_string (context->suggested_action),
-				      _gdk_win32_drag_action_to_string (context->action)));
-	      return TRUE;
-	    }
-	}
-    }
-
-  GDK_NOTE (DND, g_print (" returning FALSE\n"
-			  " context=%p:{actions=%s,suggested=%s,action=%s}\n",
-			  context,
-			  _gdk_win32_drag_action_to_string (context->actions),
-			  _gdk_win32_drag_action_to_string (context->suggested_action),
-			  _gdk_win32_drag_action_to_string (context->action)));
-  return FALSE;
-}
-
-void
-gdk_drag_drop (GdkDragContext *context,
-	       guint32         time)
-{
-  g_return_if_fail (context != NULL);
-
-  GDK_NOTE (DND, g_print ("gdk_drag_drop\n"));
-
-  if (!use_ole2_dnd)
-    {
-      if (context->dest_window &&
-	  context->protocol == GDK_DRAG_PROTO_LOCAL)
-	local_send_drop (context, time);
-    }
-  else
-    {
-      _dnd_source_state = GDK_WIN32_DND_DROPPED;
-    }
-}
-
-void
-gdk_drag_abort (GdkDragContext *context,
-		guint32         time)
-{
-  g_return_if_fail (context != NULL);
-
-  GDK_NOTE (DND, g_print ("gdk_drag_abort\n"));
-
-  if (use_ole2_dnd)
-    _dnd_source_state = GDK_WIN32_DND_NONE;
-}
-
-/* Destination side */
-
-void
-gdk_drag_status (GdkDragContext *context,
-		 GdkDragAction   action,
-		 guint32         time)
-{
-  GdkDragContextPrivateWin32 *private;
-  GdkDragContext *src_context;
-  GdkEvent tmp_event;
-
-  g_return_if_fail (context != NULL);
-
-  private = PRIVATE_DATA (context);
-
-  GDK_NOTE (DND, g_print ("gdk_drag_status: %s\n"
-			  " context=%p:{actions=%s,suggested=%s,action=%s}\n",
-			  _gdk_win32_drag_action_to_string (action),
-			  context,
-			  _gdk_win32_drag_action_to_string (context->actions),
-			  _gdk_win32_drag_action_to_string (context->suggested_action),
-			  _gdk_win32_drag_action_to_string (context->action)));
-
-  context->action = action;
-
-  if (!use_ole2_dnd)
-    {
-      src_context = gdk_drag_context_find (TRUE,
-					   context->source_window,
-					   context->dest_window);
-
-      if (src_context)
-	{
-	  GdkDragContextPrivateWin32 *private = PRIVATE_DATA (src_context);
-
-	  if (private->drag_status == GDK_DRAG_STATUS_MOTION_WAIT)
-	    private->drag_status = GDK_DRAG_STATUS_DRAG;
-
-	  tmp_event.type = GDK_DRAG_STATUS;
-	  tmp_event.dnd.window = context->source_window;
-	  tmp_event.dnd.send_event = FALSE;
-	  tmp_event.dnd.context = src_context;
-	  tmp_event.dnd.time = GDK_CURRENT_TIME; /* FIXME? */
-
-	  if (action == GDK_ACTION_DEFAULT)
-	    action = 0;
-
-	  src_context->action = action;
-
-	  GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-	  gdk_event_put (&tmp_event);
-	}
-    }
-}
-
-void
-gdk_drop_reply (GdkDragContext *context,
-		gboolean        ok,
-		guint32         time)
-{
-  g_return_if_fail (context != NULL);
-
-  GDK_NOTE (DND, g_print ("gdk_drop_reply\n"));
-
-  if (!use_ole2_dnd)
-    if (context->dest_window)
-      {
-	if (context->protocol == GDK_DRAG_PROTO_WIN32_DROPFILES)
-	  _gdk_dropfiles_store (NULL);
-      }
-}
-
-void
-gdk_drop_finish (GdkDragContext *context,
-		 gboolean        success,
-		 guint32         time)
-{
-  GdkDragContextPrivateWin32 *private;
-  GdkDragContext *src_context;
-  GdkEvent tmp_event;
-
-  g_return_if_fail (context != NULL);
-
-  GDK_NOTE (DND, g_print ("gdk_drop_finish\n"));
-
-  private = PRIVATE_DATA (context);
-
-  if (!use_ole2_dnd)
-    {
-      src_context = gdk_drag_context_find (TRUE,
-					   context->source_window,
-					   context->dest_window);
-      if (src_context)
-	{
-	  tmp_event.type = GDK_DROP_FINISHED;
-	  tmp_event.dnd.window = src_context->source_window;
-	  tmp_event.dnd.send_event = FALSE;
-	  tmp_event.dnd.context = src_context;
-
-	  GDK_NOTE (EVENTS, _gdk_win32_print_event (&tmp_event));
-	  gdk_event_put (&tmp_event);
-	}
-    }
-  else
-    {
-      gdk_drag_do_leave (context, time);
-
-      if (success)
-	_dnd_target_state = GDK_WIN32_DND_DROPPED;
-      else
-	_dnd_target_state = GDK_WIN32_DND_FAILED;
-    }
-}
-
-#if 0
-
-static GdkFilterReturn
-gdk_destroy_filter (GdkXEvent *xev,
-		    GdkEvent  *event,
-		    gpointer   data)
-{
-  MSG *msg = (MSG *) xev;
-
-  if (msg->message == WM_DESTROY)
-    {
-      IDropTarget *idtp = (IDropTarget *) data;
-
-      GDK_NOTE (DND, g_print ("gdk_destroy_filter: WM_DESTROY: %p\n", msg->hwnd));
-#if 0
-      idtp->lpVtbl->Release (idtp);
-#endif
-      RevokeDragDrop (msg->hwnd);
-      CoLockObjectExternal ((IUnknown*) idtp, FALSE, TRUE);
-    }
-  return GDK_FILTER_CONTINUE;
-}
-
-#endif
-
-void
-gdk_window_register_dnd (GdkWindow *window)
-{
-  target_drag_context *ctx;
-  HRESULT hr;
-
-  g_return_if_fail (window != NULL);
-
-  if (gdk_window_get_window_type (window) == GDK_WINDOW_OFFSCREEN)
-    return;
-
-  if (g_object_get_data (G_OBJECT (window), "gdk-dnd-registered") != NULL)
-    return;
-  else
-    g_object_set_data (G_OBJECT (window), "gdk-dnd-registered", GINT_TO_POINTER (TRUE));
-
-  GDK_NOTE (DND, g_print ("gdk_window_register_dnd: %p\n", GDK_WINDOW_HWND (window)));
-
-  if (!use_ole2_dnd)
-    {
-      /* We always claim to accept dropped files, but in fact we might not,
-       * of course. This function is called in such a way that it cannot know
-       * whether the window (widget) in question actually accepts files
-       * (in gtk, data of type text/uri-list) or not.
-       */
-      gdk_window_add_filter (window, gdk_dropfiles_filter, NULL);
-      DragAcceptFiles (GDK_WINDOW_HWND (window), TRUE);
-    }
-  else
-    {
-      /* Return if window is already setup for DND. */
-      if (g_hash_table_lookup (target_ctx_for_window, GDK_WINDOW_HWND (window)) != NULL)
-	return;
-
-      /* Register for OLE2 d&d : similarly, claim to accept all supported
-       * data types because we cannot know from here what the window
-       * actually accepts.
-       */
-      /* FIXME: This of course won't work with user-extensible data types! */
-      ctx = target_context_new (window);
-
-      hr = CoLockObjectExternal ((IUnknown *) &ctx->idt, TRUE, FALSE);
-      if (!SUCCEEDED (hr))
-	OTHER_API_FAILED ("CoLockObjectExternal");
-      else
-	{
-	  hr = RegisterDragDrop (GDK_WINDOW_HWND (window), &ctx->idt);
-	  if (hr == DRAGDROP_E_ALREADYREGISTERED)
-	    {
-	      g_print ("DRAGDROP_E_ALREADYREGISTERED\n");
-	      CoLockObjectExternal ((IUnknown *) &ctx->idt, FALSE, FALSE);
-	    }
-	  else if (!SUCCEEDED (hr))
-	    OTHER_API_FAILED ("RegisterDragDrop");
-	  else
-	    {
-	      gdk_window_ref (window);
-	      g_hash_table_insert (target_ctx_for_window, GDK_WINDOW_HWND (window), ctx);
-	    }
-	}
-    }
-}
-
-GdkAtom
-gdk_drag_get_selection (GdkDragContext *context)
-{
-  switch (context->protocol)
-    {
-    case GDK_DRAG_PROTO_LOCAL:
-      return _local_dnd;
-    case GDK_DRAG_PROTO_WIN32_DROPFILES:
-      return _gdk_win32_dropfiles;
-    case GDK_DRAG_PROTO_OLE2:
-      return _gdk_ole2_dnd;
-    default:
-      return GDK_NONE;
-    }
-}
-
-gboolean
-gdk_drag_drop_succeeded (GdkDragContext *context)
-{
-  GdkDragContextPrivateWin32 *private;
-
-  g_return_val_if_fail (context != NULL, FALSE);
-
-  private = PRIVATE_DATA (context);
-
-  /* FIXME: Can we set drop_failed when the drop has failed? */
-  return !private->drop_failed;
-}
diff --git a/gdk/win32/gdkdrawable-win32.c b/gdk/win32/gdkdrawable-win32.c
deleted file mode 100644
index f3beada..0000000
--- a/gdk/win32/gdkdrawable-win32.c
+++ /dev/null
@@ -1,2054 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2004 Tor Lillqvist
- * Copyright (C) 2001-2005 Hans Breuer
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <math.h>
-#include <stdio.h>
-#include <glib.h>
-
-#include <pango/pangowin32.h>
-#include <cairo-win32.h>
-
-#include "gdkscreen.h" /* gdk_screen_get_default() */
-#include "gdkregion-generic.h"
-#include "gdkprivate-win32.h"
-
-#define ROP3_D 0x00AA0029
-#define ROP3_DSna 0x00220326
-#define ROP3_DSPDxax 0x00E20746
-
-#define LINE_ATTRIBUTES (GDK_GC_LINE_WIDTH|GDK_GC_LINE_STYLE| \
-			 GDK_GC_CAP_STYLE|GDK_GC_JOIN_STYLE)
-
-#define MUST_RENDER_DASHES_MANUALLY(gcwin32)			\
-  (gcwin32->line_style == GDK_LINE_DOUBLE_DASH ||		\
-   (gcwin32->line_style == GDK_LINE_ON_OFF_DASH && gcwin32->pen_dash_offset))
-
-static void gdk_win32_draw_rectangle (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      gboolean        filled,
-				      gint            x,
-				      gint            y,
-				      gint            width,
-				      gint            height);
-static void gdk_win32_draw_arc       (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      gboolean        filled,
-				      gint            x,
-				      gint            y,
-				      gint            width,
-				      gint            height,
-				      gint            angle1,
-				      gint            angle2);
-static void gdk_win32_draw_polygon   (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      gboolean        filled,
-				      GdkPoint       *points,
-				      gint            npoints);
-static void gdk_win32_draw_text      (GdkDrawable    *drawable,
-				      GdkFont        *font,
-				      GdkGC          *gc,
-				      gint            x,
-				      gint            y,
-				      const gchar    *text,
-				      gint            text_length);
-static void gdk_win32_draw_text_wc   (GdkDrawable    *drawable,
-				      GdkFont        *font,
-				      GdkGC          *gc,
-				      gint            x,
-				      gint            y,
-				      const GdkWChar *text,
-				      gint            text_length);
-static void gdk_win32_draw_drawable  (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      GdkPixmap      *src,
-				      gint            xsrc,
-				      gint            ysrc,
-				      gint            xdest,
-				      gint            ydest,
-				      gint            width,
-				      gint            height,
-				      GdkDrawable    *original_src);
-static void gdk_win32_draw_points    (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      GdkPoint       *points,
-				      gint            npoints);
-static void gdk_win32_draw_segments  (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      GdkSegment     *segs,
-				      gint            nsegs);
-static void gdk_win32_draw_lines     (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      GdkPoint       *points,
-				      gint            npoints);
-static void gdk_win32_draw_image     (GdkDrawable     *drawable,
-				      GdkGC           *gc,
-				      GdkImage        *image,
-				      gint             xsrc,
-				      gint             ysrc,
-				      gint             xdest,
-				      gint             ydest,
-				      gint             width,
-				      gint             height);
-static void gdk_win32_draw_pixbuf     (GdkDrawable     *drawable,
-				      GdkGC           *gc,
-				      GdkPixbuf       *pixbuf,
-				      gint             src_x,
-				      gint             src_y,
-				      gint             dest_x,
-				      gint             dest_y,
-				      gint             width,
-				      gint             height,
-				      GdkRgbDither     dither,
-				      gint             x_dither,
-				      gint             y_dither);
-
-static cairo_surface_t *gdk_win32_ref_cairo_surface (GdkDrawable *drawable);
-     
-static void gdk_win32_set_colormap   (GdkDrawable    *drawable,
-				      GdkColormap    *colormap);
-
-static GdkColormap* gdk_win32_get_colormap   (GdkDrawable    *drawable);
-
-static gint         gdk_win32_get_depth      (GdkDrawable    *drawable);
-
-static GdkScreen *  gdk_win32_get_screen     (GdkDrawable    *drawable);
-
-static GdkVisual*   gdk_win32_get_visual     (GdkDrawable    *drawable);
-
-static void gdk_drawable_impl_win32_finalize   (GObject *object);
-
-static const cairo_user_data_key_t gdk_win32_cairo_key;
-static const cairo_user_data_key_t gdk_win32_cairo_hdc_key;
-
-G_DEFINE_TYPE (GdkDrawableImplWin32,  _gdk_drawable_impl_win32, GDK_TYPE_DRAWABLE)
-
-
-static void
-_gdk_drawable_impl_win32_class_init (GdkDrawableImplWin32Class *klass)
-{
-  GdkDrawableClass *drawable_class = GDK_DRAWABLE_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = gdk_drawable_impl_win32_finalize;
-
-  drawable_class->create_gc = _gdk_win32_gc_new;
-  drawable_class->draw_rectangle = gdk_win32_draw_rectangle;
-  drawable_class->draw_arc = gdk_win32_draw_arc;
-  drawable_class->draw_polygon = gdk_win32_draw_polygon;
-  drawable_class->draw_text = gdk_win32_draw_text;
-  drawable_class->draw_text_wc = gdk_win32_draw_text_wc;
-  drawable_class->draw_drawable_with_src = gdk_win32_draw_drawable;
-  drawable_class->draw_points = gdk_win32_draw_points;
-  drawable_class->draw_segments = gdk_win32_draw_segments;
-  drawable_class->draw_lines = gdk_win32_draw_lines;
-  drawable_class->draw_image = gdk_win32_draw_image;
-  drawable_class->draw_pixbuf = gdk_win32_draw_pixbuf;
-  
-  drawable_class->ref_cairo_surface = gdk_win32_ref_cairo_surface;
-  
-  drawable_class->set_colormap = gdk_win32_set_colormap;
-  drawable_class->get_colormap = gdk_win32_get_colormap;
-
-  drawable_class->get_depth = gdk_win32_get_depth;
-  drawable_class->get_screen = gdk_win32_get_screen;
-  drawable_class->get_visual = gdk_win32_get_visual;
-
-  drawable_class->_copy_to_image = _gdk_win32_copy_to_image;
-}
-
-static void
-_gdk_drawable_impl_win32_init (GdkDrawableImplWin32 *impl)
-{
-}
-
-static void
-gdk_drawable_impl_win32_finalize (GObject *object)
-{
-  gdk_drawable_set_colormap (GDK_DRAWABLE (object), NULL);
-
-  G_OBJECT_CLASS (_gdk_drawable_impl_win32_parent_class)->finalize (object);
-}
-
-/*****************************************************
- * Win32 specific implementations of generic functions *
- *****************************************************/
-
-static GdkColormap*
-gdk_win32_get_colormap (GdkDrawable *drawable)
-{
-  return GDK_DRAWABLE_IMPL_WIN32 (drawable)->colormap;
-}
-
-static void
-gdk_win32_set_colormap (GdkDrawable *drawable,
-			GdkColormap *colormap)
-{
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-
-  if (impl->colormap == colormap)
-    return;
-  
-  if (impl->colormap)
-    g_object_unref (impl->colormap);
-  impl->colormap = colormap;
-  if (impl->colormap)
-    g_object_ref (impl->colormap);
-}
-
-/* Drawing
- */
-
-static int
-rop2_to_rop3 (int rop2)
-{
-  switch (rop2)
-    {
-    /* Oh, Microsoft's silly names for binary and ternary rops. */
-#define CASE(rop2,rop3) case R2_##rop2: return rop3
-      CASE (BLACK, BLACKNESS);
-      CASE (NOTMERGEPEN, NOTSRCERASE);
-      CASE (MASKNOTPEN, 0x00220326);
-      CASE (NOTCOPYPEN, NOTSRCCOPY);
-      CASE (MASKPENNOT, SRCERASE);
-      CASE (NOT, DSTINVERT);
-      CASE (XORPEN, SRCINVERT);
-      CASE (NOTMASKPEN, 0x007700E6);
-      CASE (MASKPEN, SRCAND);
-      CASE (NOTXORPEN, 0x00990066);
-      CASE (NOP, 0x00AA0029);
-      CASE (MERGENOTPEN, MERGEPAINT);
-      CASE (COPYPEN, SRCCOPY);
-      CASE (MERGEPENNOT, 0x00DD0228);
-      CASE (MERGEPEN, SRCPAINT);
-      CASE (WHITE, WHITENESS);
-#undef CASE
-    default: return SRCCOPY;
-    }
-}
-
-static int
-rop2_to_patblt_rop (int rop2)
-{
-  switch (rop2)
-    {
-#define CASE(rop2,patblt_rop) case R2_##rop2: return patblt_rop
-      CASE (COPYPEN, PATCOPY);
-      CASE (XORPEN, PATINVERT);
-      CASE (NOT, DSTINVERT);
-      CASE (BLACK, BLACKNESS);
-      CASE (WHITE, WHITENESS);
-#undef CASE
-    default:
-      g_warning ("Unhandled rop2 in GC to be used in PatBlt: %#x", rop2);
-      return PATCOPY;
-    }
-}
-
-static inline int
-align_with_dash_offset (int a, DWORD *dashes, int num_dashes, GdkGCWin32 *gcwin32)
-{
-  int	   n = 0;
-  int    len_sum = 0;
-  /* 
-   * We can't simply add the dashoffset, it can be an arbitrary larger
-   * or smaller value not even between x1 and x2. It just says use the
-   * dash pattern aligned to the offset. So ensure x1 is smaller _x1
-   * and we start with the appropriate dash.
-   */
-  for (n = 0; n < num_dashes; n++)
-    len_sum += dashes[n];
-  if (   len_sum > 0 /* pathological api usage? */
-      && gcwin32->pen_dash_offset > a)
-    a -= (((gcwin32->pen_dash_offset/len_sum - a/len_sum) + 1) * len_sum);
-  else
-    a = gcwin32->pen_dash_offset;
-
-  return a;
-}
- 
-/* Render a dashed line 'by hand'. Used for all dashes on Win9x (where
- * GDI is way too limited), and for double dashes on all Windowses.
- */
-static inline gboolean
-render_line_horizontal (GdkGCWin32 *gcwin32,
-                        int         x1,
-                        int         x2,
-                        int         y)
-{
-  int n = 0;
-  const int pen_width = MAX (gcwin32->pen_width, 1);
-  const int _x1 = x1;
-
-  g_assert (gcwin32->pen_dashes);
-
-  x1 = align_with_dash_offset (x1, gcwin32->pen_dashes, gcwin32->pen_num_dashes, gcwin32);
-
-  for (n = 0; x1 < x2; n++)
-    {
-      int len = gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-      if (x1 + len > x2)
-        len = x2 - x1;
-
-      if (n % 2 == 0 && x1 + len > _x1)
-        if (!GDI_CALL (PatBlt, (gcwin32->hdc, 
-				x1 < _x1 ? _x1 : x1, 
-				y - pen_width / 2, 
-				len, pen_width, 
-				rop2_to_patblt_rop (gcwin32->rop2))))
-	  return FALSE;
-
-      x1 += gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-    }
-
-  if (gcwin32->line_style == GDK_LINE_DOUBLE_DASH)
-    {
-      HBRUSH hbr;
-
-      if ((hbr = SelectObject (gcwin32->hdc, gcwin32->pen_hbrbg)) == HGDI_ERROR)
-	return FALSE;
-      x1 = _x1;
-      x1 += gcwin32->pen_dash_offset;
-      for (n = 0; x1 < x2; n++)
-	{
-	  int len = gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-	  if (x1 + len > x2)
-	    len = x2 - x1;
-
-	  if (n % 2)
-	    if (!GDI_CALL (PatBlt, (gcwin32->hdc, x1, y - pen_width / 2,
-				    len, pen_width,
-				    rop2_to_patblt_rop (gcwin32->rop2))))
-	      return FALSE;
-
-	  x1 += gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-	}
-      if (SelectObject (gcwin32->hdc, hbr) == HGDI_ERROR)
-	return FALSE;
-    }
-
-  return TRUE;
-}
-
-static inline gboolean
-render_line_vertical (GdkGCWin32 *gcwin32,
-		      int         x,
-                      int         y1,
-                      int         y2)
-{
-  int n;
-  const int pen_width = MAX (gcwin32->pen_width, 1);
-  const int _y1 = y1;
-
-  g_assert (gcwin32->pen_dashes);
-
-  y1 = align_with_dash_offset (y1, gcwin32->pen_dashes, gcwin32->pen_num_dashes, gcwin32);
-  for (n = 0; y1 < y2; n++)
-    {
-      int len = gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-      if (y1 + len > y2)
-        len = y2 - y1;
-      if (n % 2 == 0 && y1 + len > _y1)
-        if (!GDI_CALL (PatBlt, (gcwin32->hdc, x - pen_width / 2, 
-				y1 < _y1 ? _y1 : y1, 
-				pen_width, len, 
-				rop2_to_patblt_rop (gcwin32->rop2))))
-	  return FALSE;
-
-      y1 += gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-    }
-
-  if (gcwin32->line_style == GDK_LINE_DOUBLE_DASH)
-    {
-      HBRUSH hbr;
-
-      if ((hbr = SelectObject (gcwin32->hdc, gcwin32->pen_hbrbg)) == HGDI_ERROR)
-	return FALSE;
-      y1 = _y1;
-      y1 += gcwin32->pen_dash_offset;
-      for (n = 0; y1 < y2; n++)
-	{
-	  int len = gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-	  if (y1 + len > y2)
-	    len = y2 - y1;
-	  if (n % 2)
-	    if (!GDI_CALL (PatBlt, (gcwin32->hdc, x - pen_width / 2, y1,
-				    pen_width, len,
-				    rop2_to_patblt_rop (gcwin32->rop2))))
-	      return FALSE;
-
-	  y1 += gcwin32->pen_dashes[n % gcwin32->pen_num_dashes];
-	}
-      if (SelectObject (gcwin32->hdc, hbr) == HGDI_ERROR)
-	return FALSE;
-    }
-
-  return TRUE;
-}
-
-static void
-draw_tiles_lowlevel (HDC  dest,
-		     HDC  tile,
-		     int  rop3,
-		     gint dest_x,
-		     gint dest_y,
-		     gint tile_x_origin,
-		     gint tile_y_origin,
-		     gint width,
-		     gint height,
-		     gint tile_width,
-		     gint tile_height)
-{
-  gint x, y;
-
-  GDK_NOTE (DRAW, g_print ("draw_tiles_lowlevel: %p %+d%+d tile=%p:%dx%d@%+d%+d %dx%d\n",
-			   dest,
-			   dest_x, dest_y,
-			   tile, tile_width, tile_height,
-			   tile_x_origin, tile_y_origin,
-			   width, height));
-
-  y = tile_y_origin % tile_height;
-  if (y > 0)
-    y -= tile_height;
-  while (y < dest_y + height)
-    {
-      if (y + tile_height >= dest_y)
-	{
-	  x = tile_x_origin % tile_width;
-	  if (x > 0)
-	    x -= tile_width;
-	  while (x < dest_x + width)
-	    {
-	      if (x + tile_width >= dest_x)
-		{
-		  gint src_x = MAX (0, dest_x - x);
-		  gint src_y = MAX (0, dest_y - y);
-
-		  if (!GDI_CALL (BitBlt, (dest, x + src_x, y + src_y,
-					  MIN (tile_width, dest_x + width - (x + src_x)),
-					  MIN (tile_height, dest_y + height - (y + src_y)),
-					  tile,
-					  src_x, src_y,
-					  rop3)))
-		    return;
-		}
-	      x += tile_width;
-	    }
-	}
-      y += tile_height;
-    }
-}
-
-static void
-draw_tiles (GdkDrawable *drawable,
-	    GdkGC       *gc,
-	    int          rop3,
-	    GdkPixmap   *tile,
-	    gint         dest_x,
-	    gint 	 dest_y,
-	    gint 	 tile_x_origin,
-	    gint 	 tile_y_origin,
-	    gint 	 width,
-	    gint 	 height)
-{
-  const GdkGCValuesMask mask = GDK_GC_FOREGROUND;
-  gint tile_width, tile_height;
-  GdkGC *gc_copy;
-  HDC dest_hdc, tile_hdc;
-
-  gc_copy = gdk_gc_new (tile);
-  gdk_gc_copy (gc_copy, gc);
-  dest_hdc = gdk_win32_hdc_get (drawable, gc, mask);
-  tile_hdc = gdk_win32_hdc_get (tile, gc_copy, mask);
-
-  gdk_drawable_get_size (tile, &tile_width, &tile_height);
-
-  draw_tiles_lowlevel (dest_hdc, tile_hdc, rop3,
-		       dest_x, dest_y, tile_x_origin, tile_y_origin,
-		       width, height, tile_width, tile_height);
-
-  gdk_win32_hdc_release (drawable, gc, mask);
-  gdk_win32_hdc_release (tile, gc_copy, mask);
-  g_object_unref (gc_copy);
-}
-
-static void
-generic_draw (GdkDrawable    *drawable,
-	      GdkGC          *gc,
-	      GdkGCValuesMask mask,
-	      void (*function) (GdkGCWin32 *, HDC, gint, gint, va_list),
-	      const GdkRegion *region,
-	      ...)
-{
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-  GdkGCWin32 *gcwin32 = GDK_GC_WIN32 (gc);
-  HDC hdc;
-  va_list args;
-  GdkFill fill_style = _gdk_gc_get_fill (gc);
-
-  va_start (args, region);
-
-  /* If tiled or stippled, draw to a temp pixmap and do blitting magic.
-   */
-
-  if (gcwin32->values_mask & GDK_GC_FILL &&
-      ((fill_style == GDK_TILED &&
-	gcwin32->values_mask & GDK_GC_TILE &&
-	_gdk_gc_get_tile (gc) != NULL)
-       ||
-       ((fill_style == GDK_OPAQUE_STIPPLED ||
-	 fill_style == GDK_STIPPLED) &&
-	gcwin32->values_mask & GDK_GC_STIPPLE &&
-	_gdk_gc_get_stipple (gc) != NULL)))
-    {
-      const GdkGCValuesMask blitting_mask = 0;
-      GdkGCValuesMask drawing_mask = GDK_GC_FOREGROUND;
-      gint ts_x_origin = 0, ts_y_origin = 0;
-
-      gint width = region->extents.x2 - region->extents.x1;
-      gint height = region->extents.y2 - region->extents.y1;
-
-      GdkPixmap *mask_pixmap =
-	gdk_pixmap_new (drawable, width, height, 1);
-      GdkPixmap *tile_pixmap =
-	gdk_pixmap_new (drawable, width, height, -1);
-      GdkPixmap *stipple_bitmap = NULL;
-      GdkColor fg;
-      
-      GdkGC *mask_gc = gdk_gc_new (mask_pixmap);
-      GdkGC *tile_gc = gdk_gc_new (tile_pixmap);
-
-      HDC mask_hdc;
-      HDC tile_hdc;
-
-      GdkGCValues gcvalues;
-
-      hdc = gdk_win32_hdc_get (drawable, gc, blitting_mask);
-      tile_hdc = gdk_win32_hdc_get (tile_pixmap, tile_gc, blitting_mask);
-
-      if (gcwin32->values_mask & GDK_GC_TS_X_ORIGIN)
-	ts_x_origin = gc->ts_x_origin;
-      if (gcwin32->values_mask & GDK_GC_TS_Y_ORIGIN)
-	ts_y_origin = gc->ts_y_origin;
-
-      ts_x_origin -= region->extents.x1;
-      ts_y_origin -= region->extents.y1;
-
-      /* Fill mask bitmap with zeros */
-      gdk_gc_set_function (mask_gc, GDK_CLEAR);
-      gdk_draw_rectangle (mask_pixmap, mask_gc, TRUE,
-			  0, 0, width, height);
-
-      /* Paint into mask bitmap, drawing ones */
-      gdk_gc_set_function (mask_gc, GDK_COPY);
-      fg.pixel = 1;
-      gdk_gc_set_foreground (mask_gc, &fg);
-
-      /* If the drawing function uses line attributes, set them as in
-       * the real GC.
-       */
-      if (mask & LINE_ATTRIBUTES)
-	{
-	  gdk_gc_get_values (gc, &gcvalues);
-	  if (gcvalues.line_width != 0 ||
-	      gcvalues.line_style != GDK_LINE_SOLID ||
-	      gcvalues.cap_style != GDK_CAP_BUTT ||
-	      gcvalues.join_style != GDK_JOIN_MITER)
-	    gdk_gc_set_line_attributes (mask_gc,
-					gcvalues.line_width,
-					gcvalues.line_style,
-					gcvalues.cap_style,
-					gcvalues.join_style);
-	  drawing_mask |= LINE_ATTRIBUTES;
-	}
-
-      /* Ditto, if the drawing function draws text, set up for that. */
-      if (mask & GDK_GC_FONT)
-	drawing_mask |= GDK_GC_FONT;
-
-      mask_hdc = gdk_win32_hdc_get (mask_pixmap, mask_gc, drawing_mask);
-      (*function) (GDK_GC_WIN32 (mask_gc), mask_hdc,
-		   region->extents.x1, region->extents.y1, args);
-      gdk_win32_hdc_release (mask_pixmap, mask_gc, drawing_mask);
-
-      if (fill_style == GDK_TILED)
-	{
-	  /* Tile pixmap with tile */
-	  draw_tiles (tile_pixmap, tile_gc, SRCCOPY,
-		      _gdk_gc_get_tile (gc),
-		      0, 0, ts_x_origin, ts_y_origin,
-		      width, height);
-	}
-      else
-	{
-	  /* Tile with stipple */
-	  GdkGC *stipple_gc;
-
-	  stipple_bitmap = gdk_pixmap_new (NULL, width, height, 1);
-	  stipple_gc = gdk_gc_new (stipple_bitmap);
-
-	  /* Tile stipple bitmap */
-	  draw_tiles (stipple_bitmap, stipple_gc, SRCCOPY,
-		      _gdk_gc_get_stipple (gc),
-		      0, 0, ts_x_origin, ts_y_origin,
-		      width, height);
-
-	  if (fill_style == GDK_OPAQUE_STIPPLED)
-	    {
-	      /* Fill tile pixmap with background */
-	      fg.pixel = _gdk_gc_get_bg_pixel (gc);
-	      gdk_gc_set_foreground (tile_gc, &fg);
-	      gdk_draw_rectangle (tile_pixmap, tile_gc, TRUE,
-				  0, 0, width, height);
-	    }
-	  g_object_unref (stipple_gc);
-	}
-
-      mask_hdc = gdk_win32_hdc_get (mask_pixmap, mask_gc, blitting_mask);
-
-      if (fill_style == GDK_STIPPLED ||
-	  fill_style == GDK_OPAQUE_STIPPLED)
-	{
-	  HDC stipple_hdc;
-	  HBRUSH fg_brush;
-	  HGDIOBJ old_tile_brush;
-	  GdkGC *stipple_gc;
-
-	  stipple_gc = gdk_gc_new (stipple_bitmap);
-	  stipple_hdc = gdk_win32_hdc_get (stipple_bitmap, stipple_gc, blitting_mask);
-
-	  if ((fg_brush = CreateSolidBrush
-	       (_gdk_win32_colormap_color (impl->colormap,
-					   _gdk_gc_get_fg_pixel (gc)))) == NULL)
-	    WIN32_GDI_FAILED ("CreateSolidBrush");
-
-	  if ((old_tile_brush = SelectObject (tile_hdc, fg_brush)) == NULL)
-	    WIN32_GDI_FAILED ("SelectObject");
-
-	  /* Paint tile with foreround where stipple is one
-	   *
-	   *  Desired ternary ROP: (P=foreground, S=stipple, D=destination)
-           *   P   S   D   ?
-           *   0   0   0   0
-           *   0   0   1   1
-           *   0   1   0   0
-           *   0   1   1   0
-           *   1   0   0   0
-           *   1   0   1   1
-           *   1   1   0   1
-           *   1   1   1   1
-	   *
-	   * Reading bottom-up: 11100010 = 0xE2. PSDK docs say this is
-	   * known as DSPDxax, with hex value 0x00E20746.
-	   */
-	  GDI_CALL (BitBlt, (tile_hdc, 0, 0, width, height,
-			     stipple_hdc, 0, 0, ROP3_DSPDxax));
-
-	  if (fill_style == GDK_STIPPLED)
-	    {
-	      /* Punch holes in mask where stipple is zero */
-	      GDI_CALL (BitBlt, (mask_hdc, 0, 0, width, height,
-				 stipple_hdc, 0, 0, SRCAND));
-	    }
-
-	  GDI_CALL (SelectObject, (tile_hdc, old_tile_brush));
-	  GDI_CALL (DeleteObject, (fg_brush));
-	  gdk_win32_hdc_release (stipple_bitmap, stipple_gc, blitting_mask);
-	  g_object_unref (stipple_gc);
-	  g_object_unref (stipple_bitmap);
-	}
-
-      /* Tile pixmap now contains the pattern that we should paint in
-       * the areas where mask is one. (It is filled with said pattern.)
-       */
-
-      GDI_CALL (MaskBlt, (hdc, region->extents.x1, region->extents.y1,
-			  width, height,
-			  tile_hdc, 0, 0,
-			  GDK_PIXMAP_HBITMAP (mask_pixmap), 0, 0,
-			  MAKEROP4 (rop2_to_rop3 (gcwin32->rop2), ROP3_D)));
-
-      /* Cleanup */
-      gdk_win32_hdc_release (mask_pixmap, mask_gc, blitting_mask);
-      g_object_unref (mask_gc);
-      g_object_unref (mask_pixmap);
-      gdk_win32_hdc_release (tile_pixmap, tile_gc, blitting_mask);
-      g_object_unref (tile_gc);
-      g_object_unref (tile_pixmap);
-
-      gdk_win32_hdc_release (drawable, gc, blitting_mask);
-    }
-  else
-    {
-      hdc = gdk_win32_hdc_get (drawable, gc, mask);
-      (*function) (gcwin32, hdc, 0, 0, args);
-      gdk_win32_hdc_release (drawable, gc, mask);
-    }
-  va_end (args);
-}
-
-static GdkRegion *
-widen_bounds (GdkRectangle *bounds,
-	      gint          pen_width)
-{
-  if (pen_width == 0)
-    pen_width = 1;
-
-  bounds->x -= pen_width;
-  bounds->y -= pen_width;
-  bounds->width += 2 * pen_width;
-  bounds->height += 2 * pen_width;
-
-  return gdk_region_rectangle (bounds);
-}
-
-static void
-draw_rectangle (GdkGCWin32 *gcwin32,
-		HDC         hdc,
-		gint        x_offset,
-		gint        y_offset,
-		va_list     args)
-{
-  HGDIOBJ old_pen_or_brush;
-  gboolean filled;
-  gint x;
-  gint y;
-  gint width;
-  gint height;
-
-  filled = va_arg (args, gboolean);
-  x = va_arg (args, gint);
-  y = va_arg (args, gint);
-  width = va_arg (args, gint);
-  height = va_arg (args, gint);
-  
-  x -= x_offset;
-  y -= y_offset;
-
-  if (!filled && MUST_RENDER_DASHES_MANUALLY (gcwin32))
-    {
-      render_line_vertical (gcwin32, x, y, y+height+1) &&
-      render_line_horizontal (gcwin32, x, x+width+1, y) &&
-      render_line_vertical (gcwin32, x+width+1, y, y+height+1) &&
-      render_line_horizontal (gcwin32, x, x+width+1, y+height+1);
-    }
-  else
-    {
-      if (filled)
-	old_pen_or_brush = SelectObject (hdc, GetStockObject (NULL_PEN));
-      else
-	old_pen_or_brush = SelectObject (hdc, GetStockObject (HOLLOW_BRUSH));
-      if (old_pen_or_brush == NULL)
-	WIN32_GDI_FAILED ("SelectObject");
-      else
-	GDI_CALL (Rectangle, (hdc, x, y, x+width+1, y+height+1));
-
-      if (old_pen_or_brush != NULL)
-	GDI_CALL (SelectObject, (hdc, old_pen_or_brush));
-    }
-}
-
-static void
-gdk_win32_draw_rectangle (GdkDrawable *drawable,
-			  GdkGC       *gc,
-			  gboolean     filled,
-			  gint         x,
-			  gint         y,
-			  gint         width,
-			  gint         height)
-{
-  GdkRectangle bounds;
-  GdkRegion *region;
-
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_rectangle: %s (%p) %s%dx%d@%+d%+d\n",
-			   _gdk_win32_drawable_description (drawable),
-			   gc,
-			   (filled ? "fill " : ""),
-			   width, height, x, y));
-    
-  bounds.x = x;
-  bounds.y = y;
-  bounds.width = width;
-  bounds.height = height;
-  region = widen_bounds (&bounds, GDK_GC_WIN32 (gc)->pen_width);
-
-  generic_draw (drawable, gc,
-		GDK_GC_FOREGROUND | GDK_GC_BACKGROUND |
-		(filled ? 0 : LINE_ATTRIBUTES),
-		draw_rectangle, region, filled, x, y, width, height);
-
-  gdk_region_destroy (region);
-}
-
-static void
-draw_arc (GdkGCWin32 *gcwin32,
-	  HDC         hdc,
-	  gint        x_offset,
-	  gint        y_offset,
-	  va_list     args)
-{
-  HGDIOBJ old_pen;
-  gboolean filled;
-  gint x, y;
-  gint width, height;
-  gint angle1, angle2;
-  int nXStartArc, nYStartArc, nXEndArc, nYEndArc;
-
-  filled = va_arg (args, gboolean);
-  x = va_arg (args, gint);
-  y = va_arg (args, gint);
-  width = va_arg (args, gint);
-  height = va_arg (args, gint);
-  angle1 = va_arg (args, gint);
-  angle2 = va_arg (args, gint);
-
-  x -= x_offset;
-  y -= y_offset;
-  
-  if (angle2 >= 360*64)
-    {
-      nXStartArc = nYStartArc = nXEndArc = nYEndArc = 0;
-    }
-  else if (angle2 > 0)
-    {
-      nXStartArc = x + width/2 + width * cos(angle1/64.*2.*G_PI/360.);
-      nYStartArc = y + height/2 + -height * sin(angle1/64.*2.*G_PI/360.);
-      nXEndArc = x + width/2 + width * cos((angle1+angle2)/64.*2.*G_PI/360.);
-      nYEndArc = y + height/2 + -height * sin((angle1+angle2)/64.*2.*G_PI/360.);
-    }
-  else
-    {
-      nXEndArc = x + width/2 + width * cos(angle1/64.*2.*G_PI/360.);
-      nYEndArc = y + height/2 + -height * sin(angle1/64.*2.*G_PI/360.);
-      nXStartArc = x + width/2 + width * cos((angle1+angle2)/64.*2.*G_PI/360.);
-      nYStartArc = y + height/2 + -height * sin((angle1+angle2)/64.*2.*G_PI/360.);
-    }
-  
-  if (filled)
-    {
-      old_pen = SelectObject (hdc, GetStockObject (NULL_PEN));
-      GDK_NOTE (DRAW, g_print ("... Pie(%p,%d,%d,%d,%d,%d,%d,%d,%d)\n",
-			       hdc, x, y, x+width, y+height,
-			       nXStartArc, nYStartArc, nXEndArc, nYEndArc));
-      GDI_CALL (Pie, (hdc, x, y, x+width, y+height,
-		      nXStartArc, nYStartArc, nXEndArc, nYEndArc));
-      GDI_CALL (SelectObject, (hdc, old_pen));
-    }
-  else
-    {
-      GDK_NOTE (DRAW, g_print ("... Arc(%p,%d,%d,%d,%d,%d,%d,%d,%d)\n",
-			       hdc, x, y, x+width, y+height,
-			       nXStartArc, nYStartArc, nXEndArc, nYEndArc));
-      GDI_CALL (Arc, (hdc, x, y, x+width, y+height,
-		      nXStartArc, nYStartArc, nXEndArc, nYEndArc));
-    }
-}
-
-static void
-gdk_win32_draw_arc (GdkDrawable *drawable,
-		    GdkGC       *gc,
-		    gboolean     filled,
-		    gint         x,
-		    gint         y,
-		    gint         width,
-		    gint         height,
-		    gint         angle1,
-		    gint         angle2)
-{
-  GdkRectangle bounds;
-  GdkRegion *region;
-
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_arc: %s  %d,%d,%d,%d  %d %d\n",
-			   _gdk_win32_drawable_description (drawable),
-			   x, y, width, height, angle1, angle2));
-
-  if (width <= 2 || height <= 2 || angle2 == 0)
-    return;
-
-  bounds.x = x;
-  bounds.y = y;
-  bounds.width = width;
-  bounds.height = height;
-  region = widen_bounds (&bounds, GDK_GC_WIN32 (gc)->pen_width);
-
-  generic_draw (drawable, gc,
-		GDK_GC_FOREGROUND | (filled ? 0 : LINE_ATTRIBUTES),
-		draw_arc, region, filled, x, y, width, height, angle1, angle2);
-
-  gdk_region_destroy (region);
-}
-
-static void
-draw_polygon (GdkGCWin32 *gcwin32,
-	      HDC         hdc,
-	      gint        x_offset,
-	      gint        y_offset,
-	      va_list     args)
-{
-  gboolean filled;
-  POINT *pts;
-  HGDIOBJ old_pen_or_brush;
-  gint npoints;
-  gint i;
-
-  filled = va_arg (args, gboolean);
-  pts = va_arg (args, POINT *);
-  npoints = va_arg (args, gint);
-
-  if (x_offset != 0 || y_offset != 0)
-    for (i = 0; i < npoints; i++)
-      {
-	pts[i].x -= x_offset;
-	pts[i].y -= y_offset;
-      }
-
-  if (filled)
-    old_pen_or_brush = SelectObject (hdc, GetStockObject (NULL_PEN));
-  else
-    old_pen_or_brush = SelectObject (hdc, GetStockObject (HOLLOW_BRUSH));
-  if (old_pen_or_brush == NULL)
-    WIN32_GDI_FAILED ("SelectObject");
-  GDI_CALL (Polygon, (hdc, pts, npoints));
-  if (old_pen_or_brush != NULL)
-    GDI_CALL (SelectObject, (hdc, old_pen_or_brush));
-}
-
-static void
-gdk_win32_draw_polygon (GdkDrawable *drawable,
-			GdkGC       *gc,
-			gboolean     filled,
-			GdkPoint    *points,
-			gint         npoints)
-{
-  GdkRectangle bounds;
-  GdkRegion *region;
-  POINT *pts;
-  int i;
-
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_polygon: %s %d points\n",
-			   _gdk_win32_drawable_description (drawable),
-			   npoints));
-
-  if (npoints < 2)
-    return;
-
-  bounds.x = G_MAXINT;
-  bounds.y = G_MAXINT;
-  bounds.width = 0;
-  bounds.height = 0;
-
-  pts = g_new (POINT, npoints);
-
-  for (i = 0; i < npoints; i++)
-    {
-      bounds.x = MIN (bounds.x, points[i].x);
-      bounds.y = MIN (bounds.y, points[i].y);
-      pts[i].x = points[i].x;
-      pts[i].y = points[i].y;
-    }
-
-  for (i = 0; i < npoints; i++)
-    {
-      bounds.width = MAX (bounds.width, points[i].x - bounds.x);
-      bounds.height = MAX (bounds.height, points[i].y - bounds.y);
-    }
-
-  region = widen_bounds (&bounds, GDK_GC_WIN32 (gc)->pen_width);
-
-  generic_draw (drawable, gc,
-		GDK_GC_FOREGROUND | (filled ? 0 : LINE_ATTRIBUTES),
-		draw_polygon, region, filled, pts, npoints);
-
-  gdk_region_destroy (region);
-  g_free (pts);
-}
-
-typedef struct
-{
-  gint x, y;
-  HDC hdc;
-} gdk_draw_text_arg;
-
-static void
-gdk_draw_text_handler (GdkWin32SingleFont *singlefont,
-		       const wchar_t      *wcstr,
-		       int                 wclen,
-		       void               *arg)
-{
-  HGDIOBJ oldfont;
-  SIZE size;
-  gdk_draw_text_arg *argp = (gdk_draw_text_arg *) arg;
-
-  if (!singlefont)
-    return;
-
-  if ((oldfont = SelectObject (argp->hdc, singlefont->hfont)) == NULL)
-    {
-      WIN32_GDI_FAILED ("SelectObject");
-      return;
-    }
-  
-  if (!TextOutW (argp->hdc, argp->x, argp->y, wcstr, wclen))
-    WIN32_GDI_FAILED ("TextOutW");
-  GetTextExtentPoint32W (argp->hdc, wcstr, wclen, &size);
-  argp->x += size.cx;
-
-  SelectObject (argp->hdc, oldfont);
-}
-
-static void
-gdk_win32_draw_text (GdkDrawable *drawable,
-		     GdkFont     *font,
-		     GdkGC       *gc,
-		     gint         x,
-		     gint         y,
-		     const gchar *text,
-		     gint         text_length)
-{
-  const GdkGCValuesMask mask = GDK_GC_FOREGROUND|GDK_GC_FONT;
-  wchar_t *wcstr, wc;
-  glong wlen;
-  gdk_draw_text_arg arg;
-
-  if (text_length == 0)
-    return;
-
-  g_assert (font->type == GDK_FONT_FONT || font->type == GDK_FONT_FONTSET);
-
-  arg.x = x;
-  arg.y = y;
-  arg.hdc = gdk_win32_hdc_get (drawable, gc, mask);
-
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_text: %s (%d,%d) \"%.*s\" (len %d)\n",
-			   _gdk_win32_drawable_description (drawable),
-			   x, y,
-			   (text_length > 10 ? 10 : text_length),
-			   text, text_length));
-  
-  if (text_length == 1)
-    {
-      /* For single characters, don't try to interpret as UTF-8. */
-      wc = (guchar) text[0];
-      _gdk_wchar_text_handle (font, &wc, 1, gdk_draw_text_handler, &arg);
-    }
-  else
-    {
-      wcstr = g_utf8_to_utf16 (text, text_length, NULL, &wlen, NULL);
-      _gdk_wchar_text_handle (font, wcstr, wlen, gdk_draw_text_handler, &arg);
-      g_free (wcstr);
-    }
-
-  gdk_win32_hdc_release (drawable, gc, mask);
-}
-
-static void
-gdk_win32_draw_text_wc (GdkDrawable	 *drawable,
-			GdkFont          *font,
-			GdkGC		 *gc,
-			gint		  x,
-			gint		  y,
-			const GdkWChar *text,
-			gint		  text_length)
-{
-  const GdkGCValuesMask mask = GDK_GC_FOREGROUND|GDK_GC_FONT;
-  gint i;
-  wchar_t *wcstr;
-  gdk_draw_text_arg arg;
-
-  if (text_length == 0)
-    return;
-
-  g_assert (font->type == GDK_FONT_FONT || font->type == GDK_FONT_FONTSET);
-
-  arg.x = x;
-  arg.y = y;
-  arg.hdc = gdk_win32_hdc_get (drawable, gc, mask);
-
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_text_wc: %s (%d,%d) len: %d\n",
-			   _gdk_win32_drawable_description (drawable),
-			   x, y, text_length));
-      
-  if (sizeof (wchar_t) != sizeof (GdkWChar))
-    {
-      wcstr = g_new (wchar_t, text_length);
-      for (i = 0; i < text_length; i++)
-	wcstr[i] = text[i];
-    }
-  else
-    wcstr = (wchar_t *) text;
-
-  _gdk_wchar_text_handle (font, wcstr, text_length,
-			 gdk_draw_text_handler, &arg);
-
-  if (sizeof (wchar_t) != sizeof (GdkWChar))
-    g_free (wcstr);
-
-  gdk_win32_hdc_release (drawable, gc, mask);
-}
-
-static void
-gdk_win32_draw_drawable (GdkDrawable *drawable,
-			 GdkGC       *gc,
-			 GdkPixmap   *src,
-			 gint         xsrc,
-			 gint         ysrc,
-			 gint         xdest,
-			 gint         ydest,
-			 gint         width,
-			 gint         height,
-			 GdkDrawable *original_src)
-{
-  g_assert (GDK_IS_DRAWABLE_IMPL_WIN32 (drawable));
-
-  _gdk_win32_blit (FALSE, (GdkDrawableImplWin32 *) drawable,
-		   gc, src, xsrc, ysrc,
-		   xdest, ydest, width, height);
-}
-
-static void
-gdk_win32_draw_points (GdkDrawable *drawable,
-		       GdkGC       *gc,
-		       GdkPoint    *points,
-		       gint         npoints)
-{
-  HDC hdc;
-  HGDIOBJ old_pen;
-  int i;
-
-  hdc = gdk_win32_hdc_get (drawable, gc, GDK_GC_FOREGROUND);
-  
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_points: %s %d points\n",
-			   _gdk_win32_drawable_description (drawable),
-			   npoints));
-
-  /* The X11 version uses XDrawPoint(), which doesn't use the fill
-   * mode, so don't use generic_draw. But we should use the current
-   * function, so we can't use SetPixel(). Draw single-pixel
-   * rectangles (sigh).
-   */
-
-  old_pen = SelectObject (hdc, GetStockObject (NULL_PEN));
-  for (i = 0; i < npoints; i++)
-    Rectangle (hdc, points[i].x, points[i].y,
-	       points[i].x + 2, points[i].y + 2);
-
-  SelectObject (hdc, old_pen);
-  gdk_win32_hdc_release (drawable, gc, GDK_GC_FOREGROUND);
-}
-
-static void
-draw_segments (GdkGCWin32 *gcwin32,
-	       HDC         hdc,
-	       gint        x_offset,
-	       gint        y_offset,
-	       va_list     args)
-{
-  GdkSegment *segs;
-  gint nsegs;
-  gint i;
-
-  segs = va_arg (args, GdkSegment *);
-  nsegs = va_arg (args, gint);
-
-  if (x_offset != 0 || y_offset != 0)
-    {
-      /* must not modify in place, but could splice in the offset all below */
-      segs = g_memdup (segs, nsegs * sizeof (GdkSegment));
-      for (i = 0; i < nsegs; i++)
-        {
-          segs[i].x1 -= x_offset;
-          segs[i].y1 -= y_offset;
-          segs[i].x2 -= x_offset;
-          segs[i].y2 -= y_offset;
-        }
-    }
-
-  if (MUST_RENDER_DASHES_MANUALLY (gcwin32))
-    {
-      for (i = 0; i < nsegs; i++)
-	{
-	  if (segs[i].x1 == segs[i].x2)
-	    {
-	      int y1, y2;
-	      
-	      if (segs[i].y1 <= segs[i].y2)
-		y1 = segs[i].y1, y2 = segs[i].y2;
-	      else
-		y1 = segs[i].y2, y2 = segs[i].y1;
-	      
-	      render_line_vertical (gcwin32, segs[i].x1, y1, y2);
-	    }
-	  else if (segs[i].y1 == segs[i].y2)
-	    {
-	      int x1, x2;
-	      
-	      if (segs[i].x1 <= segs[i].x2)
-		x1 = segs[i].x1, x2 = segs[i].x2;
-	      else
-		x1 = segs[i].x2, x2 = segs[i].x1;
-	      
-	      render_line_horizontal (gcwin32, x1, x2, segs[i].y1);
-	    }
-	  else
-	    GDI_CALL (MoveToEx, (hdc, segs[i].x1, segs[i].y1, NULL)) &&
-	      GDI_CALL (LineTo, (hdc, segs[i].x2, segs[i].y2));
-	}
-    }
-  else
-    {
-      for (i = 0; i < nsegs; i++)
-	{
-	  const GdkSegment *ps = &segs[i];
-	  const int x1 = ps->x1, y1 = ps->y1;
-	  int x2 = ps->x2, y2 = ps->y2;
-
-	  GDK_NOTE (DRAW, g_print (" +%d+%d..+%d+%d", x1, y1, x2, y2));
-	  GDI_CALL (MoveToEx, (hdc, x1, y1, NULL)) &&
-	    GDI_CALL (LineTo, (hdc, x2, y2));
-	}
-
-      GDK_NOTE (DRAW, g_print ("\n"));
-    }
-  if (x_offset != 0 || y_offset != 0)
-    g_free (segs);
-}
-
-static void
-gdk_win32_draw_segments (GdkDrawable *drawable,
-			 GdkGC       *gc,
-			 GdkSegment  *segs,
-			 gint         nsegs)
-{
-  GdkRectangle bounds;
-  GdkRegion *region;
-  gint i;
-
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_segments: %s %d segs\n",
-			   _gdk_win32_drawable_description (drawable),
-			   nsegs));
-
-  bounds.x = G_MAXINT;
-  bounds.y = G_MAXINT;
-  bounds.width = 0;
-  bounds.height = 0;
-
-  for (i = 0; i < nsegs; i++)
-    {
-      bounds.x = MIN (bounds.x, segs[i].x1);
-      bounds.x = MIN (bounds.x, segs[i].x2);
-      bounds.y = MIN (bounds.y, segs[i].y1);
-      bounds.y = MIN (bounds.y, segs[i].y2);
-    }
-
-  for (i = 0; i < nsegs; i++)
-    {
-      bounds.width = MAX (bounds.width, segs[i].x1 - bounds.x);
-      bounds.width = MAX (bounds.width, segs[i].x2 - bounds.x);
-      bounds.height = MAX (bounds.height, segs[i].y1 - bounds.y);
-      bounds.height = MAX (bounds.height, segs[i].y2 - bounds.y);
-    }
-
-  region = widen_bounds (&bounds, GDK_GC_WIN32 (gc)->pen_width);
-
-  generic_draw (drawable, gc, GDK_GC_FOREGROUND | LINE_ATTRIBUTES,
-		draw_segments, region, segs, nsegs);
-
-  gdk_region_destroy (region);
-}
-
-static void
-draw_lines (GdkGCWin32 *gcwin32,
-	    HDC         hdc,
-	    gint        x_offset,
-	    gint        y_offset,
-	    va_list     args)
-{
-  POINT *pts;
-  gint npoints;
-  gint i;
-
-  pts = va_arg (args, POINT *);
-  npoints = va_arg (args, gint);
-
-  if (x_offset != 0 || y_offset != 0)
-    for (i = 0; i < npoints; i++)
-      {
-	pts[i].x -= x_offset;
-	pts[i].y -= y_offset;
-      }
-  
-  if (MUST_RENDER_DASHES_MANUALLY (gcwin32))
-    {
-      for (i = 0; i < npoints - 1; i++)
-        {
-	  if (pts[i].x == pts[i+1].x)
-	    {
-	      int y1, y2;
-	      if (pts[i].y > pts[i+1].y)
-	        y1 = pts[i+1].y, y2 = pts[i].y;
-	      else
-	        y1 = pts[i].y, y2 = pts[i+1].y;
-	      
-	      render_line_vertical (gcwin32, pts[i].x, y1, y2);
-	    }
-	  else if (pts[i].y == pts[i+1].y)
-	    {
-	      int x1, x2;
-	      if (pts[i].x > pts[i+1].x)
-	        x1 = pts[i+1].x, x2 = pts[i].x;
-	      else
-	        x1 = pts[i].x, x2 = pts[i+1].x;
-
-	      render_line_horizontal (gcwin32, x1, x2, pts[i].y);
-	    }
-	  else
-	    GDI_CALL (MoveToEx, (hdc, pts[i].x, pts[i].y, NULL)) &&
-	      GDI_CALL (LineTo, (hdc, pts[i+1].x, pts[i+1].y));
-	}
-    }
-  else
-    GDI_CALL (Polyline, (hdc, pts, npoints));
-}
-
-static void
-gdk_win32_draw_lines (GdkDrawable *drawable,
-		      GdkGC       *gc,
-		      GdkPoint    *points,
-		      gint         npoints)
-{
-  GdkRectangle bounds;
-  GdkRegion *region;
-  POINT *pts;
-  int i;
-
-  GDK_NOTE (DRAW, g_print ("gdk_win32_draw_lines: %s %d points\n",
-			   _gdk_win32_drawable_description (drawable),
-			   npoints));
-
-  if (npoints < 2)
-    return;
-
-  bounds.x = G_MAXINT;
-  bounds.y = G_MAXINT;
-  bounds.width = 0;
-  bounds.height = 0;
-
-  pts = g_new (POINT, npoints);
-
-  for (i = 0; i < npoints; i++)
-    {
-      bounds.x = MIN (bounds.x, points[i].x);
-      bounds.y = MIN (bounds.y, points[i].y);
-      pts[i].x = points[i].x;
-      pts[i].y = points[i].y;
-    }
-
-  for (i = 0; i < npoints; i++)
-    {
-      bounds.width = MAX (bounds.width, points[i].x - bounds.x);
-      bounds.height = MAX (bounds.height, points[i].y - bounds.y);
-    }
-
-  region = widen_bounds (&bounds, GDK_GC_WIN32 (gc)->pen_width);
-
-  generic_draw (drawable, gc, GDK_GC_FOREGROUND | GDK_GC_BACKGROUND |
-			      LINE_ATTRIBUTES,
-		draw_lines, region, pts, npoints);
-
-  gdk_region_destroy (region);
-  g_free (pts);
-}
-
-static void
-blit_from_pixmap (gboolean              use_fg_bg,
-		  GdkDrawableImplWin32 *dest,
-		  HDC                   hdc,
-		  GdkPixmapImplWin32   *src,
-		  GdkGC                *gc,
-		  gint         	      	xsrc,
-		  gint         	      	ysrc,
-		  gint         	      	xdest,
-		  gint         	      	ydest,
-		  gint         	      	width,
-		  gint         	      	height)
-{
-  GdkGCWin32 *gcwin32 = GDK_GC_WIN32 (gc);
-  HDC srcdc;
-  HBITMAP holdbitmap;
-  RGBQUAD oldtable[256], newtable[256];
-  COLORREF bg, fg;
-
-  gint newtable_size = 0, oldtable_size = 0;
-  gboolean ok = TRUE;
-  
-  GDK_NOTE (DRAW, g_print ("blit_from_pixmap\n"));
-
-  srcdc = _gdk_win32_drawable_acquire_dc (GDK_DRAWABLE (src));
-  if (!srcdc)
-    return;
-  
-  if (!(holdbitmap = SelectObject (srcdc, ((GdkDrawableImplWin32 *) src)->handle)))
-    WIN32_GDI_FAILED ("SelectObject");
-  else
-    {
-      if (GDK_PIXMAP_OBJECT (src->parent_instance.wrapper)->depth <= 8)
-	{
-	  /* Blitting from a 1, 4 or 8-bit pixmap */
-
-	  if ((oldtable_size = GetDIBColorTable (srcdc, 0, 256, oldtable)) == 0)
-	    WIN32_GDI_FAILED ("GetDIBColorTable");
-	  else if (GDK_PIXMAP_OBJECT (src->parent_instance.wrapper)->depth == 1)
-	    {
-	      /* Blitting from an 1-bit pixmap */
-
-	      gint bgix, fgix;
-	      
-	      if (use_fg_bg)
-		{
-		  bgix = _gdk_gc_get_bg_pixel (gc);
-		  fgix = _gdk_gc_get_fg_pixel (gc);
-		}
-	      else
-		{
-		  bgix = 0;
-		  fgix = 1;
-		}
-	      
-	      if (GDK_IS_PIXMAP_IMPL_WIN32 (dest) &&
-		  GDK_PIXMAP_OBJECT (dest->wrapper)->depth <= 8)
-		{
-		  /* Destination is also pixmap, get fg and bg from
-		   * its palette. Either use the foreground and
-		   * background pixel values in the GC (only in the
-		   * case of gdk_image_put(), cf. XPutImage()), or 0
-		   * and 1 to index the palette.
-		   */
-		  if (!GDI_CALL (GetDIBColorTable, (hdc, bgix, 1, newtable)) ||
-		      !GDI_CALL (GetDIBColorTable, (hdc, fgix, 1, newtable+1)))
-		    ok = FALSE;
-		}
-	      else
-		{
-		  /* Destination is a window, get fg and bg from its
-		   * colormap
-		   */
-
-		  bg = _gdk_win32_colormap_color (dest->colormap, bgix);
-		  fg = _gdk_win32_colormap_color (dest->colormap, fgix);
-		  newtable[0].rgbBlue = GetBValue (bg);
-		  newtable[0].rgbGreen = GetGValue (bg);
-		  newtable[0].rgbRed = GetRValue (bg);
-		  newtable[0].rgbReserved = 0;
-		  newtable[1].rgbBlue = GetBValue (fg);
-		  newtable[1].rgbGreen = GetGValue (fg);
-		  newtable[1].rgbRed = GetRValue (fg);
-		  newtable[1].rgbReserved = 0;
-		}
-	      if (ok)
-		GDK_NOTE (DRAW, g_print ("bg: %02x %02x %02x "
-					 "fg: %02x %02x %02x\n",
-					 newtable[0].rgbRed,
-					 newtable[0].rgbGreen,
-					 newtable[0].rgbBlue,
-					 newtable[1].rgbRed,
-					 newtable[1].rgbGreen,
-					 newtable[1].rgbBlue));
-	      newtable_size = 2;
-	    }
-	  else if (GDK_IS_PIXMAP_IMPL_WIN32 (dest))
-	    {
-	      /* Destination is pixmap, get its color table */
-	      
-	      if ((newtable_size = GetDIBColorTable (hdc, 0, 256, newtable)) == 0)
-		WIN32_GDI_FAILED ("GetDIBColorTable"), ok = FALSE;
-	    }
-	  
-	  /* If blitting between pixmaps, set source's color table */
-	  if (ok && newtable_size > 0)
-	    {
-	      GDK_NOTE (MISC_OR_COLORMAP,
-			g_print ("blit_from_pixmap: set color table"
-				 " hdc=%p count=%d\n",
-				 srcdc, newtable_size));
-	      if (!GDI_CALL (SetDIBColorTable, (srcdc, 0, newtable_size, newtable)))
-		ok = FALSE;
-	    }
-	}
-      
-      if (ok)
-	if (!BitBlt (hdc, xdest, ydest, width, height,
-		     srcdc, xsrc, ysrc, rop2_to_rop3 (gcwin32->rop2)) &&
-	    GetLastError () != ERROR_INVALID_HANDLE)
-	  WIN32_GDI_FAILED ("BitBlt");
-      
-      /* Restore source's color table if necessary */
-      if (ok && newtable_size > 0 && oldtable_size > 0)
-	{
-	  GDK_NOTE (MISC_OR_COLORMAP,
-		    g_print ("blit_from_pixmap: reset color table"
-			     " hdc=%p count=%d\n",
-			     srcdc, oldtable_size));
-	  GDI_CALL (SetDIBColorTable, (srcdc, 0, oldtable_size, oldtable));
-	}
-      
-      GDI_CALL (SelectObject, (srcdc, holdbitmap));
-    }
-  
-  _gdk_win32_drawable_release_dc (GDK_DRAWABLE (src));
-}
-
-static void
-blit_inside_drawable (HDC                   hdc,
-                      GdkGCWin32           *gcwin32,
-                      GdkDrawableImplWin32 *src,
-                      gint                  xsrc,
-                      gint                  ysrc,
-                      gint                  xdest,
-                      gint                  ydest,
-                      gint                  width,
-                      gint                  height)
-
-{
-  GDK_NOTE (DRAW, g_print ("blit_inside_drawable\n"));
-
-  if GDK_IS_WINDOW_IMPL_WIN32 (src)
-    {
-      /* Simply calling BitBlt() instead of these ScrollDC() gymnastics might
-       * seem tempting, but we need to do this to prevent blitting garbage when
-       * scrolling a window that is partially obscured by another window. For
-       * example, GIMP's toolbox being over the editor window. */
-
-      RECT emptyRect, clipRect;
-      HRGN updateRgn;
-      GdkRegion *update_region;
-
-      clipRect.left = xdest;
-      clipRect.top = ydest;
-      clipRect.right = xdest + width;
-      clipRect.bottom = ydest + height;
-
-      SetRectEmpty (&emptyRect);
-      updateRgn = CreateRectRgnIndirect (&emptyRect);
-
-      if (!ScrollDC (hdc, xdest - xsrc, ydest - ysrc, NULL, &clipRect, updateRgn, NULL))
-        WIN32_GDI_FAILED ("ScrollDC");
-      else
-	{
-	  GdkDrawable *wrapper = src->wrapper;
-	  update_region = _gdk_win32_hrgn_to_region (updateRgn);
-	  if (!gdk_region_empty (update_region))
-	    _gdk_window_invalidate_for_expose (GDK_WINDOW (wrapper), update_region);
-	  gdk_region_destroy (update_region);
-	}
-
-      if (!DeleteObject (updateRgn))
-        WIN32_GDI_FAILED ("DeleteObject");
-    }
-  else
-    {
-      GDI_CALL (BitBlt, (hdc, xdest, ydest, width, height,
-                         hdc, xsrc, ysrc, rop2_to_rop3 (gcwin32->rop2)));
-    }
-}
-
-static void
-blit_from_window (HDC                   hdc,
-		  GdkGCWin32           *gcwin32,
-		  GdkDrawableImplWin32 *src,
-		  gint         	      	xsrc,
-		  gint         	      	ysrc,
-		  gint         	      	xdest,
-		  gint         	      	ydest,
-		  gint         	      	width,
-		  gint         	      	height)
-{
-  HDC srcdc;
-  HPALETTE holdpal = NULL;
-  GdkColormap *cmap = gdk_colormap_get_system ();
-
-  GDK_NOTE (DRAW, g_print ("blit_from_window\n"));
-
-  if ((srcdc = GetDC (src->handle)) == NULL)
-    {
-      WIN32_GDI_FAILED ("GetDC");
-      return;
-    }
-
-  if (cmap->visual->type == GDK_VISUAL_PSEUDO_COLOR ||
-      cmap->visual->type == GDK_VISUAL_STATIC_COLOR)
-    {
-      gint k;
-      
-      if (!(holdpal = SelectPalette (srcdc, GDK_WIN32_COLORMAP_DATA (cmap)->hpal, FALSE)))
-	WIN32_GDI_FAILED ("SelectPalette");
-      else if ((k = RealizePalette (srcdc)) == GDI_ERROR)
-	WIN32_GDI_FAILED ("RealizePalette");
-      else if (k > 0)
-	GDK_NOTE (MISC_OR_COLORMAP,
-		  g_print ("blit_from_window: realized %d\n", k));
-    }
-  
-  GDI_CALL (BitBlt, (hdc, xdest, ydest, width, height,
-		     srcdc, xsrc, ysrc, rop2_to_rop3 (gcwin32->rop2)));
-  
-  if (holdpal != NULL)
-    GDI_CALL (SelectPalette, (srcdc, holdpal, FALSE));
-  
-  GDI_CALL (ReleaseDC, (src->handle, srcdc));
-}
-
-void
-_gdk_win32_blit (gboolean              use_fg_bg,
-		 GdkDrawableImplWin32 *draw_impl,
-		 GdkGC       	      *gc,
-		 GdkDrawable 	      *src,
-		 gint        	       xsrc,
-		 gint        	       ysrc,
-		 gint        	       xdest,
-		 gint        	       ydest,
-		 gint        	       width,
-		 gint        	       height)
-{
-  HDC hdc;
-  HRGN src_rgn, draw_rgn, outside_rgn;
-  RECT r;
-  GdkDrawableImplWin32 *src_impl = NULL;
-  gint src_width, src_height;
-  
-  GDK_NOTE (DRAW, g_print ("_gdk_win32_blit: src:%s %dx%d@%+d%+d\n"
-			   "                 dst:%s @%+d%+d use_fg_bg=%d\n",
-			   _gdk_win32_drawable_description (src),
-			   width, height, xsrc, ysrc,
-			   _gdk_win32_drawable_description (&draw_impl->parent_instance),
-			   xdest, ydest,
-			   use_fg_bg));
-
-  /* If blitting from the root window, take the multi-monitor offset
-   * into account.
-   */
-  if (src == ((GdkWindowObject *)_gdk_root)->impl)
-    {
-      GDK_NOTE (DRAW, g_print ("... offsetting src coords\n"));
-      xsrc -= _gdk_offset_x;
-      ysrc -= _gdk_offset_y;
-    }
-
-  if (GDK_IS_DRAWABLE_IMPL_WIN32 (src))
-    src_impl = (GdkDrawableImplWin32 *) src;
-  else if (GDK_IS_WINDOW (src))
-    src_impl = (GdkDrawableImplWin32 *) GDK_WINDOW_OBJECT (src)->impl;
-  else if (GDK_IS_PIXMAP (src))
-    src_impl = (GdkDrawableImplWin32 *) GDK_PIXMAP_OBJECT (src)->impl;
-  else
-    g_assert_not_reached ();
-
-  if (GDK_IS_WINDOW_IMPL_WIN32 (draw_impl) &&
-      GDK_IS_PIXMAP_IMPL_WIN32 (src_impl))
-    {
-      GdkPixmapImplWin32 *src_pixmap = GDK_PIXMAP_IMPL_WIN32 (src_impl);
-
-      if (xsrc < 0)
-	{
-	  width += xsrc;
-	  xdest -= xsrc;
-	  xsrc = 0;
-	}
-
-      if (ysrc < 0)
-	{
-	  height += ysrc;
-	  ydest -= ysrc;
-	  ysrc = 0;
-	}
-
-      if (xsrc + width > src_pixmap->width)
-	width = src_pixmap->width - xsrc;
-      if (ysrc + height > src_pixmap->height)
-	height = src_pixmap->height - ysrc;
-    }
-
-  hdc = gdk_win32_hdc_get (&draw_impl->parent_instance, gc, GDK_GC_FOREGROUND);
-
-  gdk_drawable_get_size (src_impl->wrapper, &src_width, &src_height);
-
-  if ((src_rgn = CreateRectRgn (0, 0, src_width + 1, src_height + 1)) == NULL)
-    {
-      WIN32_GDI_FAILED ("CreateRectRgn");
-    }
-  else if ((draw_rgn = CreateRectRgn (xsrc, ysrc,
-				      xsrc + width + 1,
-				      ysrc + height + 1)) == NULL)
-    {
-      WIN32_GDI_FAILED ("CreateRectRgn");
-    }
-  else
-    {
-      if (GDK_IS_WINDOW_IMPL_WIN32 (draw_impl))
-	{
-	  int comb;
-	  
-	  /* If we are drawing on a window, calculate the region that is
-	   * outside the source pixmap, and invalidate that, causing it to
-	   * be cleared. Not completely sure whether this is always needed. XXX
-	   */
-	  SetRectEmpty (&r);
-	  outside_rgn = CreateRectRgnIndirect (&r);
-	  
-	  if ((comb = CombineRgn (outside_rgn,
-				  draw_rgn, src_rgn,
-				  RGN_DIFF)) == ERROR)
-	    WIN32_GDI_FAILED ("CombineRgn");
-	  else if (comb != NULLREGION)
-	    {
-	      OffsetRgn (outside_rgn, xdest, ydest);
-	      GDK_NOTE (DRAW, (GetRgnBox (outside_rgn, &r),
-			       g_print ("... InvalidateRgn "
-					"bbox: %ldx%ld@%+ld%+ld\n",
-					r.right - r.left - 1, r.bottom - r.top - 1,
-					r.left, r.top)));
-	      InvalidateRgn (draw_impl->handle, outside_rgn, TRUE);
-	    }
-	  GDI_CALL (DeleteObject, (outside_rgn));
-	}
-
-#if 1 /* Don't know if this is necessary XXX */
-      if (CombineRgn (draw_rgn, draw_rgn, src_rgn, RGN_AND) == COMPLEXREGION)
-	g_warning ("gdk_win32_blit: CombineRgn returned a COMPLEXREGION");
-      
-      GetRgnBox (draw_rgn, &r);
-      if (r.left != xsrc || r.top != ysrc ||
-	  r.right != xsrc + width + 1 || r.bottom != ysrc + height + 1)
-	{
-	  xdest += r.left - xsrc;
-	  xsrc = r.left;
-	  ydest += r.top - ysrc;
-	  ysrc = r.top;
-	  width = r.right - xsrc - 1;
-	  height = r.bottom - ysrc - 1;
-	  
-	  GDK_NOTE (DRAW, g_print ("... restricted to src: %dx%d@%+d%+d, "
-				   "dest: @%+d%+d\n",
-				   width, height, xsrc, ysrc,
-				   xdest, ydest));
-	}
-#endif
-
-      GDI_CALL (DeleteObject, (src_rgn));
-      GDI_CALL (DeleteObject, (draw_rgn));
-    }
-
-  if (draw_impl->handle == src_impl->handle)
-    blit_inside_drawable (hdc, GDK_GC_WIN32 (gc), src_impl,
-                          xsrc, ysrc, xdest, ydest, width, height);
-  else if (GDK_IS_PIXMAP_IMPL_WIN32 (src_impl))
-    blit_from_pixmap (use_fg_bg, draw_impl, hdc,
-		      (GdkPixmapImplWin32 *) src_impl, gc,
-		      xsrc, ysrc, xdest, ydest, width, height);
-  else
-    blit_from_window (hdc, GDK_GC_WIN32 (gc), src_impl,
-                      xsrc, ysrc, xdest, ydest, width, height);
-
-  gdk_win32_hdc_release (&draw_impl->parent_instance, gc, GDK_GC_FOREGROUND);
-}
-
-static void
-gdk_win32_draw_image (GdkDrawable     *drawable,
-		      GdkGC           *gc,
-		      GdkImage        *image,
-		      gint             xsrc,
-		      gint             ysrc,
-		      gint             xdest,
-		      gint             ydest,
-		      gint             width,
-		      gint             height)
-{
-  g_assert (GDK_IS_DRAWABLE_IMPL_WIN32 (drawable));
-
-  _gdk_win32_blit (TRUE, (GdkDrawableImplWin32 *) drawable,
-		   gc, (GdkPixmap *) image->windowing_data,
-		   xsrc, ysrc, xdest, ydest, width, height);
-}
-
-static void
-gdk_win32_draw_pixbuf (GdkDrawable     *drawable,
-			GdkGC           *gc,
-			GdkPixbuf       *pixbuf,
-			gint             src_x,
-			gint             src_y,
-			gint             dest_x,
-			gint             dest_y,
-			gint             width,
-			gint             height,
-			GdkRgbDither     dither,
-			gint             x_dither,
-			gint             y_dither)
-{
-  GdkDrawable *wrapper = GDK_DRAWABLE_IMPL_WIN32 (drawable)->wrapper;
-  GDK_DRAWABLE_CLASS (_gdk_drawable_impl_win32_parent_class)->draw_pixbuf (wrapper, gc, pixbuf,
-									     src_x, src_y, dest_x, dest_y,
-									     width, height,
-									     dither, x_dither, y_dither);
-}
-
-/**
- * _gdk_win32_drawable_acquire_dc
- * @drawable: a Win32 #GdkDrawable implementation
- * 
- * Gets a DC with the given drawable selected into
- * it.
- *
- * Return value: The DC, on success. Otherwise
- *  %NULL. If this function succeeded
- *  _gdk_win32_drawable_release_dc()  must be called
- *  release the DC when you are done using it.
- **/
-HDC 
-_gdk_win32_drawable_acquire_dc (GdkDrawable *drawable)
-{
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-  
-  if (GDK_IS_WINDOW_IMPL_WIN32 (drawable) &&
-      GDK_WINDOW_DESTROYED (impl->wrapper))
-    return NULL;
-
-  if (!impl->hdc)
-    {
-      if (GDK_IS_PIXMAP_IMPL_WIN32 (impl))
-	{
-	  impl->hdc = CreateCompatibleDC (NULL);
-	  if (!impl->hdc)
-	    WIN32_GDI_FAILED ("CreateCompatibleDC");
-	  
-	  if (impl->hdc)
-	    {
-	      impl->saved_dc_bitmap = SelectObject (impl->hdc,
-						    impl->handle);
-	      if (!impl->saved_dc_bitmap)
-		{
-		  WIN32_GDI_FAILED ("SelectObject");
-		  DeleteDC (impl->hdc);
-		  impl->hdc = NULL;
-		}
-	    }
-	}
-      else
-	{
-	  impl->hdc = GetDC (impl->handle);
-	  if (!impl->hdc)
-	    WIN32_GDI_FAILED ("GetDC");
-	}
-    }
-
-  if (impl->hdc)
-    {
-      impl->hdc_count++;
-      return impl->hdc;
-    }
-  else
-    {
-      return NULL;
-    }
-}
-
-/**
- * _gdk_win32_drawable_release_dc
- * @drawable: a Win32 #GdkDrawable implementation
- * 
- * Releases the reference count for the DC
- * from _gdk_win32_drawable_acquire_dc()
- **/
-void
-_gdk_win32_drawable_release_dc (GdkDrawable *drawable)
-{
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-  
-  g_return_if_fail (impl->hdc_count > 0);
-
-  impl->hdc_count--;
-  if (impl->hdc_count == 0)
-    {
-      if (impl->saved_dc_bitmap)
-	{
-	  GDI_CALL (SelectObject, (impl->hdc, impl->saved_dc_bitmap));
-	  impl->saved_dc_bitmap = NULL;
-	}
-      
-      if (impl->hdc)
-	{
-	  if (GDK_IS_PIXMAP_IMPL_WIN32 (impl))
-	    GDI_CALL (DeleteDC, (impl->hdc));
-	  else
-	    GDI_CALL (ReleaseDC, (impl->handle, impl->hdc));
-	  impl->hdc = NULL;
-	}
-    }
-}
-
-static void
-gdk_win32_cairo_surface_release_hdc (void *data)
-{
-  _gdk_win32_drawable_release_dc (GDK_DRAWABLE (data));
-}
-
-cairo_surface_t *
-_gdk_windowing_create_cairo_surface (GdkDrawable *drawable,
-				     gint width,
-				     gint height)
-{
-  cairo_surface_t *surface;
-  HDC hdc;
-
-  hdc = _gdk_win32_drawable_acquire_dc (drawable);
-  if (!hdc)
-    return NULL;
-
-  surface = cairo_win32_surface_create (hdc);
-
-  /* Whenever the cairo surface is destroyed, we need to release the
-   * HDC that was acquired */
-  cairo_surface_set_user_data (surface, &gdk_win32_cairo_hdc_key,
-			       drawable,
-			       gdk_win32_cairo_surface_release_hdc);
-
-  return surface;
-}
-
-static void
-gdk_win32_cairo_surface_destroy (void *data)
-{
-  GdkDrawableImplWin32 *impl = data;
-
-  impl->cairo_surface = NULL;
-}
-
-static cairo_surface_t *
-gdk_win32_ref_cairo_surface (GdkDrawable *drawable)
-{
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-
-  if (GDK_IS_WINDOW_IMPL_WIN32 (drawable) &&
-      GDK_WINDOW_DESTROYED (impl->wrapper))
-    return NULL;
-
-  if (!impl->cairo_surface)
-    {
-      /* width and height are determined from the DC */
-      impl->cairo_surface = _gdk_windowing_create_cairo_surface (drawable, 0, 0);
-
-      /* Whenever the cairo surface is destroyed, we need to clear the
-       * pointer that we had stored here */
-      cairo_surface_set_user_data (impl->cairo_surface, &gdk_win32_cairo_key,
-				   drawable,
-				   gdk_win32_cairo_surface_destroy);
-    }
-  else
-    cairo_surface_reference (impl->cairo_surface);
-
-  return impl->cairo_surface;
-}
-
-void
-_gdk_windowing_set_cairo_surface_size (cairo_surface_t *surface,
-				       gint width,
-				       gint height)
-{
-  // Do nothing.  The surface size is determined by the DC
-}
-
-static gint
-gdk_win32_get_depth (GdkDrawable *drawable)
-{
-  /* This is a bit bogus but I'm not sure the other way is better */
-
-  return gdk_drawable_get_depth (GDK_DRAWABLE_IMPL_WIN32 (drawable)->wrapper);
-}
-
-static GdkScreen*
-gdk_win32_get_screen (GdkDrawable *drawable)
-{
-  return gdk_screen_get_default ();
-}
- 
-static GdkVisual*
-gdk_win32_get_visual (GdkDrawable *drawable)
-{
-  return gdk_drawable_get_visual (GDK_DRAWABLE_IMPL_WIN32 (drawable)->wrapper);
-}
-
-HGDIOBJ
-gdk_win32_drawable_get_handle (GdkDrawable *drawable)
-{
-  if (GDK_IS_WINDOW (drawable))
-    {
-      GdkWindow *window = (GdkWindow *)drawable;
-
-      /* Try to ensure the window has a native window */
-      if (!_gdk_window_has_impl (window))
-	gdk_window_ensure_native (window);
-
-      if (!GDK_WINDOW_IS_WIN32 (window))
-	{
-	  g_warning (G_STRLOC " drawable is not a native Win32 window");
-	  return NULL;
-	}
-    }
-  else if (!GDK_IS_PIXMAP (drawable))
-    {
-      g_warning (G_STRLOC " drawable is not a pixmap or window");
-      return NULL;
-    }
-
-  return GDK_DRAWABLE_HANDLE (drawable);
-}
-
-/**
- * _gdk_win32_drawable_finish
- * @drawable: a Win32 #GdkDrawable implementation
- * 
- * Releases any resources allocated internally for the drawable.
- * This is called when the drawable becomes unusable
- * (gdk_window_destroy() for a window, or the refcount going to
- * zero for a pixmap.)
- **/
-void
-_gdk_win32_drawable_finish (GdkDrawable *drawable)
-{
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-
-  if (impl->cairo_surface)
-    {
-      cairo_surface_finish (impl->cairo_surface);
-      cairo_surface_set_user_data (impl->cairo_surface, &gdk_win32_cairo_hdc_key, NULL, NULL);
-      cairo_surface_set_user_data (impl->cairo_surface, &gdk_win32_cairo_key, NULL, NULL);
-    }
-
-  /* impl->hdc_count doesn't have to be 0 here; as there may still be surfaces
-   * created with gdk_windowing_create_cairo_surface() out there, which are not
-   * managed internally by the drawable */
-}
diff --git a/gdk/win32/gdkdrawable-win32.h b/gdk/win32/gdkdrawable-win32.h
deleted file mode 100644
index 32649d8..0000000
--- a/gdk/win32/gdkdrawable-win32.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#ifndef __GDK_DRAWABLE_WIN32_H__
-#define __GDK_DRAWABLE_WIN32_H__
-
-#include <gdk/gdkdrawable.h>
-#include <gdk/win32/gdkwin32.h>
-
-G_BEGIN_DECLS
-
-/* Drawable implementation for Win32
- */
-
-typedef struct _GdkDrawableImplWin32 GdkDrawableImplWin32;
-typedef struct _GdkDrawableImplWin32Class GdkDrawableImplWin32Class;
-
-#define GDK_TYPE_DRAWABLE_IMPL_WIN32              (_gdk_drawable_impl_win32_get_type ())
-#define GDK_DRAWABLE_IMPL_WIN32(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_DRAWABLE_IMPL_WIN32, GdkDrawableImplWin32))
-#define GDK_DRAWABLE_IMPL_WIN32_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_DRAWABLE_IMPL_WIN32, GdkDrawableImplWin32Class))
-#define GDK_IS_DRAWABLE_IMPL_WIN32(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_DRAWABLE_IMPL_WIN32))
-#define GDK_IS_DRAWABLE_IMPL_WIN32_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_DRAWABLE_IMPL_WIN32))
-#define GDK_DRAWABLE_IMPL_WIN32_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GDK_TYPE_DRAWABLE_IMPL_WIN32, GdkDrawableImplWin32Class))
-
-struct _GdkDrawableImplWin32
-{
-  GdkDrawable parent_instance;
-  GdkDrawable *wrapper;
-  GdkColormap *colormap;
-  HANDLE handle;
-
-  guint hdc_count;
-  HDC hdc;
-  HBITMAP saved_dc_bitmap;	/* Original bitmap for dc */
-  cairo_surface_t *cairo_surface;
-};
- 
-struct _GdkDrawableImplWin32Class 
-{
-  GdkDrawableClass parent_class;
-};
-
-GType _gdk_drawable_impl_win32_get_type (void);
-
-HDC  _gdk_win32_drawable_acquire_dc (GdkDrawable *drawable);
-void _gdk_win32_drawable_release_dc (GdkDrawable *drawable);
-void _gdk_win32_drawable_finish     (GdkDrawable *drawable);
-
-G_END_DECLS
-
-#endif /* __GDK_DRAWABLE_WIN32_H__ */
diff --git a/gdk/win32/gdkevents-win32.c b/gdk/win32/gdkevents-win32.c
deleted file mode 100644
index b4b2a94..0000000
--- a/gdk/win32/gdkevents-win32.c
+++ /dev/null
@@ -1,3797 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- * Copyright (C) 2001,2009 Hans Breuer
- * Copyright (C) 2007-2009 Cody Russell
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-/* Cannot use TrackMouseEvent, as the stupid WM_MOUSELEAVE message
- * doesn't tell us where the mouse has gone. Thus we cannot use it to
- * generate a correct GdkNotifyType. Pity, as using TrackMouseEvent
- * otherwise would make it possible to reliably generate
- * GDK_LEAVE_NOTIFY events, which would help get rid of those pesky
- * tooltips sometimes popping up in the wrong place.
- *
- * Update: a combination of TrackMouseEvent, GetCursorPos and 
- * GetWindowPos can and is actually used to get rid of those
- * pesky tooltips. It should be possible to use this for the
- * whole ENTER/LEAVE NOTIFY handling but some platforms may
- * not have TrackMouseEvent at all (?) --hb
- */
-
-#include "config.h"
-
-#include <glib/gprintf.h>
-
-#include "gdk.h"
-#include "gdkprivate-win32.h"
-#include "gdkinput-win32.h"
-#include "gdkkeysyms.h"
-
-#include <windowsx.h>
-
-#ifdef G_WITH_CYGWIN
-#include <fcntl.h>
-#include <errno.h>
-#endif
-
-#include <objbase.h>
-
-#include <imm.h>
-
-#ifndef XBUTTON1
-#define XBUTTON1 1
-#define XBUTTON2 2
-#endif
-
-#ifndef VK_XBUTTON1
-#define VK_XBUTTON1 5
-#define VK_XBUTTON2 6
-#endif
-
-#ifndef MK_XBUTTON1
-#define MK_XBUTTON1 32
-#define MK_XBUTTON2 64
-#endif
-
-/* Undefined flags: */
-#define SWP_NOCLIENTSIZE 0x0800
-#define SWP_NOCLIENTMOVE 0x1000
-#define SWP_STATECHANGED 0x8000
-/* 
- * Private function declarations
- */
-
-#define SYNAPSIS_ICON_WINDOW_CLASS "SynTrackCursorWindowClass"
-
-static gboolean gdk_event_translate (MSG        *msg,
-				     gint       *ret_valp);
-static void     handle_wm_paint     (MSG        *msg,
-				     GdkWindow  *window,
-				     gboolean    return_exposes,
-				     GdkEvent  **event);
-
-static gboolean gdk_event_prepare  (GSource     *source,
-				    gint        *timeout);
-static gboolean gdk_event_check    (GSource     *source);
-static gboolean gdk_event_dispatch (GSource     *source,
-				    GSourceFunc  callback,
-				    gpointer     user_data);
-
-/* Private variable declarations
- */
-
-static GList *client_filters;	/* Filters for client messages */
-
-static HCURSOR p_grab_cursor;
-
-static GSourceFuncs event_funcs = {
-  gdk_event_prepare,
-  gdk_event_check,
-  gdk_event_dispatch,
-  NULL
-};
-
-GPollFD event_poll_fd;
-
-static GdkWindow *mouse_window = NULL;
-static GdkWindow *mouse_window_ignored_leave = NULL;
-static gint current_x, current_y;
-static gint current_root_x, current_root_y;
-static UINT client_message;
-
-static UINT got_gdk_events_message;
-static HWND modal_win32_dialog = NULL;
-
-#if 0
-static HKL latin_locale = NULL;
-#endif
-
-static gboolean in_ime_composition = FALSE;
-static UINT     modal_timer;
-static UINT     sync_timer = 0;
-
-static int debug_indent = 0;
-
-static void
-assign_object (gpointer lhsp,
-	       gpointer rhs)
-{
-  if (*(gpointer *)lhsp != rhs)
-    {
-      if (*(gpointer *)lhsp != NULL)
-	g_object_unref (*(gpointer *)lhsp);
-      *(gpointer *)lhsp = rhs;
-      if (rhs != NULL)
-	g_object_ref (rhs);
-    }
-}
-
-static void
-track_mouse_event (DWORD dwFlags,
-		   HWND  hwnd)
-{
-  TRACKMOUSEEVENT tme;
-
-  tme.cbSize = sizeof(TRACKMOUSEEVENT);
-  tme.dwFlags = dwFlags;
-  tme.hwndTrack = hwnd;
-  tme.dwHoverTime = HOVER_DEFAULT; /* not used */
-
-  if (!TrackMouseEvent (&tme))
-    WIN32_API_FAILED ("TrackMouseEvent");
-  else if (dwFlags == TME_LEAVE)
-    GDK_NOTE (EVENTS, g_print(" (TrackMouseEvent %p)", hwnd));
-  else if (dwFlags == TME_CANCEL)
-    GDK_NOTE (EVENTS, g_print(" (cancel TrackMouseEvent %p)", hwnd));
-}
-
-gulong
-_gdk_win32_get_next_tick (gulong suggested_tick)
-{
-  static gulong cur_tick = 0;
-
-  if (suggested_tick == 0)
-    suggested_tick = GetTickCount ();
-  if (suggested_tick <= cur_tick)
-    return cur_tick;
-  else
-    return cur_tick = suggested_tick;
-}
-
-static void
-generate_focus_event (GdkWindow *window,
-		      gboolean   in)
-{
-  GdkEvent *event;
-
-  event = gdk_event_new (GDK_FOCUS_CHANGE);
-  event->focus_change.window = window;
-  event->focus_change.in = in;
-
-  _gdk_win32_append_event (event);
-}
-
-static void
-generate_grab_broken_event (GdkWindow *window,
-			    gboolean   keyboard,
-			    GdkWindow *grab_window)
-{
-  GdkEvent *event = gdk_event_new (GDK_GRAB_BROKEN);
-
-  event->grab_broken.window = window;
-  event->grab_broken.send_event = 0;
-  event->grab_broken.keyboard = keyboard;
-  event->grab_broken.implicit = FALSE;
-  event->grab_broken.grab_window = grab_window;
-	  
-  _gdk_win32_append_event (event);
-}
-
-static LRESULT 
-inner_window_procedure (HWND   hwnd,
-			UINT   message,
-			WPARAM wparam,
-			LPARAM lparam)
-{
-  MSG msg;
-  DWORD pos;
-  gint ret_val = 0;
-
-  msg.hwnd = hwnd;
-  msg.message = message;
-  msg.wParam = wparam;
-  msg.lParam = lparam;
-  msg.time = _gdk_win32_get_next_tick (0);
-  pos = GetMessagePos ();
-  msg.pt.x = GET_X_LPARAM (pos);
-  msg.pt.y = GET_Y_LPARAM (pos);
-
-  if (gdk_event_translate (&msg, &ret_val))
-    {
-      /* If gdk_event_translate() returns TRUE, we return ret_val from
-       * the window procedure.
-       */
-      if (modal_win32_dialog)
-	PostMessageW (modal_win32_dialog, got_gdk_events_message,
-		      (WPARAM) 1, 0);
-      return ret_val;
-    }
-  else
-    {
-      /* Otherwise call DefWindowProcW(). */
-      GDK_NOTE (EVENTS, g_print (" DefWindowProcW"));
-      return DefWindowProcW (hwnd, message, wparam, lparam);
-    }
-}
-
-LRESULT CALLBACK
-_gdk_win32_window_procedure (HWND   hwnd,
-                             UINT   message,
-                             WPARAM wparam,
-                             LPARAM lparam)
-{
-  LRESULT retval;
-
-  GDK_NOTE (EVENTS, g_print ("%s%*s%s %p",
-			     (debug_indent > 0 ? "\n" : ""),
-			     debug_indent, "", 
-			     _gdk_win32_message_to_string (message), hwnd));
-  debug_indent += 2;
-  retval = inner_window_procedure (hwnd, message, wparam, lparam);
-  debug_indent -= 2;
-
-  GDK_NOTE (EVENTS, g_print (" => %I64d%s", (gint64) retval, (debug_indent == 0 ? "\n" : "")));
-
-  return retval;
-}
-
-void 
-_gdk_events_init (void)
-{
-  GSource *source;
-
-#if 0
-  int i, j, n;
-
-  /* List of languages that use a latin keyboard. Somewhat sorted in
-   * "order of least surprise", in case we have to load one of them if
-   * the user only has arabic loaded, for instance.
-   */
-  static int latin_languages[] = {
-    LANG_ENGLISH,
-    LANG_SPANISH,
-    LANG_PORTUGUESE,
-    LANG_FRENCH,
-    LANG_GERMAN,
-    /* Rest in numeric order */
-    LANG_CZECH,
-    LANG_DANISH,
-    LANG_FINNISH,
-    LANG_HUNGARIAN,
-    LANG_ICELANDIC,
-    LANG_ITALIAN,
-    LANG_DUTCH,
-    LANG_NORWEGIAN,
-    LANG_POLISH,
-    LANG_ROMANIAN,
-    LANG_SLOVAK,
-    LANG_ALBANIAN,
-    LANG_SWEDISH,
-    LANG_TURKISH,
-    LANG_INDONESIAN,
-    LANG_SLOVENIAN,
-    LANG_ESTONIAN,
-    LANG_LATVIAN,
-    LANG_LITHUANIAN,
-    LANG_VIETNAMESE,
-    LANG_AFRIKAANS,
-    LANG_FAEROESE
-#ifdef LANG_SWAHILI
-   ,LANG_SWAHILI
-#endif
-  };
-#endif
-
-  client_message = RegisterWindowMessage ("GDK_WIN32_CLIENT_MESSAGE");
-  got_gdk_events_message = RegisterWindowMessage ("GDK_WIN32_GOT_EVENTS");
-
-#if 0
-  /* Check if we have some input locale identifier loaded that uses a
-   * latin keyboard, to be able to get the virtual-key code for the
-   * latin characters corresponding to ASCII control characters.
-   */
-  if ((n = GetKeyboardLayoutList (0, NULL)) == 0)
-    WIN32_API_FAILED ("GetKeyboardLayoutList");
-  else
-    {
-      HKL *hkl_list = g_new (HKL, n);
-      if (GetKeyboardLayoutList (n, hkl_list) == 0)
-	WIN32_API_FAILED ("GetKeyboardLayoutList");
-      else
-	{
-	  for (i = 0; latin_locale == NULL && i < n; i++)
-	    for (j = 0; j < G_N_ELEMENTS (latin_languages); j++)
-	      if (PRIMARYLANGID (LOWORD (hkl_list[i])) == latin_languages[j])
-		{
-		  latin_locale = hkl_list [i];
-		  break;
-		}
-	}
-      g_free (hkl_list);
-    }
-
-  if (latin_locale == NULL)
-    {
-      /* Try to load a keyboard layout with latin characters then.
-       */
-      i = 0;
-      while (latin_locale == NULL && i < G_N_ELEMENTS (latin_languages))
-	{
-	  char id[9];
-	  g_sprintf (id, "%08x", MAKELANGID (latin_languages[i++], SUBLANG_DEFAULT));
-	  latin_locale = LoadKeyboardLayout (id, KLF_NOTELLSHELL|KLF_SUBSTITUTE_OK);
-	}
-    }
-
-  GDK_NOTE (EVENTS, g_print ("latin_locale = %08x\n", (guint) latin_locale));
-#endif
-
-  source = g_source_new (&event_funcs, sizeof (GSource));
-  g_source_set_name (source, "GDK Win32 event source"); 
-  g_source_set_priority (source, GDK_PRIORITY_EVENTS);
-
-#ifdef G_WITH_CYGWIN
-  event_poll_fd.fd = open ("/dev/windows", O_RDONLY);
-  if (event_poll_fd.fd == -1)
-    g_error ("can't open \"/dev/windows\": %s", g_strerror (errno));
-#else
-  event_poll_fd.fd = G_WIN32_MSG_HANDLE;
-#endif
-  event_poll_fd.events = G_IO_IN;
-  
-  g_source_add_poll (source, &event_poll_fd);
-  g_source_set_can_recurse (source, TRUE);
-  g_source_attach (source, NULL);
-}
-
-gboolean
-gdk_events_pending (void)
-{
-  return (_gdk_event_queue_find_first (_gdk_display) ||
-	  (modal_win32_dialog == NULL &&
-	   GetQueueStatus (QS_ALLINPUT) != 0));
-}
-
-GdkEvent*
-gdk_event_get_graphics_expose (GdkWindow *window)
-{
-  MSG msg;
-  GdkEvent *event = NULL;
-
-  g_return_val_if_fail (window != NULL, NULL);
-  
-  GDK_NOTE (EVENTS, g_print ("gdk_event_get_graphics_expose\n"));
-
-  if (PeekMessageW (&msg, GDK_WINDOW_HWND (window), WM_PAINT, WM_PAINT, PM_REMOVE))
-    {
-      handle_wm_paint (&msg, window, TRUE, &event);
-      if (event != NULL)
-	{
-	  GDK_NOTE (EVENTS, g_print ("gdk_event_get_graphics_expose: got it!\n"));
-	  return event;
-	}
-    }
-  
-  GDK_NOTE (EVENTS, g_print ("gdk_event_get_graphics_expose: nope\n"));
-  return NULL;	
-}
-
-#if 0 /* Unused, but might be useful to re-introduce in some debugging output? */
-
-static char *
-event_mask_string (GdkEventMask mask)
-{
-  static char bfr[500];
-  char *p = bfr;
-
-  *p = '\0';
-#define BIT(x) \
-  if (mask & GDK_##x##_MASK) \
-    p += g_sprintf (p, "%s" #x, (p > bfr ? " " : ""))
-  BIT (EXPOSURE);
-  BIT (POINTER_MOTION);
-  BIT (POINTER_MOTION_HINT);
-  BIT (BUTTON_MOTION);
-  BIT (BUTTON1_MOTION);
-  BIT (BUTTON2_MOTION);
-  BIT (BUTTON3_MOTION);
-  BIT (BUTTON_PRESS);
-  BIT (BUTTON_RELEASE);
-  BIT (KEY_PRESS);
-  BIT (KEY_RELEASE);
-  BIT (ENTER_NOTIFY);
-  BIT (LEAVE_NOTIFY);
-  BIT (FOCUS_CHANGE);
-  BIT (STRUCTURE);
-  BIT (PROPERTY_CHANGE);
-  BIT (VISIBILITY_NOTIFY);
-  BIT (PROXIMITY_IN);
-  BIT (PROXIMITY_OUT);
-  BIT (SUBSTRUCTURE);
-  BIT (SCROLL);
-#undef BIT
-
-  return bfr;
-}
-
-#endif
-
-GdkGrabStatus
-_gdk_windowing_pointer_grab (GdkWindow    *window,
-			     GdkWindow    *native_window,
-			     gboolean	owner_events,
-			     GdkEventMask	event_mask,
-			     GdkWindow    *confine_to,
-			     GdkCursor    *cursor,
-			     guint32	time)
-{
-  HCURSOR hcursor;
-  GdkCursorPrivate *cursor_private;
-  gint return_val;
-
-  g_return_val_if_fail (window != NULL, 0);
-  g_return_val_if_fail (GDK_IS_WINDOW (window), 0);
-  g_return_val_if_fail (confine_to == NULL || GDK_IS_WINDOW (confine_to), 0);
-  
-  cursor_private = (GdkCursorPrivate*) cursor;
-  
-  if (!cursor)
-    hcursor = NULL;
-  else if ((hcursor = CopyCursor (cursor_private->hcursor)) == NULL)
-    WIN32_API_FAILED ("CopyCursor");
-
-  return_val = _gdk_input_grab_pointer (native_window,
-					owner_events,
-					event_mask,
-					confine_to,
-					time);
-
-  if (return_val == GDK_GRAB_SUCCESS)
-    {
-      GdkWindowImplWin32 *impl = GDK_WINDOW_IMPL_WIN32 (((GdkWindowObject *) native_window)->impl);
-
-      SetCapture (GDK_WINDOW_HWND (native_window));
-      /* TODO_CSW: grab brokens, confine window, input_grab */
-      if (p_grab_cursor != NULL)
-	{
-	  if (GetCursor () == p_grab_cursor)
-	    SetCursor (NULL);
-	  DestroyCursor (p_grab_cursor);
-	}
-
-      p_grab_cursor = hcursor;
-
-      if (p_grab_cursor != NULL)
-	SetCursor (p_grab_cursor);
-      else if (impl->hcursor != NULL)
-	SetCursor (impl->hcursor);
-      else
-	SetCursor (LoadCursor (NULL, IDC_ARROW));
-
-    }
-
-  return return_val;
-}
-
-void
-gdk_display_pointer_ungrab (GdkDisplay *display,
-                            guint32     time)
-{
-  GdkPointerGrabInfo *info;
-
-  info = _gdk_display_get_last_pointer_grab (display);
-  if (info)
-    {
-      info->serial_end = 0;
-      ReleaseCapture ();
-    }
-
-  _gdk_input_ungrab_pointer (time);
-
-  /* TODO_CSW: cursor, confines, etc */
-
-  _gdk_display_pointer_grab_update (display, 0);
-}
-
-
-static GdkWindow *
-find_window_for_mouse_event (GdkWindow* reported_window,
-			     MSG*       msg)
-{
-  POINT pt;
-  GdkWindow *event_window;
-  HWND hwnd;
-  RECT rect;
-  GdkPointerGrabInfo *grab;
-
-  grab = _gdk_display_get_last_pointer_grab (_gdk_display);
-  if (grab == NULL)
-    return reported_window;
-
-  pt = msg->pt;
-
-  if (!grab->owner_events)
-    event_window = grab->native_window;
-  else
-    {
-      event_window = NULL;
-      hwnd = WindowFromPoint (pt);
-      if (hwnd != NULL)
-	{
-	  POINT client_pt = pt;
-
-	  ScreenToClient (hwnd, &client_pt);
-	  GetClientRect (hwnd, &rect);
-	  if (PtInRect (&rect, client_pt))
-	    event_window = gdk_win32_handle_table_lookup ((GdkNativeWindow) hwnd);
-	}
-      if (event_window == NULL)
-	event_window = grab->native_window;
-    }
-
-  /* need to also adjust the coordinates to the new window */
-  ScreenToClient (GDK_WINDOW_HWND (event_window), &pt);
-
-  /* ATTENTION: need to update client coords */
-  msg->lParam = MAKELPARAM (pt.x, pt.y);
-
-  return event_window;
-}
-
-GdkGrabStatus
-gdk_keyboard_grab (GdkWindow *window,
-		   gboolean   owner_events,
-		   guint32    time)
-{
-  GdkDisplay *display;
-  GdkWindow  *toplevel;
-
-  g_return_val_if_fail (window != NULL, 0);
-  g_return_val_if_fail (GDK_IS_WINDOW (window), 0);
-  
-  GDK_NOTE (EVENTS, g_print ("gdk_keyboard_grab %p%s\n",
-			     GDK_WINDOW_HWND (window), owner_events ? " OWNER_EVENTS" : ""));
-
-  display = gdk_drawable_get_display (window);
-  toplevel = gdk_window_get_toplevel (window);
-
-  _gdk_display_set_has_keyboard_grab (display,
-				      window,
-				      toplevel,
-				      owner_events,
-				      0,
-				      time);
-
-  return GDK_GRAB_SUCCESS;
-}
-
-void
-gdk_display_keyboard_ungrab (GdkDisplay *display,
-                             guint32 time)
-{
-  GDK_NOTE (EVENTS, g_print ("gdk_display_keyboard_ungrab\n"));
-  _gdk_display_unset_has_keyboard_grab (display, FALSE);
-}
-
-void 
-gdk_display_add_client_message_filter (GdkDisplay   *display,
-				       GdkAtom       message_type,
-				       GdkFilterFunc func,
-				       gpointer      data)
-{
-  /* XXX */
-  gdk_add_client_message_filter (message_type, func, data);
-}
-
-void
-gdk_add_client_message_filter (GdkAtom       message_type,
-			       GdkFilterFunc func,
-			       gpointer      data)
-{
-  GdkClientFilter *filter = g_new (GdkClientFilter, 1);
-
-  filter->type = message_type;
-  filter->function = func;
-  filter->data = data;
-  
-  client_filters = g_list_append (client_filters, filter);
-}
-
-static void
-build_key_event_state (GdkEvent *event,
-		       BYTE     *key_state)
-{
-  GdkWin32Keymap *keymap;
-
-  event->key.state = 0;
-
-  if (key_state[VK_SHIFT] & 0x80)
-    event->key.state |= GDK_SHIFT_MASK;
-
-  if (key_state[VK_CAPITAL] & 0x01)
-    event->key.state |= GDK_LOCK_MASK;
-
-  if (key_state[VK_LBUTTON] & 0x80)
-    event->key.state |= GDK_BUTTON1_MASK;
-  if (key_state[VK_MBUTTON] & 0x80)
-    event->key.state |= GDK_BUTTON2_MASK;
-  if (key_state[VK_RBUTTON] & 0x80)
-    event->key.state |= GDK_BUTTON3_MASK;
-  if (key_state[VK_XBUTTON1] & 0x80)
-    event->key.state |= GDK_BUTTON4_MASK;
-  if (key_state[VK_XBUTTON2] & 0x80)
-    event->key.state |= GDK_BUTTON5_MASK;
-
-  keymap = GDK_WIN32_KEYMAP (gdk_keymap_get_default ());
-  event->key.group = _gdk_win32_keymap_get_active_group (keymap);
-
-  if (_gdk_win32_keymap_has_altgr (keymap) &&
-      (key_state[VK_LCONTROL] & 0x80) &&
-      (key_state[VK_RMENU] & 0x80))
-    {
-      event->key.state |= GDK_MOD2_MASK;
-      if (key_state[VK_RCONTROL] & 0x80)
-	event->key.state |= GDK_CONTROL_MASK;
-      if (key_state[VK_LMENU] & 0x80)
-	event->key.state |= GDK_MOD1_MASK;
-    }
-  else
-    {
-      if (key_state[VK_CONTROL] & 0x80)
-	event->key.state |= GDK_CONTROL_MASK;
-      if (key_state[VK_MENU] & 0x80)
-	event->key.state |= GDK_MOD1_MASK;
-    }
-}
-
-static gint
-build_pointer_event_state (MSG *msg)
-{
-  gint state;
-  
-  state = 0;
-
-  if (msg->wParam & MK_CONTROL)
-    state |= GDK_CONTROL_MASK;
-
-  if ((msg->message != WM_LBUTTONDOWN &&
-       (msg->wParam & MK_LBUTTON)) ||
-      msg->message == WM_LBUTTONUP)
-    state |= GDK_BUTTON1_MASK;
-
-  if ((msg->message != WM_MBUTTONDOWN &&
-       (msg->wParam & MK_MBUTTON)) ||
-      msg->message == WM_MBUTTONUP)
-    state |= GDK_BUTTON2_MASK;
-
-  if ((msg->message != WM_RBUTTONDOWN &&
-       (msg->wParam & MK_RBUTTON)) ||
-      msg->message == WM_RBUTTONUP)
-    state |= GDK_BUTTON3_MASK;
-
-  if (((msg->message != WM_XBUTTONDOWN || HIWORD (msg->wParam) != XBUTTON1) &&
-       (msg->wParam & MK_XBUTTON1)) ||
-      (msg->message == WM_XBUTTONUP && HIWORD (msg->wParam) == XBUTTON1))
-    state |= GDK_BUTTON4_MASK;
-
-  if (((msg->message != WM_XBUTTONDOWN || HIWORD (msg->wParam) != XBUTTON2) &&
-       (msg->wParam & MK_XBUTTON2)) ||
-      (msg->message == WM_XBUTTONUP && HIWORD (msg->wParam) == XBUTTON2))
-    state |= GDK_BUTTON5_MASK;
-
-  if (msg->wParam & MK_SHIFT)
-    state |= GDK_SHIFT_MASK;
-
-  if (GetKeyState (VK_MENU) < 0)
-    state |= GDK_MOD1_MASK;
-
-  if (GetKeyState (VK_CAPITAL) & 0x1)
-    state |= GDK_LOCK_MASK;
-
-  return state;
-}
-
-static void
-build_wm_ime_composition_event (GdkEvent *event,
-				MSG      *msg,
-				wchar_t   wc,
-				BYTE     *key_state)
-{
-  event->key.time = _gdk_win32_get_next_tick (msg->time);
-  
-  build_key_event_state (event, key_state);
-
-  event->key.hardware_keycode = 0; /* FIXME: What should it be? */
-  event->key.string = NULL;
-  event->key.length = 0;
-  event->key.keyval = gdk_unicode_to_keyval (wc);
-}
-
-#ifdef G_ENABLE_DEBUG
-
-static void
-print_event_state (guint state)
-{
-#define CASE(bit) if (state & GDK_ ## bit ## _MASK) g_print (#bit " ");
-  CASE (SHIFT);
-  CASE (LOCK);
-  CASE (CONTROL);
-  CASE (MOD1);
-  CASE (MOD2);
-  CASE (MOD3);
-  CASE (MOD4);
-  CASE (MOD5);
-  CASE (BUTTON1);
-  CASE (BUTTON2);
-  CASE (BUTTON3);
-  CASE (BUTTON4);
-  CASE (BUTTON5);
-#undef CASE
-}
-
-void
-_gdk_win32_print_event (const GdkEvent *event)
-{
-  gchar *escaped, *kvname;
-  gchar *selection_name, *target_name, *property_name;
-
-  g_print ("%s%*s===> ", (debug_indent > 0 ? "\n" : ""), debug_indent, "");
-  switch (event->any.type)
-    {
-#define CASE(x) case x: g_print (#x); break;
-    CASE (GDK_NOTHING);
-    CASE (GDK_DELETE);
-    CASE (GDK_DESTROY);
-    CASE (GDK_EXPOSE);
-    CASE (GDK_MOTION_NOTIFY);
-    CASE (GDK_BUTTON_PRESS);
-    CASE (GDK_2BUTTON_PRESS);
-    CASE (GDK_3BUTTON_PRESS);
-    CASE (GDK_BUTTON_RELEASE);
-    CASE (GDK_KEY_PRESS);
-    CASE (GDK_KEY_RELEASE);
-    CASE (GDK_ENTER_NOTIFY);
-    CASE (GDK_LEAVE_NOTIFY);
-    CASE (GDK_FOCUS_CHANGE);
-    CASE (GDK_CONFIGURE);
-    CASE (GDK_MAP);
-    CASE (GDK_UNMAP);
-    CASE (GDK_PROPERTY_NOTIFY);
-    CASE (GDK_SELECTION_CLEAR);
-    CASE (GDK_SELECTION_REQUEST);
-    CASE (GDK_SELECTION_NOTIFY);
-    CASE (GDK_PROXIMITY_IN);
-    CASE (GDK_PROXIMITY_OUT);
-    CASE (GDK_DRAG_ENTER);
-    CASE (GDK_DRAG_LEAVE);
-    CASE (GDK_DRAG_MOTION);
-    CASE (GDK_DRAG_STATUS);
-    CASE (GDK_DROP_START);
-    CASE (GDK_DROP_FINISHED);
-    CASE (GDK_CLIENT_EVENT);
-    CASE (GDK_VISIBILITY_NOTIFY);
-    CASE (GDK_NO_EXPOSE);
-    CASE (GDK_SCROLL);
-    CASE (GDK_WINDOW_STATE);
-    CASE (GDK_SETTING);
-    CASE (GDK_OWNER_CHANGE);
-    CASE (GDK_GRAB_BROKEN);
-#undef CASE
-    default: g_assert_not_reached ();
-    }
-
-  g_print (" %p ", event->any.window ? GDK_WINDOW_HWND (event->any.window) : NULL);
-
-  switch (event->any.type)
-    {
-    case GDK_EXPOSE:
-      g_print ("%s %d",
-	       _gdk_win32_gdkrectangle_to_string (&event->expose.area),
-	       event->expose.count);
-      break;
-    case GDK_MOTION_NOTIFY:
-      g_print ("(%.4g,%.4g) (%.4g,%.4g) %s",
-	       event->motion.x, event->motion.y,
-	       event->motion.x_root, event->motion.y_root,
-	       event->motion.is_hint ? "HINT " : "");
-      print_event_state (event->motion.state);
-      break;
-    case GDK_BUTTON_PRESS:
-    case GDK_2BUTTON_PRESS:
-    case GDK_3BUTTON_PRESS:
-    case GDK_BUTTON_RELEASE:
-      g_print ("%d (%.4g,%.4g) (%.4g,%.4g) ",
-	       event->button.button,
-	       event->button.x, event->button.y,
-	       event->button.x_root, event->button.y_root);
-      print_event_state (event->button.state);
-      break;
-    case GDK_KEY_PRESS: 
-    case GDK_KEY_RELEASE:
-      if (event->key.length == 0)
-	escaped = g_strdup ("");
-      else
-	escaped = g_strescape (event->key.string, NULL);
-      kvname = gdk_keyval_name (event->key.keyval);
-      g_print ("%#.02x group:%d %s %d:\"%s\" ",
-	       event->key.hardware_keycode, event->key.group,
-	       (kvname ? kvname : "??"),
-	       event->key.length,
-	       escaped);
-      g_free (escaped);
-      print_event_state (event->key.state);
-      break;
-    case GDK_ENTER_NOTIFY:
-    case GDK_LEAVE_NOTIFY:
-      g_print ("%p (%.4g,%.4g) (%.4g,%.4g) %s %s%s",
-	       event->crossing.subwindow == NULL ? NULL : GDK_WINDOW_HWND (event->crossing.subwindow),
-	       event->crossing.x, event->crossing.y,
-	       event->crossing.x_root, event->crossing.y_root,
-	       (event->crossing.mode == GDK_CROSSING_NORMAL ? "NORMAL" :
-		(event->crossing.mode == GDK_CROSSING_GRAB ? "GRAB" :
-		 (event->crossing.mode == GDK_CROSSING_UNGRAB ? "UNGRAB" :
-		  "???"))),
-	       (event->crossing.detail == GDK_NOTIFY_ANCESTOR ? "ANCESTOR" :
-		(event->crossing.detail == GDK_NOTIFY_VIRTUAL ? "VIRTUAL" :
-		 (event->crossing.detail == GDK_NOTIFY_INFERIOR ? "INFERIOR" :
-		  (event->crossing.detail == GDK_NOTIFY_NONLINEAR ? "NONLINEAR" :
-		   (event->crossing.detail == GDK_NOTIFY_NONLINEAR_VIRTUAL ? "NONLINEAR_VIRTUAL" :
-		    (event->crossing.detail == GDK_NOTIFY_UNKNOWN ? "UNKNOWN" :
-		     "???")))))),
-	       event->crossing.focus ? " FOCUS" : "");
-      print_event_state (event->crossing.state);
-      break;
-    case GDK_FOCUS_CHANGE:
-      g_print ("%s", (event->focus_change.in ? "IN" : "OUT"));
-      break;
-    case GDK_CONFIGURE:
-      g_print ("x:%d y:%d w:%d h:%d",
-	       event->configure.x, event->configure.y,
-	       event->configure.width, event->configure.height);
-      break;
-    case GDK_SELECTION_CLEAR:
-    case GDK_SELECTION_REQUEST:
-    case GDK_SELECTION_NOTIFY:
-      selection_name = gdk_atom_name (event->selection.selection);
-      target_name = gdk_atom_name (event->selection.target);
-      property_name = gdk_atom_name (event->selection.property);
-      g_print ("sel:%s tgt:%s prop:%s",
-	       selection_name, target_name, property_name);
-      g_free (selection_name);
-      g_free (target_name);
-      g_free (property_name);
-      break;
-    case GDK_DRAG_ENTER:
-    case GDK_DRAG_LEAVE:
-    case GDK_DRAG_MOTION:
-    case GDK_DRAG_STATUS:
-    case GDK_DROP_START:
-    case GDK_DROP_FINISHED:
-      if (event->dnd.context != NULL)
-	g_print ("ctx:%p: %s %s src:%p dest:%p",
-		 event->dnd.context,
-		 _gdk_win32_drag_protocol_to_string (event->dnd.context->protocol),
-		 event->dnd.context->is_source ? "SOURCE" : "DEST",
-		 event->dnd.context->source_window == NULL ? NULL : GDK_WINDOW_HWND (event->dnd.context->source_window),
-		 event->dnd.context->dest_window == NULL ? NULL : GDK_WINDOW_HWND (event->dnd.context->dest_window));
-      break;
-    case GDK_CLIENT_EVENT:
-      g_print ("%s %d %ld %ld %ld %ld %ld",
-	       gdk_atom_name (event->client.message_type),
-	       event->client.data_format,
-	       event->client.data.l[0],
-	       event->client.data.l[1],
-	       event->client.data.l[2],
-	       event->client.data.l[3],
-	       event->client.data.l[4]);
-      break;
-    case GDK_SCROLL:
-      g_print ("(%.4g,%.4g) (%.4g,%.4g) %s ",
-	       event->scroll.x, event->scroll.y,
-	       event->scroll.x_root, event->scroll.y_root,
-	       (event->scroll.direction == GDK_SCROLL_UP ? "UP" :
-		(event->scroll.direction == GDK_SCROLL_DOWN ? "DOWN" :
-		 (event->scroll.direction == GDK_SCROLL_LEFT ? "LEFT" :
-		  (event->scroll.direction == GDK_SCROLL_RIGHT ? "RIGHT" :
-		   "???")))));
-      print_event_state (event->scroll.state);
-      break;
-    case GDK_WINDOW_STATE:
-      g_print ("%s: %s",
-	       _gdk_win32_window_state_to_string (event->window_state.changed_mask),
-	       _gdk_win32_window_state_to_string (event->window_state.new_window_state));
-    case GDK_SETTING:
-      g_print ("%s: %s",
-	       (event->setting.action == GDK_SETTING_ACTION_NEW ? "NEW" :
-		(event->setting.action == GDK_SETTING_ACTION_CHANGED ? "CHANGED" :
-		 (event->setting.action == GDK_SETTING_ACTION_DELETED ? "DELETED" :
-		  "???"))),
-	       (event->setting.name ? event->setting.name : "NULL"));
-    case GDK_GRAB_BROKEN:
-      g_print ("%s %s %p",
-	       (event->grab_broken.keyboard ? "KEYBOARD" : "POINTER"),
-	       (event->grab_broken.implicit ? "IMPLICIT" : "EXPLICIT"),
-	       (event->grab_broken.grab_window ? GDK_WINDOW_HWND (event->grab_broken.grab_window) : 0));
-    default:
-      /* Nothing */
-      break;
-    }  
-  g_print ("%s", (debug_indent == 0 ? "\n" : "")); 
-}
-
-static char *
-decode_key_lparam (LPARAM lParam)
-{
-  static char buf[100];
-  char *p = buf;
-
-  if (HIWORD (lParam) & KF_UP)
-    p += g_sprintf (p, "KF_UP ");
-  if (HIWORD (lParam) & KF_REPEAT)
-    p += g_sprintf (p, "KF_REPEAT ");
-  if (HIWORD (lParam) & KF_ALTDOWN)
-    p += g_sprintf (p, "KF_ALTDOWN ");
-  if (HIWORD (lParam) & KF_EXTENDED)
-    p += g_sprintf (p, "KF_EXTENDED ");
-  p += g_sprintf (p, "sc:%d rep:%d", LOBYTE (HIWORD (lParam)), LOWORD (lParam));
-
-  return buf;
-}
-
-#endif
-
-static void
-fixup_event (GdkEvent *event)
-{
-  if (event->any.window)
-    g_object_ref (event->any.window);
-  if (((event->any.type == GDK_ENTER_NOTIFY) ||
-       (event->any.type == GDK_LEAVE_NOTIFY)) &&
-      (event->crossing.subwindow != NULL))
-    g_object_ref (event->crossing.subwindow);
-  event->any.send_event = InSendMessage (); 
-}
-
-void
-_gdk_win32_append_event (GdkEvent *event)
-{
-  GList *link;
-  
-  fixup_event (event);
-#if 1
-  link = _gdk_event_queue_append (_gdk_display, event);
-  GDK_NOTE (EVENTS, _gdk_win32_print_event (event));
-  /* event morphing, the passed in may not be valid afterwards */
-  _gdk_windowing_got_event (_gdk_display, link, event, 0);
-#else
-  _gdk_event_queue_append (_gdk_display, event);
-  GDK_NOTE (EVENTS, _gdk_win32_print_event (event));
-#endif
-}
-
-static void
-fill_key_event_string (GdkEvent *event)
-{
-  gunichar c;
-  gchar buf[256];
-
-  /* Fill in event->string crudely, since various programs
-   * depend on it.
-   */
-  
-  c = 0;
-  if (event->key.keyval != GDK_VoidSymbol)
-    c = gdk_keyval_to_unicode (event->key.keyval);
-
-  if (c)
-    {
-      gsize bytes_written;
-      gint len;
-      
-      /* Apply the control key - Taken from Xlib
-       */
-      if (event->key.state & GDK_CONTROL_MASK)
-	{
-	  if ((c >= '@' && c < '\177') || c == ' ')
-	    c &= 0x1F;
-	  else if (c == '2')
-	    {
-	      event->key.string = g_memdup ("\0\0", 2);
-	      event->key.length = 1;
-	      return;
-	    }
-	  else if (c >= '3' && c <= '7')
-	    c -= ('3' - '\033');
-	  else if (c == '8')
-	    c = '\177';
-	  else if (c == '/')
-	    c = '_' & 0x1F;
-	}
-      
-      len = g_unichar_to_utf8 (c, buf);
-      buf[len] = '\0';
-	  
-      event->key.string = g_locale_from_utf8 (buf, len,
-					      NULL, &bytes_written,
-					      NULL);
-      if (event->key.string)
-	event->key.length = bytes_written;
-    }
-  else if (event->key.keyval == GDK_Escape)
-    {
-      event->key.length = 1;
-      event->key.string = g_strdup ("\033");
-    }
-  else if (event->key.keyval == GDK_Return ||
-	   event->key.keyval == GDK_KP_Enter)
-    {
-      event->key.length = 1;
-      event->key.string = g_strdup ("\r");
-    }
-  
-  if (!event->key.string)
-    {
-      event->key.length = 0;
-      event->key.string = g_strdup ("");
-    }
-}
-
-static GdkFilterReturn
-apply_event_filters (GdkWindow  *window,
-		     MSG        *msg,
-		     GList      **filters)
-{
-  GdkFilterReturn result = GDK_FILTER_CONTINUE;
-  GdkEvent *event;
-  GList *node;
-  GList *tmp_list;
-
-  event = gdk_event_new (GDK_NOTHING);
-  if (window != NULL)
-    event->any.window = g_object_ref (window);
-  ((GdkEventPrivate *)event)->flags |= GDK_EVENT_PENDING;
-
-  /* I think GdkFilterFunc semantics require the passed-in event
-   * to already be in the queue. The filter func can generate
-   * more events and append them after it if it likes.
-   */
-  node = _gdk_event_queue_append (_gdk_display, event);
-  
-  tmp_list = *filters;
-  while (tmp_list)
-    {
-      GdkEventFilter *filter = (GdkEventFilter *) tmp_list->data;
-      GList *node;
-
-      if ((filter->flags & GDK_EVENT_FILTER_REMOVED) != 0)
-        {
-          tmp_list = tmp_list->next;
-          continue;
-        }
-
-      filter->ref_count++;
-      result = filter->function (msg, event, filter->data);
-
-      /* get the next node after running the function since the
-         function may add or remove a next node */
-      node = tmp_list;
-      tmp_list = tmp_list->next;
-
-      filter->ref_count--;
-      if (filter->ref_count == 0)
-        {
-          *filters = g_list_remove_link (*filters, node);
-          g_list_free_1 (node);
-          g_free (filter);
-        }
-
-      if (result != GDK_FILTER_CONTINUE)
-        break;
-    }
-
-  if (result == GDK_FILTER_CONTINUE || result == GDK_FILTER_REMOVE)
-    {
-      _gdk_event_queue_remove_link (_gdk_display, node);
-      g_list_free_1 (node);
-      gdk_event_free (event);
-    }
-  else /* GDK_FILTER_TRANSLATE */
-    {
-      ((GdkEventPrivate *)event)->flags &= ~GDK_EVENT_PENDING;
-      fixup_event (event);
-      GDK_NOTE (EVENTS, _gdk_win32_print_event (event));
-    }
-  return result;
-}
-
-/*
- * On Windows, transient windows will not have their own taskbar entries.
- * Because of this, we must hide and restore groups of transients in both
- * directions.  That is, all transient children must be hidden or restored
- * with this window, but if this window's transient owner also has a
- * transient owner then this window's transient owner must be hidden/restored
- * with this one.  And etc, up the chain until we hit an ancestor that has no
- * transient owner.
- *
- * It would be a good idea if applications don't chain transient windows
- * together.  There's a limit to how much evil GTK can try to shield you
- * from.
- */
-static void
-show_window_recurse (GdkWindow *window, gboolean hide_window)
-{
-  GdkWindowImplWin32 *impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-  GSList *children = impl->transient_children;
-  GdkWindow *child = NULL;
-
-  if (!impl->changing_state)
-    {
-      impl->changing_state = TRUE;
-
-      if (children != NULL)
-	{
-	  while (children != NULL)
-	    {
-	      child = children->data;
-	      show_window_recurse (child, hide_window);
-
-	      children = g_slist_next (children);
-	    }
-	}
-
-      if (GDK_WINDOW_IS_MAPPED (window))
-	{
-	  if (!hide_window)
-	    {
-	      if (GDK_WINDOW_OBJECT (window)->state & GDK_WINDOW_STATE_ICONIFIED)
-		{
-		  if (GDK_WINDOW_OBJECT (window)->state & GDK_WINDOW_STATE_MAXIMIZED)
-		    {
-		      ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWMAXIMIZED);
-		    }
-		  else
-		    {
-		      ShowWindow (GDK_WINDOW_HWND (window), SW_RESTORE);
-		    }
-		}
-	    }
-	  else
-	    {
-	      ShowWindow (GDK_WINDOW_HWND (window), SW_MINIMIZE);
-	    }
-	}
-
-      impl->changing_state = FALSE;
-    }
-}
-
-static void
-do_show_window (GdkWindow *window, gboolean hide_window)
-{
-  GdkWindow *tmp_window = NULL;
-  GdkWindowImplWin32 *tmp_impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-  if (!tmp_impl->changing_state)
-    {
-      /* Find the top-level window in our transient chain. */
-      while (tmp_impl->transient_owner != NULL)
-	{
-	  tmp_window = tmp_impl->transient_owner;
-	  tmp_impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (tmp_window)->impl);
-	}
-
-      /* If we couldn't find one, use the window provided. */
-      if (tmp_window == NULL)
-	{
-	  tmp_window = window;
-	}
-
-      /* Recursively show/hide every window in the chain. */
-      if (tmp_window != window)
-	{
-	  show_window_recurse (tmp_window, hide_window);
-	}
-    }
-}
-
-static void
-send_crossing_event (GdkDisplay                 *display,
-		     GdkWindowObject            *window,
-		     GdkEventType                type,
-		     GdkCrossingMode             mode,
-		     GdkNotifyType               notify_type,
-		     GdkWindow                  *subwindow,
-		     POINT                      *screen_pt,
-		     GdkModifierType             mask,
-		     guint32                     time_)
-{
-  GdkEvent *event;
-  GdkPointerGrabInfo *grab;
-  POINT pt;
-
-  grab = _gdk_display_has_pointer_grab (display, 0);
-
-  if (grab != NULL &&
-      !grab->owner_events &&
-      mode != GDK_CROSSING_UNGRAB)
-    {
-      /* !owner_event => only report events wrt grab window, ignore rest */
-      if ((GdkWindow *)window != grab->native_window)
-	return;
-    }
-
-  pt = *screen_pt;
-  ScreenToClient (GDK_WINDOW_HWND (window), &pt);
-  
-  event = gdk_event_new (type);
-  event->crossing.window = (GdkWindow *)window;
-  event->crossing.subwindow = subwindow;
-  event->crossing.time = _gdk_win32_get_next_tick (time_);
-  event->crossing.x = pt.x;
-  event->crossing.y = pt.y;
-  event->crossing.x_root = screen_pt->x + _gdk_offset_x;
-  event->crossing.y_root = screen_pt->y + _gdk_offset_y;
-  event->crossing.mode = mode;
-  event->crossing.detail = notify_type;
-  event->crossing.mode = mode;
-  event->crossing.detail = notify_type;
-  event->crossing.focus = FALSE;
-  event->crossing.state = mask;
-
-  _gdk_win32_append_event (event);
-  
-  /*
-  if (((GdkWindowObject *) window)->extension_events != 0)
-    _gdk_input_crossing_event ((GdkWindow *)window, type == GDK_ENTER_NOTIFY);
-  */
-}
-
-static GdkWindowObject *
-get_native_parent (GdkWindowObject *window)
-{
-  if (window->parent != NULL)
-    return window->parent->impl_window;
-  return NULL;
-}
-
-
-static GdkWindowObject *
-find_common_ancestor (GdkWindowObject *win1,
-		      GdkWindowObject *win2)
-{
-  GdkWindowObject *tmp;
-  GList *path1 = NULL, *path2 = NULL;
-  GList *list1, *list2;
-
-  tmp = win1;
-  while (tmp != NULL && tmp->window_type != GDK_WINDOW_ROOT)
-    {
-      path1 = g_list_prepend (path1, tmp);
-      tmp = get_native_parent (tmp);
-    }
-
-  tmp = win2;
-  while (tmp != NULL && tmp->window_type != GDK_WINDOW_ROOT)
-    {
-      path2 = g_list_prepend (path2, tmp);
-      tmp = get_native_parent (tmp);
-    }
-
-  list1 = path1;
-  list2 = path2;
-  tmp = NULL;
-  while (list1 && list2 && (list1->data == list2->data))
-    {
-      tmp = (GdkWindowObject *)list1->data;
-      list1 = g_list_next (list1);
-      list2 = g_list_next (list2);
-    }
-  g_list_free (path1);
-  g_list_free (path2);
-
-  return tmp;
-}
-
-void
-synthesize_crossing_events (GdkDisplay                 *display,
-			    GdkWindow                  *src,
-			    GdkWindow                  *dest,
-			    GdkCrossingMode             mode,
-			    POINT                      *screen_pt,
-			    GdkModifierType             mask,
-			    guint32                     time_,
-			    gboolean                    non_linear)
-{
-  GdkWindowObject *c;
-  GdkWindowObject *win, *last, *next;
-  GList *path, *list;
-  GdkWindowObject *a;
-  GdkWindowObject *b;
-  GdkNotifyType notify_type;
-
-  a = (GdkWindowObject *)src;
-  b = (GdkWindowObject *)dest;
-  if (a == b)
-    return; /* No crossings generated between src and dest */
-
-  c = find_common_ancestor (a, b);
-
-  non_linear |= (c != a) && (c != b);
-
-  if (a) /* There might not be a source (i.e. if no previous pointer_in_window) */
-    {
-      /* Traverse up from a to (excluding) c sending leave events */
-      if (non_linear)
-	notify_type = GDK_NOTIFY_NONLINEAR;
-      else if (c == a)
-	notify_type = GDK_NOTIFY_INFERIOR;
-      else
-	notify_type = GDK_NOTIFY_ANCESTOR;
-      send_crossing_event (display,
-			   a, GDK_LEAVE_NOTIFY,
-			   mode,
-			   notify_type,
-			   NULL,
-			   screen_pt,
-			   mask, time_);
-
-      if (c != a)
-	{
-	  if (non_linear)
-	    notify_type = GDK_NOTIFY_NONLINEAR_VIRTUAL;
-	  else
-	    notify_type = GDK_NOTIFY_VIRTUAL;
-
-	  last = a;
-	  win = get_native_parent (a);
-	  while (win != c && win->window_type != GDK_WINDOW_ROOT)
-	    {
-	      send_crossing_event (display,
-				   win, GDK_LEAVE_NOTIFY,
-				   mode,
-				   notify_type,
-				   (GdkWindow *)last,
-				   screen_pt,
-				   mask, time_);
-
-	      last = win;
-	      win = get_native_parent (win);
-	    }
-	}
-    }
-
-  if (b) /* Might not be a dest, e.g. if we're moving out of the window */
-    {
-      /* Traverse down from c to b */
-      if (c != b)
-	{
-	  path = NULL;
-	  win = get_native_parent (b);
-	  while (win != c && win->window_type != GDK_WINDOW_ROOT)
-	    {
-	      path = g_list_prepend (path, win);
-	      win = get_native_parent (win);
-	    }
-
-	  if (non_linear)
-	    notify_type = GDK_NOTIFY_NONLINEAR_VIRTUAL;
-	  else
-	    notify_type = GDK_NOTIFY_VIRTUAL;
-
-	  list = path;
-	  while (list)
-	    {
-	      win = (GdkWindowObject *)list->data;
-	      list = g_list_next (list);
-	      if (list)
-		next = (GdkWindowObject *)list->data;
-	      else
-		next = b;
-
-	      send_crossing_event (display,
-				   win, GDK_ENTER_NOTIFY,
-				   mode,
-				   notify_type,
-				   (GdkWindow *)next,
-				   screen_pt,
-				   mask, time_);
-	    }
-	  g_list_free (path);
-	}
-
-
-      if (non_linear)
-	notify_type = GDK_NOTIFY_NONLINEAR;
-      else if (c == a)
-	notify_type = GDK_NOTIFY_ANCESTOR;
-      else
-	notify_type = GDK_NOTIFY_INFERIOR;
-
-      send_crossing_event (display,
-			   b, GDK_ENTER_NOTIFY,
-			   mode,
-			   notify_type,
-			   NULL,
-			   screen_pt,
-			   mask, time_);
-    }
-}
-			 
-static void
-synthesize_expose_events (GdkWindow *window)
-{
-  RECT r;
-  HDC hdc;
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (((GdkWindowObject *) window)->impl);
-  GList *list = gdk_window_get_children (window);
-  GList *head = list;
-  GdkEvent *event;
-  int k;
-  
-  while (list)
-    {
-      synthesize_expose_events ((GdkWindow *) list->data);
-      list = list->next;
-    }
-
-  g_list_free (head);
-
-  if (((GdkWindowObject *) window)->input_only)
-    ;
-  else if (!(hdc = GetDC (impl->handle)))
-    WIN32_GDI_FAILED ("GetDC");
-  else
-    {
-      if ((k = GetClipBox (hdc, &r)) == ERROR)
-	WIN32_GDI_FAILED ("GetClipBox");
-      else if (k != NULLREGION)
-	{
-	  event = gdk_event_new (GDK_EXPOSE);
-	  event->expose.window = window;
-	  event->expose.area.x = r.left;
-	  event->expose.area.y = r.top;
-	  event->expose.area.width = r.right - r.left;
-	  event->expose.area.height = r.bottom - r.top;
-	  event->expose.region = gdk_region_rectangle (&(event->expose.area));
-	  event->expose.count = 0;
-  
-	  _gdk_win32_append_event (event);
-	}
-      GDI_CALL (ReleaseDC, (impl->handle, hdc));
-    }
-}
-
-static void
-update_colors (GdkWindow *window,
-	       gboolean   top)
-{
-  HDC hdc;
-  GdkDrawableImplWin32 *impl = GDK_DRAWABLE_IMPL_WIN32 (((GdkWindowObject *) window)->impl);
-  GList *list = gdk_window_get_children (window);
-  GList *head = list;
-
-  GDK_NOTE (COLORMAP, (top ? g_print ("update_colors:") : (void) 0));
-
-  while (list)
-    {
-      update_colors ((GdkWindow *) list->data, FALSE);
-      list = list->next;
-    }
-  g_list_free (head);
-
-  if (((GdkWindowObject *) window)->input_only ||
-      impl->colormap == NULL)
-    return;
-
-  if (!(hdc = GetDC (impl->handle)))
-    WIN32_GDI_FAILED ("GetDC");
-  else
-    {
-      GdkColormapPrivateWin32 *cmapp = GDK_WIN32_COLORMAP_DATA (impl->colormap);
-      HPALETTE holdpal;
-      gint k;
-      
-      if ((holdpal = SelectPalette (hdc, cmapp->hpal, TRUE)) == NULL)
-	WIN32_GDI_FAILED ("SelectPalette");
-      else if ((k = RealizePalette (hdc)) == GDI_ERROR)
-	WIN32_GDI_FAILED ("RealizePalette");
-      else
-	{
-	  GDK_NOTE (COLORMAP,
-		    (k > 0 ?
-		     g_print (" %p pal=%p: realized %d colors\n"
-			      "update_colors:",
-			      impl->handle, cmapp->hpal, k) :
-		     (void) 0,
-		     g_print (" %p", impl->handle)));
-	  GDI_CALL (UpdateColors, (hdc));
-	  SelectPalette (hdc, holdpal, TRUE);
-	  RealizePalette (hdc);
-	}
-      GDI_CALL (ReleaseDC, (impl->handle, hdc));
-    }
-  GDK_NOTE (COLORMAP, (top ? g_print ("\n") : (void) 0));
-}
-
-/* The check_extended flag controls whether to check if the windows want
- * events from extended input devices and if the message should be skipped
- * because an extended input device is active
- */
-static gboolean
-propagate (GdkWindow  **window,
-	   MSG         *msg,
-	   GdkWindow   *grab_window,
-	   gboolean     grab_owner_events,
-	   gint	        grab_mask,
-	   gboolean   (*doesnt_want_it) (gint mask,
-					 MSG *msg))
-{
-  if (grab_window != NULL && !grab_owner_events)
-    {
-      /* Event source is grabbed with owner_events FALSE */
-
-      /* See if the event should be ignored because an extended input
-       * device is used
-       */
-      if ((*doesnt_want_it) (grab_mask, msg))
-	{
-	  GDK_NOTE (EVENTS, g_print (" (grabber doesn't want it)"));
-	  return FALSE;
-	}
-      else
-	{
-	  GDK_NOTE (EVENTS, g_print (" (to grabber)"));
-	  assign_object (window, grab_window);
-	  return TRUE;
-	}
-    }
-
-  /* If we come here, we know that if grab_window != NULL then
-   * grab_owner_events is TRUE
-   */
-  while (TRUE)
-    {
-      if ((*doesnt_want_it) (((GdkWindowObject *) *window)->event_mask, msg))
-	{
-	  /* Owner doesn't want it, propagate to parent. */
-	  GdkWindow *parent = gdk_window_get_parent (*window);
-	  if (parent == _gdk_root || parent == NULL)
-	    {
-	      /* No parent; check if grabbed */
-	      if (grab_window != NULL)
-		{
-		  /* Event source is grabbed with owner_events TRUE */
-
-		  if ((*doesnt_want_it) (grab_mask, msg))
-		    {
-		      /* Grabber doesn't want it either */
-		      GDK_NOTE (EVENTS, g_print (" (grabber doesn't want it)"));
-		      return FALSE;
-		    }
-		  else
-		    {
-		      /* Grabbed! */
-		      GDK_NOTE (EVENTS, g_print (" (to grabber)"));
-		      assign_object (window, grab_window);
-		      return TRUE;
-		    }
-		}
-	      else
-		{
-		  GDK_NOTE (EVENTS, g_print (" (undelivered)"));
-		  return FALSE;
-		}
-	    }
-	  else
-	    {
-	      assign_object (window, parent);
-	      /* The only branch where we actually continue the loop */
-	    }
-	}
-      else
-	return TRUE;
-    }
-}
-
-static gboolean
-doesnt_want_key (gint mask,
-		 MSG *msg)
-{
-  return (((msg->message == WM_KEYUP || msg->message == WM_SYSKEYUP) &&
-	   !(mask & GDK_KEY_RELEASE_MASK)) ||
-	  ((msg->message == WM_KEYDOWN || msg->message == WM_SYSKEYDOWN) &&
-	   !(mask & GDK_KEY_PRESS_MASK)));
-}
-
-static gboolean
-doesnt_want_char (gint mask,
-		  MSG *msg)
-{
-  return !(mask & (GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK));
-}
-
-void
-_gdk_win32_emit_configure_event (GdkWindow *window)
-{
-  GdkWindowImplWin32 *window_impl;
-  RECT client_rect;
-  POINT point;
-  GdkWindowObject *window_object;
-  HWND hwnd;
-
-  window_object = GDK_WINDOW_OBJECT (window);
-
-  window_impl = GDK_WINDOW_IMPL_WIN32 (window_object->impl);
-  if (window_impl->inhibit_configure)
-    return;
-
-  hwnd = GDK_WINDOW_HWND (window);
-
-  GetClientRect (hwnd, &client_rect);
-  point.x = client_rect.left; /* always 0 */
-  point.y = client_rect.top;
-
-  /* top level windows need screen coords */
-  if (gdk_window_get_parent (window) == _gdk_root)
-    {
-      ClientToScreen (hwnd, &point);
-      point.x += _gdk_offset_x;
-      point.y += _gdk_offset_y;
-    }
-
-  window_object->width = client_rect.right - client_rect.left;
-  window_object->height = client_rect.bottom - client_rect.top;
-  
-  window_object->x = point.x;
-  window_object->y = point.y;
-
-  _gdk_window_update_size (window);
-  
-  if (window_object->event_mask & GDK_STRUCTURE_MASK)
-    {
-      GdkEvent *event = gdk_event_new (GDK_CONFIGURE);
-
-      event->configure.window = window;
-
-      event->configure.width = client_rect.right - client_rect.left;
-      event->configure.height = client_rect.bottom - client_rect.top;
-      
-      event->configure.x = point.x;
-      event->configure.y = point.y;
-
-      _gdk_win32_append_event (event);
-    }
-}
-
-GdkRegion *
-_gdk_win32_hrgn_to_region (HRGN hrgn)
-{
-  RGNDATA *rgndata;
-  RECT *rects;
-  GdkRegion *result;
-  gint nbytes;
-  guint i;
-
-  if ((nbytes = GetRegionData (hrgn, 0, NULL)) == 0)
-    {
-      WIN32_GDI_FAILED ("GetRegionData");
-      return NULL;
-    }
-
-  rgndata = (RGNDATA *) g_malloc (nbytes);
-
-  if (GetRegionData (hrgn, nbytes, rgndata) == 0)
-    {
-      WIN32_GDI_FAILED ("GetRegionData");
-      g_free (rgndata);
-      return NULL;
-    }
-
-  result = gdk_region_new ();
-  rects = (RECT *) rgndata->Buffer;
-  for (i = 0; i < rgndata->rdh.nCount; i++)
-    {
-      GdkRectangle r;
-
-      r.x = rects[i].left;
-      r.y = rects[i].top;
-      r.width = rects[i].right - r.x;
-      r.height = rects[i].bottom - r.y;
-
-      gdk_region_union_with_rect (result, &r);
-    }
-
-  g_free (rgndata);
-
-  return result;
-}
-
-static void
-adjust_drag (LONG *drag,
-	     LONG  curr,
-	     gint  inc)
-{
-  if (*drag > curr)
-    *drag = curr + ((*drag + inc/2 - curr) / inc) * inc;
-  else
-    *drag = curr - ((curr - *drag + inc/2) / inc) * inc;
-}
-
-static void
-handle_wm_paint (MSG        *msg,
-		 GdkWindow  *window,
-		 gboolean    return_exposes,
-		 GdkEvent  **event)
-{
-  HRGN hrgn = CreateRectRgn (0, 0, 0, 0);
-  HDC hdc;
-  PAINTSTRUCT paintstruct;
-  GdkRegion *update_region;
-
-  if (GetUpdateRgn (msg->hwnd, hrgn, FALSE) == ERROR)
-    {
-      WIN32_GDI_FAILED ("GetUpdateRgn");
-      DeleteObject (hrgn);
-      return;
-    }
-
-  hdc = BeginPaint (msg->hwnd, &paintstruct);
-
-  GDK_NOTE (EVENTS, g_print (" %s %s dc %p%s",
-			     _gdk_win32_rect_to_string (&paintstruct.rcPaint),
-			     (paintstruct.fErase ? "erase" : ""),
-			     hdc,
-			     (return_exposes ? " return_exposes" : "")));
-
-  EndPaint (msg->hwnd, &paintstruct);
-
-  if ((paintstruct.rcPaint.right == paintstruct.rcPaint.left) ||
-      (paintstruct.rcPaint.bottom == paintstruct.rcPaint.top))
-    {
-      GDK_NOTE (EVENTS, g_print (" (empty paintstruct, ignored)"));
-      DeleteObject (hrgn);
-      return;
-    }
-
-  if (return_exposes)
-    {
-      if (!GDK_WINDOW_DESTROYED (window))
-	{
-	  GList *list = _gdk_display->queued_events;
-
-	  *event = gdk_event_new (GDK_EXPOSE);
-	  (*event)->expose.window = window;
-	  (*event)->expose.area.x = paintstruct.rcPaint.left;
-	  (*event)->expose.area.y = paintstruct.rcPaint.top;
-	  (*event)->expose.area.width = paintstruct.rcPaint.right - paintstruct.rcPaint.left;
-	  (*event)->expose.area.height = paintstruct.rcPaint.bottom - paintstruct.rcPaint.top;
-	  (*event)->expose.region = _gdk_win32_hrgn_to_region (hrgn);
-	  (*event)->expose.count = 0;
-
-	  while (list != NULL)
-	    {
-	      GdkEventPrivate *evp = list->data;
-
-	      if (evp->event.any.type == GDK_EXPOSE &&
-		  evp->event.any.window == window &&
-		  !(evp->flags & GDK_EVENT_PENDING))
-		evp->event.expose.count++;
-
-	      list = list->next;
-	    }
-	}
-
-      DeleteObject (hrgn);
-      return;
-    }
-
-  update_region = _gdk_win32_hrgn_to_region (hrgn);
-  if (!gdk_region_empty (update_region))
-    _gdk_window_invalidate_for_expose (window, update_region);
-  gdk_region_destroy (update_region);
-
-  DeleteObject (hrgn);
-}
-
-static VOID CALLBACK 
-modal_timer_proc (HWND     hwnd,
-		  UINT     msg,
-		  UINT_PTR id,
-		  DWORD    time)
-{
-  int arbitrary_limit = 10;
-
-  while (_modal_operation_in_progress &&
-	 g_main_context_pending (NULL) &&
-	 arbitrary_limit--)
-    g_main_context_iteration (NULL, FALSE);
-}
-
-void
-_gdk_win32_begin_modal_call (void)
-{
-  g_assert (!_modal_operation_in_progress);
-
-  _modal_operation_in_progress = TRUE;
-
-  modal_timer = SetTimer (NULL, 0, 10, modal_timer_proc);
-  if (modal_timer == 0)
-    WIN32_API_FAILED ("SetTimer");
-}
-
-void
-_gdk_win32_end_modal_call (void)
-{
-  g_assert (_modal_operation_in_progress);
-
-  _modal_operation_in_progress = FALSE;
-
-  if (modal_timer != 0)
-    {
-      API_CALL (KillTimer, (NULL, modal_timer));
-      modal_timer = 0;
-   }
-}
-
-static VOID CALLBACK
-sync_timer_proc (HWND     hwnd,
-		 UINT     msg,
-		 UINT_PTR id,
-		 DWORD    time)
-{
-  MSG message;
-  if (PeekMessageW (&message, hwnd, WM_PAINT, WM_PAINT, PM_REMOVE))
-    {
-      return;
-    }
-
-  RedrawWindow (hwnd, NULL, NULL, RDW_INVALIDATE|RDW_UPDATENOW|RDW_ALLCHILDREN);
-
-  KillTimer (hwnd, sync_timer);
-}
-
-static void
-handle_display_change (void)
-{
-  _gdk_monitor_init ();
-  _gdk_root_window_size_init ();
-  g_signal_emit_by_name (_gdk_screen, "size_changed");
-}
-
-static void
-generate_button_event (GdkEventType type,
-		       gint         button,
-		       GdkWindow   *window,
-		       MSG         *msg)
-{
-  GdkEvent *event = gdk_event_new (type);
-
-  event->button.window = window;
-  event->button.time = _gdk_win32_get_next_tick (msg->time);
-  event->button.x = current_x = (gint16) GET_X_LPARAM (msg->lParam);
-  event->button.y = current_y = (gint16) GET_Y_LPARAM (msg->lParam);
-  event->button.x_root = msg->pt.x + _gdk_offset_x;
-  event->button.y_root = msg->pt.y + _gdk_offset_y;
-  event->button.axes = NULL;
-  event->button.state = build_pointer_event_state (msg);
-  event->button.button = button;
-  event->button.device = _gdk_display->core_pointer;
-
-  _gdk_win32_append_event (event);
-}
-
-static void
-ensure_stacking_on_unminimize (MSG *msg)
-{
-  HWND rover;
-  HWND lowest_transient = NULL;
-
-  rover = msg->hwnd;
-  while ((rover = GetNextWindow (rover, GW_HWNDNEXT)))
-    {
-      GdkWindow *rover_gdkw = gdk_win32_handle_table_lookup (rover);
-
-      /* Checking window group not implemented yet */
-      if (rover_gdkw)
-	{
-	  GdkWindowImplWin32 *rover_impl =
-	    (GdkWindowImplWin32 *)((GdkWindowObject *)rover_gdkw)->impl;
-
-	  if (GDK_WINDOW_IS_MAPPED (rover_gdkw) &&
-	      (rover_impl->type_hint == GDK_WINDOW_TYPE_HINT_UTILITY ||
-	       rover_impl->type_hint == GDK_WINDOW_TYPE_HINT_DIALOG ||
-	       rover_impl->transient_owner != NULL))
-	    {
-	      lowest_transient = rover;
-	    }
-	}
-    }
-  if (lowest_transient != NULL)
-    {
-      GDK_NOTE (EVENTS, g_print (" restacking: %p", lowest_transient));
-      SetWindowPos (msg->hwnd, lowest_transient, 0, 0, 0, 0,
-		    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
-    }
-}
-
-static gboolean
-ensure_stacking_on_window_pos_changing (MSG       *msg,
-					GdkWindow *window)
-{
-  GdkWindowImplWin32 *impl = (GdkWindowImplWin32 *)((GdkWindowObject *) window)->impl;
-  WINDOWPOS *windowpos = (WINDOWPOS *) msg->lParam;
-
-  if (GetActiveWindow () == msg->hwnd &&
-      impl->type_hint != GDK_WINDOW_TYPE_HINT_UTILITY &&
-      impl->type_hint != GDK_WINDOW_TYPE_HINT_DIALOG &&
-      impl->transient_owner == NULL)
-    {
-      /* Make sure the window stays behind any transient-type windows
-       * of the same window group.
-       *
-       * If the window is not active and being activated, we let
-       * Windows bring it to the top and rely on the WM_ACTIVATEAPP
-       * handling to bring any utility windows on top of it.
-       */
-      HWND rover;
-      gboolean restacking;
-
-      rover = windowpos->hwndInsertAfter;
-      restacking = FALSE;
-      while (rover)
-	{
-	  GdkWindow *rover_gdkw = gdk_win32_handle_table_lookup (rover);
-
-	  /* Checking window group not implemented yet */
-	  if (rover_gdkw)
-	    {
-	      GdkWindowImplWin32 *rover_impl =
-		(GdkWindowImplWin32 *)((GdkWindowObject *)rover_gdkw)->impl;
-
-	      if (GDK_WINDOW_IS_MAPPED (rover_gdkw) &&
-		  (rover_impl->type_hint == GDK_WINDOW_TYPE_HINT_UTILITY ||
-		   rover_impl->type_hint == GDK_WINDOW_TYPE_HINT_DIALOG ||
-		   rover_impl->transient_owner != NULL))
-		{
-		  restacking = TRUE;
-		  windowpos->hwndInsertAfter = rover;
-		}
-	    }
-	  rover = GetNextWindow (rover, GW_HWNDNEXT);
-	}
-
-      if (restacking)
-	{
-	  GDK_NOTE (EVENTS, g_print (" restacking: %p", windowpos->hwndInsertAfter));
-	  return TRUE;
-	}
-    }
-  return FALSE;
-}
-
-static void
-ensure_stacking_on_activate_app (MSG       *msg,
-				 GdkWindow *window)
-{
-  GdkWindowImplWin32 *impl = (GdkWindowImplWin32 *)((GdkWindowObject *) window)->impl;
-
-  if (impl->type_hint == GDK_WINDOW_TYPE_HINT_UTILITY ||
-      impl->type_hint == GDK_WINDOW_TYPE_HINT_DIALOG ||
-      impl->transient_owner != NULL)
-    {
-      SetWindowPos (msg->hwnd, HWND_TOP, 0, 0, 0, 0,
-		    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
-      return;
-    }
-
-  if (IsWindowVisible (msg->hwnd) &&
-      msg->hwnd == GetActiveWindow ())
-    {
-      /* This window is not a transient-type window and it is the
-       * activated window. Make sure this window is as visible as
-       * possible, just below the lowest transient-type window of this
-       * app.
-       */
-      HWND rover;
-
-      rover = msg->hwnd;
-      while ((rover = GetNextWindow (rover, GW_HWNDPREV)))
-	{
-	  GdkWindow *rover_gdkw = gdk_win32_handle_table_lookup (rover);
-
-	  /* Checking window group not implemented yet */
-	  if (rover_gdkw)
-	    {
-	      GdkWindowImplWin32 *rover_impl =
-		(GdkWindowImplWin32 *)((GdkWindowObject *)rover_gdkw)->impl;
-
-	      if (GDK_WINDOW_IS_MAPPED (rover_gdkw) &&
-		  (rover_impl->type_hint == GDK_WINDOW_TYPE_HINT_UTILITY ||
-		   rover_impl->type_hint == GDK_WINDOW_TYPE_HINT_DIALOG ||
-		   rover_impl->transient_owner != NULL))
-		{
-		  GDK_NOTE (EVENTS, g_print (" restacking: %p", rover));
-		  SetWindowPos (msg->hwnd, rover, 0, 0, 0, 0,
-				SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
-		  break;
-		}
-	    }
-	}
-    }
-}
-
-#define GDK_ANY_BUTTON_MASK (GDK_BUTTON1_MASK | \
-			     GDK_BUTTON2_MASK | \
-			     GDK_BUTTON3_MASK | \
-			     GDK_BUTTON4_MASK | \
-			     GDK_BUTTON5_MASK)
-
-static gboolean
-gdk_event_translate (MSG  *msg,
-		     gint *ret_valp)
-{
-  RECT rect, *drag, orig_drag;
-  POINT point;
-  MINMAXINFO *mmi;
-  HWND hwnd;
-  HCURSOR hcursor;
-  BYTE key_state[256];
-  HIMC himc;
-  WINDOWPOS *windowpos;
-  gboolean ignore_leave;
-
-  GdkEvent *event;
-
-  wchar_t wbuf[100];
-  gint ccount;
-
-  GdkWindow *window = NULL;
-  GdkWindowImplWin32 *impl;
-
-  GdkWindow *orig_window, *new_window;
-
-  GdkPointerGrabInfo *grab = NULL;
-  GdkWindow *grab_window = NULL;
-
-  static gint update_colors_counter = 0;
-  gint button;
-  GdkAtom target;
-
-  gchar buf[256];
-  gboolean return_val = FALSE;
-
-  int i;
-
-  if (_gdk_default_filters)
-    {
-      /* Apply global filters */
-
-      GdkFilterReturn result = apply_event_filters (NULL, msg, &_gdk_default_filters);
-      
-      /* If result is GDK_FILTER_CONTINUE, we continue as if nothing
-       * happened. If it is GDK_FILTER_REMOVE or GDK_FILTER_TRANSLATE,
-       * we return TRUE, and DefWindowProcW() will not be called.
-       */
-      if (result == GDK_FILTER_REMOVE || result == GDK_FILTER_TRANSLATE)
-	return TRUE;
-    }
-
-  window = gdk_win32_handle_table_lookup ((GdkNativeWindow) msg->hwnd);
-  orig_window = window;
-
-  if (window == NULL)
-    {
-      /* XXX Handle WM_QUIT here ? */
-      if (msg->message == WM_QUIT)
-	{
-	  GDK_NOTE (EVENTS, g_print (" %d", (int) msg->wParam));
-	  exit (msg->wParam);
-	}
-      else if (msg->message == WM_CREATE)
-	{
-	  window = (UNALIGNED GdkWindow*) (((LPCREATESTRUCTW) msg->lParam)->lpCreateParams);
-	  GDK_WINDOW_HWND (window) = msg->hwnd;
-	}
-      else
-	{
-	  GDK_NOTE (EVENTS, g_print (" (no GdkWindow)"));
-	}
-      return FALSE;
-    }
-  
-  g_object_ref (window);
-
-  /* window's refcount has now been increased, so code below should
-   * not just return from this function, but instead goto done (or
-   * break out of the big switch). To protect against forgetting this,
-   * #define return to a syntax error...
-   */
-#define return GOTO_DONE_INSTEAD
-  
-  if (!GDK_WINDOW_DESTROYED (window) && ((GdkWindowObject *) window)->filters)
-    {
-      /* Apply per-window filters */
-
-      GdkFilterReturn result = apply_event_filters (window, msg, &((GdkWindowObject *) window)->filters);
-
-      if (result == GDK_FILTER_REMOVE || result == GDK_FILTER_TRANSLATE)
-	{
-	  return_val = TRUE;
-	  goto done;
-	}
-    }
-
-  if (msg->message == client_message)
-    {
-      GList *tmp_list;
-      GdkFilterReturn result = GDK_FILTER_CONTINUE;
-      GList *node;
-
-      GDK_NOTE (EVENTS, g_print (" client_message"));
-
-      event = gdk_event_new (GDK_NOTHING);
-      ((GdkEventPrivate *)event)->flags |= GDK_EVENT_PENDING;
-
-      node = _gdk_event_queue_append (_gdk_display, event);
-
-      tmp_list = client_filters;
-      while (tmp_list)
-	{
-	  GdkClientFilter *filter = tmp_list->data;
-
-	  tmp_list = tmp_list->next;
-
-	  if (filter->type == GDK_POINTER_TO_ATOM (msg->wParam))
-	    {
-	      GDK_NOTE (EVENTS, g_print (" (match)"));
-
-	      result = (*filter->function) (msg, event, filter->data);
-
-	      if (result != GDK_FILTER_CONTINUE)
-		break;
-	    }
-	}
-
-      switch (result)
-	{
-	case GDK_FILTER_REMOVE:
-	  _gdk_event_queue_remove_link (_gdk_display, node);
-	  g_list_free_1 (node);
-	  gdk_event_free (event);
-	  return_val = TRUE;
-	  goto done;
-
-	case GDK_FILTER_TRANSLATE:
-	  ((GdkEventPrivate *)event)->flags &= ~GDK_EVENT_PENDING;
-	  GDK_NOTE (EVENTS, _gdk_win32_print_event (event));
-	  return_val = TRUE;
-	  goto done;
-
-	case GDK_FILTER_CONTINUE:
-	  /* Send unknown client messages on to Gtk for it to use */
-
-	  event->client.type = GDK_CLIENT_EVENT;
-	  event->client.window = window;
-	  event->client.message_type = GDK_POINTER_TO_ATOM (msg->wParam);
-	  event->client.data_format = 32;
-	  event->client.data.l[0] = msg->lParam;
-	  for (i = 1; i < 5; i++)
-	    event->client.data.l[i] = 0;
-	  GDK_NOTE (EVENTS, _gdk_win32_print_event (event));
-	  return_val = TRUE;
-	  goto done;
-	}
-    }
-
-  switch (msg->message)
-    {
-    case WM_INPUTLANGCHANGE:
-      _gdk_input_locale = (HKL) msg->lParam;
-      _gdk_win32_keymap_set_active_layout (GDK_WIN32_KEYMAP (gdk_keymap_get_default ()), _gdk_input_locale);
-      _gdk_input_locale_is_ime = ImmIsIME (_gdk_input_locale);
-      GetLocaleInfo (MAKELCID (LOWORD (_gdk_input_locale), SORT_DEFAULT),
-		     LOCALE_IDEFAULTANSICODEPAGE,
-		     buf, sizeof (buf));
-      _gdk_input_codepage = atoi (buf);
-      _gdk_keymap_serial++;
-      GDK_NOTE (EVENTS,
-		g_print (" cs:%lu hkl:%p%s cp:%d",
-			 (gulong) msg->wParam,
-			 (gpointer) msg->lParam, _gdk_input_locale_is_ime ? " (IME)" : "",
-			 _gdk_input_codepage));
-      break;
-
-    case WM_SYSKEYUP:
-    case WM_SYSKEYDOWN:
-      GDK_NOTE (EVENTS,
-		g_print (" %s ch:%.02x %s",
-			 _gdk_win32_key_to_string (msg->lParam),
-			 (int) msg->wParam,
-			 decode_key_lparam (msg->lParam)));
-
-      /* If posted without us having keyboard focus, ignore */
-      if ((msg->wParam != VK_F10 && msg->wParam != VK_MENU) &&
-	  !(HIWORD (msg->lParam) & KF_ALTDOWN))
-	break;
-
-      /* Let the system handle Alt-Tab, Alt-Space and Alt-F4 unless
-       * the keyboard is grabbed.
-       */
-      if (_gdk_display->keyboard_grab.window == NULL &&
-	  (msg->wParam == VK_TAB ||
-	   msg->wParam == VK_SPACE ||
-	   msg->wParam == VK_F4))
-	break;
-
-      /* Jump to code in common with WM_KEYUP and WM_KEYDOWN */
-      goto keyup_or_down;
-
-    case WM_KEYUP:
-    case WM_KEYDOWN:
-      GDK_NOTE (EVENTS, 
-		g_print (" %s ch:%.02x %s",
-			 _gdk_win32_key_to_string (msg->lParam),
-			 (int) msg->wParam,
-			 decode_key_lparam (msg->lParam)));
-
-    keyup_or_down:
-
-      /* Ignore key messages intended for the IME */
-      if (msg->wParam == VK_PROCESSKEY ||
-	  in_ime_composition)
-	break;
-
-      /* Ignore autorepeats on modifiers */
-      if (msg->message == WM_KEYDOWN &&
-          (msg->wParam == VK_MENU ||
-           msg->wParam == VK_CONTROL ||
-           msg->wParam == VK_SHIFT) &&
-           ((HIWORD(msg->lParam) & KF_REPEAT) >= 1))
-        break;
-
-      if (!propagate (&window, msg,
-		      _gdk_display->keyboard_grab.window,
-		      _gdk_display->keyboard_grab.owner_events,
-		      GDK_ALL_EVENTS_MASK,
-		      doesnt_want_key))
-	break;
-
-      if (GDK_WINDOW_DESTROYED (window))
-	break;
-
-      impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-      API_CALL (GetKeyboardState, (key_state));
-
-      ccount = 0;
-
-      if (msg->wParam == VK_PACKET)
-	{
-	  ccount = ToUnicode (VK_PACKET, HIWORD (msg->lParam), key_state, wbuf, 1, 0);
-	  if (ccount == 1)
-	    {
-	      if (wbuf[0] >= 0xD800 && wbuf[0] < 0xDC00)
-	        {
-		  if (msg->message == WM_KEYDOWN)
-		    impl->leading_surrogate_keydown = wbuf[0];
-		  else
-		    impl->leading_surrogate_keyup = wbuf[0];
-
-		  /* don't emit an event */
-		  return_val = TRUE;
-		  break;
-	        }
-	      else
-		{
-		  /* wait until an event is created */;
-		}
-	    }
-	}
-
-      event = gdk_event_new ((msg->message == WM_KEYDOWN ||
-			      msg->message == WM_SYSKEYDOWN) ?
-			     GDK_KEY_PRESS : GDK_KEY_RELEASE);
-      event->key.window = window;
-      event->key.time = _gdk_win32_get_next_tick (msg->time);
-      event->key.keyval = GDK_VoidSymbol;
-      event->key.string = NULL;
-      event->key.length = 0;
-      event->key.hardware_keycode = msg->wParam;
-      if (HIWORD (msg->lParam) & KF_EXTENDED)
-	{
-	  switch (msg->wParam)
-	    {
-	    case VK_CONTROL:
-	      event->key.hardware_keycode = VK_RCONTROL;
-	      break;
-	    case VK_SHIFT:	/* Actually, KF_EXTENDED is not set
-				 * for the right shift key.
-				 */
-	      event->key.hardware_keycode = VK_RSHIFT;
-	      break;
-	    case VK_MENU:
-	      event->key.hardware_keycode = VK_RMENU;
-	      break;
-	    }
-	}
-      else if (msg->wParam == VK_SHIFT &&
-	       LOBYTE (HIWORD (msg->lParam)) == _gdk_win32_keymap_get_rshift_scancode (GDK_WIN32_KEYMAP (gdk_keymap_get_default ())))
-	event->key.hardware_keycode = VK_RSHIFT;
-
-      /* g_print ("ctrl:%02x lctrl:%02x rctrl:%02x alt:%02x lalt:%02x ralt:%02x\n", key_state[VK_CONTROL], key_state[VK_LCONTROL], key_state[VK_RCONTROL], key_state[VK_MENU], key_state[VK_LMENU], key_state[VK_RMENU]); */
-      
-      build_key_event_state (event, key_state);
-
-      if (msg->wParam == VK_PACKET && ccount == 1)
-	{
-	  if (wbuf[0] >= 0xD800 && wbuf[0] < 0xDC00)
-	    {
-	      g_assert_not_reached ();
-	    }
-	  else if (wbuf[0] >= 0xDC00 && wbuf[0] < 0xE000)
-	    {
-	      wchar_t leading;
-
-              if (msg->message == WM_KEYDOWN)
-		leading = impl->leading_surrogate_keydown;
-	      else
-		leading = impl->leading_surrogate_keyup;
-
-	      event->key.keyval = gdk_unicode_to_keyval ((leading - 0xD800) * 0x400 + wbuf[0] - 0xDC00 + 0x10000);
-	    }
-	  else
-	    {
-	      event->key.keyval = gdk_unicode_to_keyval (wbuf[0]);
-	    }
-	}
-      else
-	{
-	  gdk_keymap_translate_keyboard_state (gdk_keymap_get_for_display (_gdk_display),
-					       event->key.hardware_keycode,
-					       event->key.state,
-					       event->key.group,
-					       &event->key.keyval,
-					       NULL, NULL, NULL);
-	}
-
-      if (msg->message == WM_KEYDOWN)
-	impl->leading_surrogate_keydown = 0;
-      else
-	impl->leading_surrogate_keyup = 0;
-
-      fill_key_event_string (event);
-
-      /* Reset MOD1_MASK if it is the Alt key itself */
-      if (msg->wParam == VK_MENU)
-	event->key.state &= ~GDK_MOD1_MASK;
-
-      _gdk_win32_append_event (event);
-
-      return_val = TRUE;
-      break;
-
-    case WM_SYSCHAR:
-      if (msg->wParam != VK_SPACE)
-	{
-	  /* To prevent beeps, don't let DefWindowProcW() be called */
-	  return_val = TRUE;
-	  goto done;
-	}
-      break;
-
-    case WM_IME_STARTCOMPOSITION:
-      in_ime_composition = TRUE;
-      break;
-
-    case WM_IME_ENDCOMPOSITION:
-      in_ime_composition = FALSE;
-      break;
-
-    case WM_IME_COMPOSITION:
-      /* On Win2k WM_IME_CHAR doesn't work correctly for non-Unicode
-       * applications. Thus, handle WM_IME_COMPOSITION with
-       * GCS_RESULTSTR instead, fetch the Unicode chars from the IME
-       * with ImmGetCompositionStringW().
-       *
-       * See for instance
-       * http://groups.google.com/groups?selm=natX5.57%24g77.19788%40nntp2.onemain.com
-       * and
-       * http://groups.google.com/groups?selm=u2XfrXw5BHA.1628%40tkmsftngp02
-       * for comments by other people that seems to have the same
-       * experience. WM_IME_CHAR just gives question marks, apparently
-       * because of going through some conversion to the current code
-       * page.
-       *
-       * WM_IME_CHAR might work on NT4 or Win9x with ActiveIMM, but
-       * use WM_IME_COMPOSITION there, too, to simplify the code.
-       */
-      GDK_NOTE (EVENTS, g_print (" %#lx", (long) msg->lParam));
-
-      if (!(msg->lParam & GCS_RESULTSTR))
-	break;
-
-      if (!propagate (&window, msg,
-		      _gdk_display->keyboard_grab.window,
-		      _gdk_display->keyboard_grab.owner_events,
-		      GDK_ALL_EVENTS_MASK,
-		      doesnt_want_char))
-	break;
-
-      if (GDK_WINDOW_DESTROYED (window))
-	break;
-
-      himc = ImmGetContext (msg->hwnd);
-      ccount = ImmGetCompositionStringW (himc, GCS_RESULTSTR,
-					 wbuf, sizeof (wbuf));
-      ImmReleaseContext (msg->hwnd, himc);
-
-      ccount /= 2;
-
-      API_CALL (GetKeyboardState, (key_state));
-
-      for (i = 0; i < ccount; i++)
-	{
-	  if (((GdkWindowObject *) window)->event_mask & GDK_KEY_PRESS_MASK)
-	    {
-	      /* Build a key press event */
-	      event = gdk_event_new (GDK_KEY_PRESS);
-	      event->key.window = window;
-	      build_wm_ime_composition_event (event, msg, wbuf[i], key_state);
-
-	      _gdk_win32_append_event (event);
-	    }
-	  
-	  if (((GdkWindowObject *) window)->event_mask & GDK_KEY_RELEASE_MASK)
-	    {
-	      /* Build a key release event.  */
-	      event = gdk_event_new (GDK_KEY_RELEASE);
-	      event->key.window = window;
-	      build_wm_ime_composition_event (event, msg, wbuf[i], key_state);
-
-	      _gdk_win32_append_event (event);
-	    }
-	}
-      return_val = TRUE;
-      break;
-
-    case WM_LBUTTONDOWN:
-      button = 1;
-      goto buttondown0;
-
-    case WM_MBUTTONDOWN:
-      button = 2;
-      goto buttondown0;
-
-    case WM_RBUTTONDOWN:
-      button = 3;
-      goto buttondown0;
-
-    case WM_XBUTTONDOWN:
-      if (HIWORD (msg->wParam) == XBUTTON1)
-	button = 4;
-      else
-	button = 5;
-
-    buttondown0:
-      GDK_NOTE (EVENTS, 
-		g_print (" (%d,%d)",
-			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
-
-      assign_object (&window, find_window_for_mouse_event (window, msg));
-
-      if (GDK_WINDOW_DESTROYED (window))
-	break;
-
-      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
-      if (grab == NULL)
-	{
-	  SetCapture (GDK_WINDOW_HWND (window));
-	}
-
-      generate_button_event (GDK_BUTTON_PRESS, button,
-			     window, msg);
-
-      return_val = TRUE;
-      break;
-
-    case WM_LBUTTONUP:
-      button = 1;
-      goto buttonup0;
-
-    case WM_MBUTTONUP:
-      button = 2;
-      goto buttonup0;
-
-    case WM_RBUTTONUP:
-      button = 3;
-      goto buttonup0;
-
-    case WM_XBUTTONUP:
-      if (HIWORD (msg->wParam) == XBUTTON1)
-	button = 4;
-      else
-	button = 5;
-
-    buttonup0:
-      GDK_NOTE (EVENTS, 
-		g_print (" (%d,%d)",
-			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
-
-      assign_object (&window, find_window_for_mouse_event (window, msg));
-      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
-      if (grab != NULL && grab->implicit)
-	{
-	  gint state = build_pointer_event_state (msg);
-
-	  /* We keep the implicit grab until no buttons at all are held down */
-	  if ((state & GDK_ANY_BUTTON_MASK & ~(GDK_BUTTON1_MASK << (button - 1))) == 0)
-	    {
-	      ReleaseCapture ();
-
-	      new_window = NULL;
-	      hwnd = WindowFromPoint (msg->pt);
-	      if (hwnd != NULL)
-		{
-		  POINT client_pt = msg->pt;
-
-		  ScreenToClient (hwnd, &client_pt);
-		  GetClientRect (hwnd, &rect);
-		  if (PtInRect (&rect, client_pt))
-		    new_window = gdk_win32_handle_table_lookup ((GdkNativeWindow) hwnd);
-		}
-	      synthesize_crossing_events (_gdk_display,
-					  grab->native_window, new_window,
-					  GDK_CROSSING_UNGRAB,
-					  &msg->pt,
-					  0, /* TODO: Set right mask */
-					  msg->time,
-					  FALSE);
-	      assign_object (&mouse_window, new_window);
-	      mouse_window_ignored_leave = NULL;
-	    }
-	}
-
-      generate_button_event (GDK_BUTTON_RELEASE, button,
-			     window, msg);
-
-      return_val = TRUE;
-      break;
-
-    case WM_MOUSEMOVE:
-      GDK_NOTE (EVENTS,
-		g_print (" %p (%d,%d)",
-			 (gpointer) msg->wParam,
-			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
-
-      new_window = window;
-
-      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
-      if (grab != NULL)
-	{
-	  POINT pt;
-	  pt = msg->pt;
-
-	  new_window = NULL;
-	  hwnd = WindowFromPoint (pt);
-	  if (hwnd != NULL)
-	    {
-	      POINT client_pt = pt;
-
-	      ScreenToClient (hwnd, &client_pt);
-	      GetClientRect (hwnd, &rect);
-	      if (PtInRect (&rect, client_pt))
-		new_window = gdk_win32_handle_table_lookup ((GdkNativeWindow) hwnd);
-	    }
-
-	  if (!grab->owner_events &&
-	      new_window != NULL &&
-	      new_window != grab->native_window)
-	    new_window = NULL;
-	}
-
-      if (mouse_window != new_window)
-	{
-	  GDK_NOTE (EVENTS, g_print (" mouse_sinwod %p -> %p",
-				     mouse_window ? GDK_WINDOW_HWND (mouse_window) : NULL, 
-				     new_window ? GDK_WINDOW_HWND (new_window) : NULL));
-	  synthesize_crossing_events (_gdk_display,
-				      mouse_window, new_window,
-				      GDK_CROSSING_NORMAL,
-				      &msg->pt,
-				      0, /* TODO: Set right mask */
-				      msg->time,
-				      FALSE);
-	  assign_object (&mouse_window, new_window);
-	  mouse_window_ignored_leave = NULL;
-	  if (new_window != NULL)
-	    track_mouse_event (TME_LEAVE, GDK_WINDOW_HWND (new_window));
-	}
-      else if (new_window != NULL && 
-	       new_window == mouse_window_ignored_leave)
-	{
-	  /* If we ignored a leave event for this window and we're now getting
-	     input again we need to re-arm the mouse tracking, as that was
-	     cancelled by the mouseleave. */
-	  mouse_window_ignored_leave = NULL;
-	  track_mouse_event (TME_LEAVE, GDK_WINDOW_HWND (new_window));
-	}
-
-      assign_object (&window, find_window_for_mouse_event (window, msg));
-
-      /* If we haven't moved, don't create any GDK event. Windows
-       * sends WM_MOUSEMOVE messages after a new window is shows under
-       * the mouse, even if the mouse hasn't moved. This disturbs gtk.
-       */
-      if (msg->pt.x + _gdk_offset_x == current_root_x &&
-	  msg->pt.y + _gdk_offset_y == current_root_y)
-	break;
-
-      current_root_x = msg->pt.x + _gdk_offset_x;
-      current_root_y = msg->pt.y + _gdk_offset_y;
-
-      event = gdk_event_new (GDK_MOTION_NOTIFY);
-      event->motion.window = window;
-      event->motion.time = _gdk_win32_get_next_tick (msg->time);
-      event->motion.x = current_x = (gint16) GET_X_LPARAM (msg->lParam);
-      event->motion.y = current_y = (gint16) GET_Y_LPARAM (msg->lParam);
-      event->motion.x_root = current_root_x;
-      event->motion.y_root = current_root_y;
-      event->motion.axes = NULL;
-      event->motion.state = build_pointer_event_state (msg);
-      event->motion.is_hint = FALSE;
-      event->motion.device = _gdk_display->core_pointer;
-
-      _gdk_win32_append_event (event);
-
-      return_val = TRUE;
-      break;
-
-    case WM_NCMOUSEMOVE:
-      GDK_NOTE (EVENTS,
-		g_print (" (%d,%d)",
-			 GET_X_LPARAM (msg->lParam), GET_Y_LPARAM (msg->lParam)));
-      break;
-
-    case WM_MOUSELEAVE:
-      GDK_NOTE (EVENTS, g_print (" %d (%ld,%ld)",
-				 HIWORD (msg->wParam), msg->pt.x, msg->pt.y));
-
-      new_window = NULL;
-      hwnd = WindowFromPoint (msg->pt);
-      ignore_leave = FALSE;
-      if (hwnd != NULL)
-	{
-	  char classname[64];
-
-	  POINT client_pt = msg->pt;
-
-	  /* The synapitics trackpad drivers have this irritating
-	     feature where it pops up a window right under the pointer
-	     when you scroll. We ignore the leave and enter events for 
-	     this window */
-	  if (GetClassNameA (hwnd, classname, sizeof(classname)) &&
-	      strcmp (classname, SYNAPSIS_ICON_WINDOW_CLASS) == 0)
-	    ignore_leave = TRUE;
-
-	  ScreenToClient (hwnd, &client_pt);
-	  GetClientRect (hwnd, &rect);
-	  if (PtInRect (&rect, client_pt))
-	    new_window = gdk_win32_handle_table_lookup ((GdkNativeWindow) hwnd);
-	}
-
-      if (!ignore_leave)
-	synthesize_crossing_events (_gdk_display,
-				    mouse_window, new_window,
-				    GDK_CROSSING_NORMAL,
-				    &msg->pt,
-				    0, /* TODO: Set right mask */
-				    msg->time,
-				    FALSE);
-      assign_object (&mouse_window, new_window);
-      mouse_window_ignored_leave = ignore_leave ? new_window : NULL;
-
-
-      return_val = TRUE;
-      break;
-
-    case WM_MOUSEWHEEL:
-    case WM_MOUSEHWHEEL:
-      GDK_NOTE (EVENTS, g_print (" %d", (short) HIWORD (msg->wParam)));
-
-      /* WM_MOUSEWHEEL is delivered to the focus window. Work around
-       * that. Also, the position is in screen coordinates, not client
-       * coordinates as with the button messages. I love the
-       * consistency of Windows.
-       */
-      point.x = GET_X_LPARAM (msg->lParam);
-      point.y = GET_Y_LPARAM (msg->lParam);
-
-      if ((hwnd = WindowFromPoint (point)) == NULL)
-	break;
-      
-      {
-	char classname[64];
-
-	/* The synapitics trackpad drivers have this irritating
-	   feature where it pops up a window right under the pointer
-	   when you scroll. We backtrack and to the toplevel and
-	   find the innermost child instead. */
-	if (GetClassNameA (hwnd, classname, sizeof(classname)) &&
-	    strcmp (classname, SYNAPSIS_ICON_WINDOW_CLASS) == 0)
-	  {
-	    HWND hwndc;
-
-	    /* Find our toplevel window */
-	    hwnd = GetAncestor (msg->hwnd, GA_ROOT);
-
-	    /* Walk back up to the outermost child at the desired point */
-	    do {
-	      ScreenToClient (hwnd, &point);
-	      hwndc = ChildWindowFromPoint (hwnd, point);
-	      ClientToScreen (hwnd, &point);
-	    } while (hwndc != hwnd && (hwnd = hwndc, 1));
-	  }
-      }
-
-      msg->hwnd = hwnd;
-      if ((new_window = gdk_win32_handle_table_lookup ((GdkNativeWindow) msg->hwnd)) == NULL)
-	break;
-
-      if (new_window != window)
-	{
-	  assign_object (&window, new_window);
-	}
-
-      ScreenToClient (msg->hwnd, &point);
-
-      event = gdk_event_new (GDK_SCROLL);
-      event->scroll.window = window;
-
-      if (msg->message == WM_MOUSEWHEEL)
-        {
-	  event->scroll.direction = (((short) HIWORD (msg->wParam)) > 0) ?
-	    GDK_SCROLL_UP : GDK_SCROLL_DOWN;
-        }
-      else if (msg->message == WM_MOUSEHWHEEL)
-        {
-	  event->scroll.direction = (((short) HIWORD (msg->wParam)) > 0) ?
-	    GDK_SCROLL_RIGHT : GDK_SCROLL_LEFT;
-        }
-      event->scroll.time = _gdk_win32_get_next_tick (msg->time);
-      event->scroll.x = (gint16) point.x;
-      event->scroll.y = (gint16) point.y;
-      event->scroll.x_root = (gint16) GET_X_LPARAM (msg->lParam) + _gdk_offset_x;
-      event->scroll.y_root = (gint16) GET_Y_LPARAM (msg->lParam) + _gdk_offset_y;
-      event->scroll.state = build_pointer_event_state (msg);
-      event->scroll.device = _gdk_display->core_pointer;
-
-      _gdk_win32_append_event (event);
-      
-      return_val = TRUE;
-      break;
-
-    case WM_HSCROLL:
-      /* Just print more debugging information, don't actually handle it. */
-      GDK_NOTE (EVENTS,
-		(g_print (" %s",
-			  (LOWORD (msg->wParam) == SB_ENDSCROLL ? "ENDSCROLL" :
-			   (LOWORD (msg->wParam) == SB_LEFT ? "LEFT" :
-			    (LOWORD (msg->wParam) == SB_RIGHT ? "RIGHT" :
-			     (LOWORD (msg->wParam) == SB_LINELEFT ? "LINELEFT" :
-			      (LOWORD (msg->wParam) == SB_LINERIGHT ? "LINERIGHT" :
-			       (LOWORD (msg->wParam) == SB_PAGELEFT ? "PAGELEFT" :
-				(LOWORD (msg->wParam) == SB_PAGERIGHT ? "PAGERIGHT" :
-				 (LOWORD (msg->wParam) == SB_THUMBPOSITION ? "THUMBPOSITION" :
-				  (LOWORD (msg->wParam) == SB_THUMBTRACK ? "THUMBTRACK" :
-				   "???")))))))))),
-		 (LOWORD (msg->wParam) == SB_THUMBPOSITION ||
-		  LOWORD (msg->wParam) == SB_THUMBTRACK) ?
-		 (g_print (" %d", HIWORD (msg->wParam)), 0) : 0));
-      break;
-
-    case WM_VSCROLL:
-      /* Just print more debugging information, don't actually handle it. */
-      GDK_NOTE (EVENTS,
-		(g_print (" %s",
-			  (LOWORD (msg->wParam) == SB_ENDSCROLL ? "ENDSCROLL" :
-			   (LOWORD (msg->wParam) == SB_BOTTOM ? "BOTTOM" :
-			    (LOWORD (msg->wParam) == SB_TOP ? "TOP" :
-			     (LOWORD (msg->wParam) == SB_LINEDOWN ? "LINDOWN" :
-			      (LOWORD (msg->wParam) == SB_LINEUP ? "LINEUP" :
-			       (LOWORD (msg->wParam) == SB_PAGEDOWN ? "PAGEDOWN" :
-				(LOWORD (msg->wParam) == SB_PAGEUP ? "PAGEUP" :
-				 (LOWORD (msg->wParam) == SB_THUMBPOSITION ? "THUMBPOSITION" :
-				  (LOWORD (msg->wParam) == SB_THUMBTRACK ? "THUMBTRACK" :
-				   "???")))))))))),
-		 (LOWORD (msg->wParam) == SB_THUMBPOSITION ||
-		  LOWORD (msg->wParam) == SB_THUMBTRACK) ?
-		 (g_print (" %d", HIWORD (msg->wParam)), 0) : 0));
-      break;
-
-    case WM_QUERYNEWPALETTE:
-      if (gdk_visual_get_system ()->type == GDK_VISUAL_PSEUDO_COLOR)
-	{
-	  synthesize_expose_events (window);
-	  update_colors_counter = 0;
-	}
-      return_val = TRUE;
-      break;
-
-    case WM_PALETTECHANGED:
-      GDK_NOTE (EVENTS_OR_COLORMAP, g_print (" %p", (HWND) msg->wParam));
-      if (gdk_visual_get_system ()->type != GDK_VISUAL_PSEUDO_COLOR)
-	break;
-
-      return_val = TRUE;
-
-      if (msg->hwnd == (HWND) msg->wParam)
-	break;
-
-      if (++update_colors_counter == 5)
-	{
-	  synthesize_expose_events (window);
-	  update_colors_counter = 0;
-	  break;
-	}
-      
-      update_colors (window, TRUE);
-      break;
-
-     case WM_MOUSEACTIVATE:
-       {
-	 if (gdk_window_get_window_type (window) == GDK_WINDOW_TEMP 
-	     || !((GdkWindowObject *)window)->accept_focus)
-	   {
-	     *ret_valp = MA_NOACTIVATE;
-	     return_val = TRUE;
-	   }
-
-	 if (_gdk_modal_blocked (gdk_window_get_toplevel (window)))
-	   {
-	     *ret_valp = MA_NOACTIVATEANDEAT;
-	     return_val = TRUE;
-	   }
-       }
-
-       break;
-
-    case WM_KILLFOCUS:
-      if (_gdk_display->keyboard_grab.window != NULL &&
-	  !GDK_WINDOW_DESTROYED (_gdk_display->keyboard_grab.window))
-	{
-	  generate_grab_broken_event (_gdk_display->keyboard_grab.window, TRUE, NULL);
-	}
-
-      /* fallthrough */
-    case WM_SETFOCUS:
-      if (_gdk_display->keyboard_grab.window != NULL &&
-	  !_gdk_display->keyboard_grab.owner_events)
-	break;
-
-      if (!(((GdkWindowObject *) window)->event_mask & GDK_FOCUS_CHANGE_MASK))
-	break;
-
-      if (GDK_WINDOW_DESTROYED (window))
-	break;
-
-      generate_focus_event (window, (msg->message == WM_SETFOCUS));
-      return_val = TRUE;
-      break;
-
-    case WM_ERASEBKGND:
-      GDK_NOTE (EVENTS, g_print (" %p", (HANDLE) msg->wParam));
-      
-      if (GDK_WINDOW_DESTROYED (window))
-	break;
-
-      return_val = TRUE;
-      *ret_valp = 1;
-      break;
-
-    case WM_SYNCPAINT:
-      sync_timer = SetTimer (GDK_WINDOW_HWND (window),
-			     1,
-			     200, sync_timer_proc);
-      break;
-
-    case WM_PAINT:
-      handle_wm_paint (msg, window, FALSE, NULL);
-      break;
-
-    case WM_SETCURSOR:
-      GDK_NOTE (EVENTS, g_print (" %#x %#x",
-				 LOWORD (msg->lParam), HIWORD (msg->lParam)));
-
-      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
-      if (grab != NULL)
-	{
-	  grab_window = grab->window;
-	}
-
-      if (grab_window == NULL && LOWORD (msg->lParam) != HTCLIENT)
-	break;
-
-      if (grab_window != NULL && p_grab_cursor != NULL)
-	hcursor = p_grab_cursor;
-      else if (!GDK_WINDOW_DESTROYED (window))
-	hcursor = GDK_WINDOW_IMPL_WIN32 (((GdkWindowObject *) window)->impl)->hcursor;
-      else
-	hcursor = NULL;
-
-      if (hcursor != NULL)
-	{
-	  GDK_NOTE (EVENTS, g_print (" (SetCursor(%p)", hcursor));
-	  SetCursor (hcursor);
-	  return_val = TRUE;
-	  *ret_valp = TRUE;
-	}
-      break;
-
-    case WM_SYSCOMMAND:
-      switch (msg->wParam)
-	{
-	case SC_MINIMIZE:
-	case SC_RESTORE:
-	  do_show_window (window, msg->wParam == SC_MINIMIZE ? TRUE : FALSE);
-	  break;
-	}
-
-      break;
-
-    case WM_ENTERSIZEMOVE:
-    case WM_ENTERMENULOOP:
-      if (msg->message == WM_ENTERSIZEMOVE)
-	_modal_move_resize_window = msg->hwnd;
-
-      _gdk_win32_begin_modal_call ();
-      break;
-
-    case WM_EXITSIZEMOVE:
-    case WM_EXITMENULOOP:
-      if (_modal_operation_in_progress)
-	{
-	  _modal_move_resize_window = NULL;
-	  _gdk_win32_end_modal_call ();
-	}
-      break;
-
-    case WM_CAPTURECHANGED:
-      /* Sometimes we don't get WM_EXITSIZEMOVE, for instance when you
-	 select move/size in the menu and then click somewhere without
-	 moving/resizing. We work around this using WM_CAPTURECHANGED. */
-      if (_modal_operation_in_progress)
-	{
-	  _modal_move_resize_window = NULL;
-	  _gdk_win32_end_modal_call ();
-	}
-      break;
-
-    case WM_WINDOWPOSCHANGING:
-      GDK_NOTE (EVENTS, (windowpos = (WINDOWPOS *) msg->lParam,
-			 g_print (" %s %s %dx%d@%+d%+d now below %p",
-				  _gdk_win32_window_pos_bits_to_string (windowpos->flags),
-				  (windowpos->hwndInsertAfter == HWND_BOTTOM ? "BOTTOM" :
-				   (windowpos->hwndInsertAfter == HWND_NOTOPMOST ? "NOTOPMOST" :
-				    (windowpos->hwndInsertAfter == HWND_TOP ? "TOP" :
-				     (windowpos->hwndInsertAfter == HWND_TOPMOST ? "TOPMOST" :
-				      (sprintf (buf, "%p", windowpos->hwndInsertAfter),
-				       buf))))),
-				  windowpos->cx, windowpos->cy, windowpos->x, windowpos->y,
-				  GetNextWindow (msg->hwnd, GW_HWNDPREV))));
-
-      if (GDK_WINDOW_IS_MAPPED (window))
-	return_val = ensure_stacking_on_window_pos_changing (msg, window);
-      break;
-
-    case WM_WINDOWPOSCHANGED:
-      windowpos = (WINDOWPOS *) msg->lParam;
-      GDK_NOTE (EVENTS, g_print (" %s %s %dx%d@%+d%+d",
-				 _gdk_win32_window_pos_bits_to_string (windowpos->flags),
-				 (windowpos->hwndInsertAfter == HWND_BOTTOM ? "BOTTOM" :
-				  (windowpos->hwndInsertAfter == HWND_NOTOPMOST ? "NOTOPMOST" :
-				   (windowpos->hwndInsertAfter == HWND_TOP ? "TOP" :
-				    (windowpos->hwndInsertAfter == HWND_TOPMOST ? "TOPMOST" :
-				     (sprintf (buf, "%p", windowpos->hwndInsertAfter),
-				      buf))))),
-				 windowpos->cx, windowpos->cy, windowpos->x, windowpos->y));
-
-      /* Break grabs on unmap or minimize */
-      if (windowpos->flags & SWP_HIDEWINDOW || 
-	  ((windowpos->flags & SWP_STATECHANGED) && IsIconic (msg->hwnd)))
-	{
-	  grab = _gdk_display_get_last_pointer_grab (_gdk_display);
-	  if (grab != NULL)
-	    {
-	      if (grab->window == window)
-		gdk_pointer_ungrab (msg->time);
-	    }
-
-	  if (_gdk_display->keyboard_grab.window == window)
-	    gdk_keyboard_ungrab (msg->time);
-	}
-
-      /* Send MAP events  */
-      if ((windowpos->flags & SWP_SHOWWINDOW) &&
-	  !GDK_WINDOW_DESTROYED (window))
-	{
-	  event = gdk_event_new (GDK_MAP);
-	  event->any.window = window;
-	  _gdk_win32_append_event (event);
-	}
-
-      /* Update window state */
-      if (windowpos->flags & (SWP_STATECHANGED | SWP_SHOWWINDOW | SWP_HIDEWINDOW))
-	{
-	  GdkWindowState set_bits, unset_bits, old_state, new_state;
-
-	  old_state = GDK_WINDOW_OBJECT (window)->state;
-
-	  set_bits = 0;
-	  unset_bits = 0;
-
-	  if (IsWindowVisible (msg->hwnd))
-	    unset_bits |= GDK_WINDOW_STATE_WITHDRAWN;
-	  else
-	    set_bits |= GDK_WINDOW_STATE_WITHDRAWN;
-
-	  if (IsIconic (msg->hwnd))
-	    set_bits |= GDK_WINDOW_STATE_ICONIFIED;
-	  else
-	    unset_bits |= GDK_WINDOW_STATE_ICONIFIED;
-
-	  if (IsZoomed (msg->hwnd))
-	    set_bits |= GDK_WINDOW_STATE_MAXIMIZED;
-	  else
-	    unset_bits |= GDK_WINDOW_STATE_MAXIMIZED;
-
-	  gdk_synthesize_window_state (window, unset_bits, set_bits);
-
-	  new_state = GDK_WINDOW_OBJECT (window)->state;
-
-	  /* Whenever one window changes iconified state we need to also
-	   * change the iconified state in all transient related windows,
-	   * as windows doesn't give icons for transient childrens. 
-	   */
-	  if ((old_state & GDK_WINDOW_STATE_ICONIFIED) != 
-	      (new_state & GDK_WINDOW_STATE_ICONIFIED))
-	    do_show_window (window, (new_state & GDK_WINDOW_STATE_ICONIFIED));
-
-
-	  /* When un-minimizing, make sure we're stacked under any 
-	     transient-type windows. */
-	  if (!(old_state & GDK_WINDOW_STATE_ICONIFIED) &&
-	      (new_state & GDK_WINDOW_STATE_ICONIFIED))
-	    ensure_stacking_on_unminimize (msg);
-	}
-
-      /* Show, New size or position => configure event */
-      if (!(windowpos->flags & SWP_NOCLIENTMOVE) ||
-	  !(windowpos->flags & SWP_NOCLIENTSIZE) ||
-	  (windowpos->flags & SWP_SHOWWINDOW))
-	{
-	  if (GDK_WINDOW_TYPE (window) != GDK_WINDOW_CHILD &&
-	      !IsIconic (msg->hwnd) &&
-	      !GDK_WINDOW_DESTROYED (window))
-	    _gdk_win32_emit_configure_event (window);
-
-	  if (((GdkWindowObject *) window)->input_window != NULL)
-	    _gdk_input_configure_event (window);
-	}
-
-      if ((windowpos->flags & SWP_HIDEWINDOW) &&
-	  !GDK_WINDOW_DESTROYED (window))
-	{
-	  /* Send UNMAP events  */
-	  event = gdk_event_new (GDK_UNMAP);
-	  event->any.window = window;
-	  _gdk_win32_append_event (event);
-
-	  /* Make transient parent the forground window when window unmaps */
-	  impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-	  if (impl->transient_owner && 
-	      GetForegroundWindow () == GDK_WINDOW_HWND (window))
-	    SetForegroundWindow (GDK_WINDOW_HWND (impl->transient_owner));
-	}
-
-      if (!(windowpos->flags & SWP_NOCLIENTSIZE))
-	{
-	  if (((GdkWindowObject *) window)->resize_count > 1)
-	    ((GdkWindowObject *) window)->resize_count -= 1;
-	}
-
-      /* Call modal timer immediate so that we repaint faster after a resize. */
-      if (_modal_operation_in_progress)
-	modal_timer_proc (0,0,0,0);
-
-      /* Claim as handled, so that WM_SIZE and WM_MOVE are avoided */
-      return_val = TRUE;
-      *ret_valp = 0;
-      break;
-
-    case WM_SIZING:
-      GetWindowRect (GDK_WINDOW_HWND (window), &rect);
-      drag = (RECT *) msg->lParam;
-      GDK_NOTE (EVENTS, g_print (" %s curr:%s drag:%s",
-				 (msg->wParam == WMSZ_BOTTOM ? "BOTTOM" :
-				  (msg->wParam == WMSZ_BOTTOMLEFT ? "BOTTOMLEFT" :
-				   (msg->wParam == WMSZ_LEFT ? "LEFT" :
-				    (msg->wParam == WMSZ_TOPLEFT ? "TOPLEFT" :
-				     (msg->wParam == WMSZ_TOP ? "TOP" :
-				      (msg->wParam == WMSZ_TOPRIGHT ? "TOPRIGHT" :
-				       (msg->wParam == WMSZ_RIGHT ? "RIGHT" :
-					
-					(msg->wParam == WMSZ_BOTTOMRIGHT ? "BOTTOMRIGHT" :
-					 "???")))))))),
-				 _gdk_win32_rect_to_string (&rect),
-				 _gdk_win32_rect_to_string (drag)));
-
-      impl = GDK_WINDOW_IMPL_WIN32 (((GdkWindowObject *) window)->impl);
-      orig_drag = *drag;
-      if (impl->hint_flags & GDK_HINT_RESIZE_INC)
-	{
-	  GDK_NOTE (EVENTS, g_print (" (RESIZE_INC)"));
-	  if (impl->hint_flags & GDK_HINT_BASE_SIZE)
-	    {
-	      /* Resize in increments relative to the base size */
-	      rect.left = rect.top = 0;
-	      rect.right = impl->hints.base_width;
-	      rect.bottom = impl->hints.base_height;
-	      _gdk_win32_adjust_client_rect (window, &rect);
-	      point.x = rect.left;
-	      point.y = rect.top;
-	      ClientToScreen (GDK_WINDOW_HWND (window), &point);
-	      rect.left = point.x;
-	      rect.top = point.y;
-	      point.x = rect.right;
-	      point.y = rect.bottom;
-	      ClientToScreen (GDK_WINDOW_HWND (window), &point);
-	      rect.right = point.x;
-	      rect.bottom = point.y;
-	      
-	      GDK_NOTE (EVENTS, g_print (" (also BASE_SIZE, using %s)",
-					 _gdk_win32_rect_to_string (&rect)));
-	    }
-
-	  switch (msg->wParam)
-	    {
-	    case WMSZ_BOTTOM:
-	      if (drag->bottom == rect.bottom)
-		break;
-	      adjust_drag (&drag->bottom, rect.bottom, impl->hints.height_inc);
-	      break;
-
-	    case WMSZ_BOTTOMLEFT:
-	      if (drag->bottom == rect.bottom && drag->left == rect.left)
-		break;
-	      adjust_drag (&drag->bottom, rect.bottom, impl->hints.height_inc);
-	      adjust_drag (&drag->left, rect.left, impl->hints.width_inc);
-	      break;
-
-	    case WMSZ_LEFT:
-	      if (drag->left == rect.left)
-		break;
-	      adjust_drag (&drag->left, rect.left, impl->hints.width_inc);
-	      break;
-
-	    case WMSZ_TOPLEFT:
-	      if (drag->top == rect.top && drag->left == rect.left)
-		break;
-	      adjust_drag (&drag->top, rect.top, impl->hints.height_inc);
-	      adjust_drag (&drag->left, rect.left, impl->hints.width_inc);
-	      break;
-
-	    case WMSZ_TOP:
-	      if (drag->top == rect.top)
-		break;
-	      adjust_drag (&drag->top, rect.top, impl->hints.height_inc);
-	      break;
-
-	    case WMSZ_TOPRIGHT:
-	      if (drag->top == rect.top && drag->right == rect.right)
-		break;
-	      adjust_drag (&drag->top, rect.top, impl->hints.height_inc);
-	      adjust_drag (&drag->right, rect.right, impl->hints.width_inc);
-	      break;
-
-	    case WMSZ_RIGHT:
-	      if (drag->right == rect.right)
-		break;
-	      adjust_drag (&drag->right, rect.right, impl->hints.width_inc);
-	      break;
-
-	    case WMSZ_BOTTOMRIGHT:
-	      if (drag->bottom == rect.bottom && drag->right == rect.right)
-		break;
-	      adjust_drag (&drag->bottom, rect.bottom, impl->hints.height_inc);
-	      adjust_drag (&drag->right, rect.right, impl->hints.width_inc);
-	      break;
-	    }
-
-	  if (drag->bottom != orig_drag.bottom || drag->left != orig_drag.left ||
-	      drag->top != orig_drag.top || drag->right != orig_drag.right)
-	    {
-	      *ret_valp = TRUE;
-	      return_val = TRUE;
-	      GDK_NOTE (EVENTS, g_print (" (handled RESIZE_INC: %s)",
-					 _gdk_win32_rect_to_string (drag)));
-	    }
-	}
-
-      /* WM_GETMINMAXINFO handles min_size and max_size hints? */
-
-      if (impl->hint_flags & GDK_HINT_ASPECT)
-	{
-	  RECT decorated_rect;
-	  RECT undecorated_drag;
-	  int decoration_width, decoration_height;
-	  gdouble drag_aspect;
-	  int drag_width, drag_height, new_width, new_height;
-
-	  GetClientRect (GDK_WINDOW_HWND (window), &rect);
-	  decorated_rect = rect;
-	  _gdk_win32_adjust_client_rect (window, &decorated_rect);
-
-	  /* Set undecorated_drag to the client area being dragged
-	   * out, in screen coordinates.
-	   */
-	  undecorated_drag = *drag;
-	  undecorated_drag.left -= decorated_rect.left - rect.left;
-	  undecorated_drag.right -= decorated_rect.right - rect.right;
-	  undecorated_drag.top -= decorated_rect.top - rect.top;
-	  undecorated_drag.bottom -= decorated_rect.bottom - rect.bottom;
-
-	  decoration_width = (decorated_rect.right - decorated_rect.left) - (rect.right - rect.left);
-	  decoration_height = (decorated_rect.bottom - decorated_rect.top) - (rect.bottom - rect.top);
-
-	  drag_width = undecorated_drag.right - undecorated_drag.left;
-	  drag_height = undecorated_drag.bottom - undecorated_drag.top;
-
-	  drag_aspect = (gdouble) drag_width / drag_height;
-
-	  GDK_NOTE (EVENTS, g_print (" (ASPECT:%g--%g curr: %g)",
-				     impl->hints.min_aspect, impl->hints.max_aspect, drag_aspect));
-
-	  if (drag_aspect < impl->hints.min_aspect)
-	    {
-	      /* Aspect is getting too narrow */
-	      switch (msg->wParam)
-		{
-		case WMSZ_BOTTOM:
-		case WMSZ_TOP:
-		  /* User drags top or bottom edge outward. Keep height, increase width. */
-		  new_width = impl->hints.min_aspect * drag_height;
-		  drag->left -= (new_width - drag_width) / 2;
-		  drag->right = drag->left + new_width + decoration_width;
-		  break;
-		case WMSZ_BOTTOMLEFT:
-		case WMSZ_BOTTOMRIGHT:
-		  /* User drags bottom-left or bottom-right corner down. Adjust height. */
-		  new_height = drag_width / impl->hints.min_aspect;
-		  drag->bottom = drag->top + new_height + decoration_height;
-		  break;
-		case WMSZ_LEFT:
-		case WMSZ_RIGHT:
-		  /* User drags left or right edge inward. Decrease height */
-		  new_height = drag_width / impl->hints.min_aspect;
-		  drag->top += (drag_height - new_height) / 2;
-		  drag->bottom = drag->top + new_height + decoration_height;
-		  break;
-		case WMSZ_TOPLEFT:
-		case WMSZ_TOPRIGHT:
-		  /* User drags top-left or top-right corner up. Adjust height. */
-		  new_height = drag_width / impl->hints.min_aspect;
-		  drag->top = drag->bottom - new_height - decoration_height;
-		}
-	    }
-	  else if (drag_aspect > impl->hints.max_aspect)
-	    {
-	      /* Aspect is getting too wide */
-	      switch (msg->wParam)
-		{
-		case WMSZ_BOTTOM:
-		case WMSZ_TOP:
-		  /* User drags top or bottom edge inward. Decrease width. */
-		  new_width = impl->hints.max_aspect * drag_height;
-		  drag->left += (drag_width - new_width) / 2;
-		  drag->right = drag->left + new_width + decoration_width;
-		  break;
-		case WMSZ_BOTTOMLEFT:
-		case WMSZ_TOPLEFT:
-		  /* User drags bottom-left or top-left corner left. Adjust width. */
-		  new_width = impl->hints.max_aspect * drag_height;
-		  drag->left = drag->right - new_width - decoration_width;
-		  break;
-		case WMSZ_BOTTOMRIGHT:
-		case WMSZ_TOPRIGHT:
-		  /* User drags bottom-right or top-right corner right. Adjust width. */
-		  new_width = impl->hints.max_aspect * drag_height;
-		  drag->right = drag->left + new_width + decoration_width;
-		  break;
-		case WMSZ_LEFT:
-		case WMSZ_RIGHT:
-		  /* User drags left or right edge outward. Increase height. */
-		  new_height = drag_width / impl->hints.max_aspect;
-		  drag->top -= (new_height - drag_height) / 2;
-		  drag->bottom = drag->top + new_height + decoration_height;
-		  break;
-		}
-	    }
-
-	  *ret_valp = TRUE;
-	  return_val = TRUE;
-	  GDK_NOTE (EVENTS, g_print (" (handled ASPECT: %s)",
-				     _gdk_win32_rect_to_string (drag)));
-	}
-      break;
-
-    case WM_GETMINMAXINFO:
-      if (GDK_WINDOW_DESTROYED (window))
-	break;
-
-      impl = GDK_WINDOW_IMPL_WIN32 (((GdkWindowObject *) window)->impl);
-      mmi = (MINMAXINFO*) msg->lParam;
-      GDK_NOTE (EVENTS, g_print (" (mintrack:%ldx%ld maxtrack:%ldx%ld "
-				 "maxpos:%+ld%+ld maxsize:%ldx%ld)",
-				 mmi->ptMinTrackSize.x, mmi->ptMinTrackSize.y,
-				 mmi->ptMaxTrackSize.x, mmi->ptMaxTrackSize.y,
-				 mmi->ptMaxPosition.x, mmi->ptMaxPosition.y,
-				 mmi->ptMaxSize.x, mmi->ptMaxSize.y));
-
-      if (impl->hint_flags & GDK_HINT_MIN_SIZE)
-	{
-	  rect.left = rect.top = 0;
-	  rect.right = impl->hints.min_width;
-	  rect.bottom = impl->hints.min_height;
-
-	  _gdk_win32_adjust_client_rect (window, &rect);
-
-	  mmi->ptMinTrackSize.x = rect.right - rect.left;
-	  mmi->ptMinTrackSize.y = rect.bottom - rect.top;
-	}
-
-      if (impl->hint_flags & GDK_HINT_MAX_SIZE)
-	{
-	  int maxw, maxh;
-
-	  rect.left = rect.top = 0;
-	  rect.right = impl->hints.max_width;
-	  rect.bottom = impl->hints.max_height;
-
-	  _gdk_win32_adjust_client_rect (window, &rect);
-
-	  /* at least on win9x we have the 16 bit trouble */
-	  maxw = rect.right - rect.left;
-	  maxh = rect.bottom - rect.top;
-	  mmi->ptMaxTrackSize.x = maxw > 0 && maxw < G_MAXSHORT ? maxw : G_MAXSHORT;
-	  mmi->ptMaxTrackSize.y = maxh > 0 && maxh < G_MAXSHORT ? maxh : G_MAXSHORT;
-	}
-      else
-	{
-	  mmi->ptMaxTrackSize.x = 30000;
-	  mmi->ptMaxTrackSize.y = 30000;
-	}
-
-      if (impl->hint_flags & (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE))
-	{
-	  /* Don't call DefWindowProcW() */
-	  GDK_NOTE (EVENTS, g_print (" (handled, mintrack:%ldx%ld maxtrack:%ldx%ld "
-				     "maxpos:%+ld%+ld maxsize:%ldx%ld)",
-				     mmi->ptMinTrackSize.x, mmi->ptMinTrackSize.y,
-				     mmi->ptMaxTrackSize.x, mmi->ptMaxTrackSize.y,
-				     mmi->ptMaxPosition.x, mmi->ptMaxPosition.y,
-				     mmi->ptMaxSize.x, mmi->ptMaxSize.y));
-	  return_val = TRUE;
-	}
-
-      return_val = TRUE;
-      break;
-
-    case WM_CLOSE:
-      if (GDK_WINDOW_DESTROYED (window))
-	break;
-
-      event = gdk_event_new (GDK_DELETE);
-      event->any.window = window;
-
-      _gdk_win32_append_event (event);
-
-      impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-      if (impl->transient_owner && GetForegroundWindow() == GDK_WINDOW_HWND (window))
-	{
-	  SetForegroundWindow (GDK_WINDOW_HWND (impl->transient_owner));
-	}
-
-      return_val = TRUE;
-      break;
-
-    case WM_NCDESTROY:
-      grab = _gdk_display_get_last_pointer_grab (_gdk_display);
-      if (grab != NULL)
-	{
-	  if (grab->window == window)
-	    gdk_pointer_ungrab (msg->time);
-	}
-
-      if (_gdk_display->keyboard_grab.window == window)
-	gdk_keyboard_ungrab (msg->time);
-
-      if ((window != NULL) && (msg->hwnd != GetDesktopWindow ()))
-	gdk_window_destroy_notify (window);
-
-      if (window == NULL || GDK_WINDOW_DESTROYED (window))
-	break;
-
-      event = gdk_event_new (GDK_DESTROY);
-      event->any.window = window;
-
-      _gdk_win32_append_event (event);
-
-      return_val = TRUE;
-      break;
-
-    case WM_DISPLAYCHANGE:
-      handle_display_change ();
-      break;
-      
-    case WM_DESTROYCLIPBOARD:
-      if (!_ignore_destroy_clipboard)
-	{
-	  event = gdk_event_new (GDK_SELECTION_CLEAR);
-	  event->selection.window = window;
-	  event->selection.selection = GDK_SELECTION_CLIPBOARD;
-	  event->selection.time = _gdk_win32_get_next_tick (msg->time);
-          _gdk_win32_append_event (event);
-	}
-      else
-	{
-	  return_val = TRUE;
-	}
-
-      break;
-
-    case WM_RENDERFORMAT:
-      GDK_NOTE (EVENTS, g_print (" %s", _gdk_win32_cf_to_string (msg->wParam)));
-
-      if (!(target = g_hash_table_lookup (_format_atom_table, GINT_TO_POINTER (msg->wParam))))
-	{
-	  GDK_NOTE (EVENTS, g_print (" (target not found)"));
-	  return_val = TRUE;
-	  break;
-	}
-
-      /* We need to render to clipboard immediately, don't call
-       * _gdk_win32_append_event()
-       */
-      if (_gdk_event_func)
-	{
-	  event = gdk_event_new (GDK_SELECTION_REQUEST);
-	  event->selection.window = window;
-	  event->selection.send_event = FALSE;
-	  event->selection.selection = GDK_SELECTION_CLIPBOARD;
-	  event->selection.target = target;
-	  event->selection.property = _gdk_selection;
-	  event->selection.requestor = msg->hwnd;
-	  event->selection.time = msg->time;
-
-	  fixup_event (event);
-	  GDK_NOTE (EVENTS, g_print (" (calling gdk_event_func)"));
-	  GDK_NOTE (EVENTS, _gdk_win32_print_event (event));
-	  (*_gdk_event_func) (event, _gdk_event_data);
-	  gdk_event_free (event);
-
-	  /* Now the clipboard owner should have rendered */
-	  if (!_delayed_rendering_data)
-	    {
-	      GDK_NOTE (EVENTS, g_print (" (no _delayed_rendering_data?)"));
-	    }
-	  else
-	    {
-	      if (msg->wParam == CF_DIB)
-		{
-		  _delayed_rendering_data =
-		    _gdk_win32_selection_convert_to_dib (_delayed_rendering_data,
-							 target);
-		  if (!_delayed_rendering_data)
-		    {
-		      g_warning ("Cannot convert to DIB from delayed rendered image");
-		      break;
-		    }
-		}
-
-	      /* The requestor is holding the clipboard, no
-	       * OpenClipboard() is required/possible
-	       */
-	      GDK_NOTE (DND,
-			g_print (" SetClipboardData(%s,%p)",
-				 _gdk_win32_cf_to_string (msg->wParam),
-				 _delayed_rendering_data));
-
-	      API_CALL (SetClipboardData, (msg->wParam, _delayed_rendering_data));
-	      _delayed_rendering_data = NULL;
-	    }
-	}
-      break;
-
-    case WM_ACTIVATE:
-      GDK_NOTE (EVENTS, g_print (" %s%s %p",
-				 (LOWORD (msg->wParam) == WA_ACTIVE ? "ACTIVE" :
-				  (LOWORD (msg->wParam) == WA_CLICKACTIVE ? "CLICKACTIVE" :
-				   (LOWORD (msg->wParam) == WA_INACTIVE ? "INACTIVE" : "???"))),
-				 HIWORD (msg->wParam) ? " minimized" : "",
-				 (HWND) msg->lParam));
-      /* We handle mouse clicks for modally-blocked windows under WM_MOUSEACTIVATE,
-       * but we still need to deal with alt-tab, or with SetActiveWindow() type
-       * situations.
-       */
-      if (_gdk_modal_blocked (window) && LOWORD (msg->wParam) == WA_ACTIVE)
-	{
-	  GdkWindow *modal_current = _gdk_modal_current ();
-	  SetActiveWindow (GDK_WINDOW_HWND (modal_current));
-	  *ret_valp = 0;
-	  return_val = TRUE;
-	  break;
-	}
-
-      /* Bring any tablet contexts to the top of the overlap order when
-       * one of our windows is activated.
-       * NOTE: It doesn't seem to work well if it is done in WM_ACTIVATEAPP
-       * instead
-       */
-      if (LOWORD(msg->wParam) != WA_INACTIVE)
-	_gdk_input_set_tablet_active ();
-      break;
-
-    case WM_ACTIVATEAPP:
-      GDK_NOTE (EVENTS, g_print (" %s thread: %I64d",
-				 msg->wParam ? "YES" : "NO",
-				 (gint64) msg->lParam));
-      if (msg->wParam && GDK_WINDOW_IS_MAPPED (window))
-	ensure_stacking_on_activate_app (msg, window);
-      break;
-
-      /* Handle WINTAB events here, as we know that gdkinput.c will
-       * use the fixed WT_DEFBASE as lcMsgBase, and we thus can use the
-       * constants as case labels.
-       */
-    case WT_PACKET:
-      GDK_NOTE (EVENTS, g_print (" %d %p",
-				 (int) msg->wParam, (gpointer) msg->lParam));
-      goto wintab;
-      
-    case WT_CSRCHANGE:
-      GDK_NOTE (EVENTS, g_print (" %d %p",
-				 (int) msg->wParam, (gpointer) msg->lParam));
-      goto wintab;
-      
-    case WT_PROXIMITY:
-      GDK_NOTE (EVENTS, g_print (" %p %d %d",
-				 (gpointer) msg->wParam,
-				 LOWORD (msg->lParam),
-				 HIWORD (msg->lParam)));
-      /* Fall through */
-    wintab:
-
-      event = gdk_event_new (GDK_NOTHING);
-      event->any.window = NULL;
-
-      if (_gdk_input_other_event (event, msg, window))
-	_gdk_win32_append_event (event);
-      else
-	gdk_event_free (event);
-
-      break;
-    }
-
-done:
-
-  if (window)
-    g_object_unref (window);
-  
-#undef return
-  return return_val;
-}
-
-void
-_gdk_events_queue (GdkDisplay *display)
-{
-  MSG msg;
-
-  if (modal_win32_dialog != NULL)
-    return;
-  
-  while (PeekMessageW (&msg, NULL, 0, 0, PM_REMOVE))
-    {
-      TranslateMessage (&msg);
-      DispatchMessageW (&msg);
-    }
-}
-
-static gboolean
-gdk_event_prepare (GSource *source,
-		   gint    *timeout)
-{
-  gboolean retval;
-
-  GDK_THREADS_ENTER ();
-
-  *timeout = -1;
-
-  retval = (_gdk_event_queue_find_first (_gdk_display) != NULL ||
-	    (modal_win32_dialog == NULL &&
-	     GetQueueStatus (QS_ALLINPUT) != 0));
-
-  GDK_THREADS_LEAVE ();
-
-  return retval;
-}
-
-static gboolean
-gdk_event_check (GSource *source)
-{
-  gboolean retval;
-  
-  GDK_THREADS_ENTER ();
-
-  if (event_poll_fd.revents & G_IO_IN)
-    {
-      retval = (_gdk_event_queue_find_first (_gdk_display) != NULL ||
-		(modal_win32_dialog == NULL &&
-		 GetQueueStatus (QS_ALLINPUT) != 0));
-    }
-  else
-    {
-      retval = FALSE;
-    }
-
-  GDK_THREADS_LEAVE ();
-
-  return retval;
-}
-
-static gboolean
-gdk_event_dispatch (GSource     *source,
-		    GSourceFunc  callback,
-		    gpointer     user_data)
-{
-  GdkEvent *event;
- 
-  GDK_THREADS_ENTER ();
-
-  _gdk_events_queue (_gdk_display);
-  event = _gdk_event_unqueue (_gdk_display);
-
-  if (event)
-    {
-      if (_gdk_event_func)
-	(*_gdk_event_func) (event, _gdk_event_data);
-      
-      gdk_event_free (event);
-
-      /* Do drag & drop if it is still pending */
-      if (_dnd_source_state == GDK_WIN32_DND_PENDING) 
-	{
-	  _dnd_source_state = GDK_WIN32_DND_DRAGGING;
-	  _gdk_win32_dnd_do_dragdrop ();
-	  _dnd_source_state = GDK_WIN32_DND_NONE;
-	}
-    }
-  
-  GDK_THREADS_LEAVE ();
-
-  return TRUE;
-}
-
-void
-gdk_win32_set_modal_dialog_libgtk_only (HWND window)
-{
-  modal_win32_dialog = window;
-}
-
-static void
-check_for_too_much_data (GdkEvent *event)
-{
-  if (event->client.data.l[1] ||
-      event->client.data.l[2] ||
-      event->client.data.l[3] ||
-      event->client.data.l[4])
-    {
-      g_warning ("Only four bytes of data are passed in client messages on Win32\n");
-    }
-}
-
-gboolean
-gdk_event_send_client_message_for_display (GdkDisplay     *display,
-                                           GdkEvent       *event, 
-                                           GdkNativeWindow winid)
-{
-  check_for_too_much_data (event);
-
-  return PostMessageW ((HWND) winid, client_message,
-		       (WPARAM) event->client.message_type,
-		       event->client.data.l[0]);
-}
-
-void
-gdk_screen_broadcast_client_message (GdkScreen *screen, 
-				     GdkEvent  *event)
-{
-  check_for_too_much_data (event);
-
-  PostMessageW (HWND_BROADCAST, client_message,
-	       (WPARAM) event->client.message_type,
-		event->client.data.l[0]);
-}
-
-void
-gdk_flush (void)
-{
-  gdk_display_sync (_gdk_display);
-}
-
-void
-gdk_display_sync (GdkDisplay * display)
-{
-  g_return_if_fail (display == _gdk_display);
-
-  GdiFlush ();
-}
-
-void
-gdk_display_flush (GdkDisplay * display)
-{
-  g_return_if_fail (display == _gdk_display);
-
-  GdiFlush ();
-}
-
-gboolean
-gdk_net_wm_supports (GdkAtom property)
-{
-  return FALSE;
-}
-
-void
-_gdk_windowing_event_data_copy (const GdkEvent *src,
-                                GdkEvent       *dst)
-{
-}
-
-void
-_gdk_windowing_event_data_free (GdkEvent *event)
-{
-}
diff --git a/gdk/win32/gdkfont-win32.c b/gdk/win32/gdkfont-win32.c
deleted file mode 100644
index 9b81ce5..0000000
--- a/gdk/win32/gdkfont-win32.c
+++ /dev/null
@@ -1,1722 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <ctype.h>
-
-#include "gdkfont.h"
-#include "gdkpango.h" /* gdk_pango_context_get() */
-#include "gdkdisplay.h"
-#include "gdkprivate-win32.h"
-
-static GHashTable *font_name_hash = NULL;
-static GHashTable *fontset_name_hash = NULL;
-
-static void
-gdk_font_hash_insert (GdkFontType  type,
-		      GdkFont     *font,
-		      const gchar *font_name)
-{
-  GdkFontPrivateWin32 *private = (GdkFontPrivateWin32 *) font;
-  GHashTable **hashp = (type == GDK_FONT_FONT) ?
-    &font_name_hash : &fontset_name_hash;
-
-  if (!*hashp)
-    *hashp = g_hash_table_new (g_str_hash, g_str_equal);
-
-  private->names = g_slist_prepend (private->names, g_strdup (font_name));
-  g_hash_table_insert (*hashp, private->names->data, font);
-}
-
-static void
-gdk_font_hash_remove (GdkFontType type,
-		      GdkFont    *font)
-{
-  GdkFontPrivateWin32 *private = (GdkFontPrivateWin32 *) font;
-  GSList *tmp_list;
-  GHashTable *hash = (type == GDK_FONT_FONT) ?
-    font_name_hash : fontset_name_hash;
-
-  tmp_list = private->names;
-  while (tmp_list)
-    {
-      g_hash_table_remove (hash, tmp_list->data);
-      g_free (tmp_list->data);
-      
-      tmp_list = tmp_list->next;
-    }
-
-  g_slist_free (private->names);
-  private->names = NULL;
-}
-
-static GdkFont *
-gdk_font_hash_lookup (GdkFontType  type,
-		      const gchar *font_name)
-{
-  GdkFont *result;
-  GHashTable *hash = (type == GDK_FONT_FONT) ?
-    font_name_hash : fontset_name_hash;
-
-  if (!hash)
-    return NULL;
-  else
-    {
-      result = g_hash_table_lookup (hash, font_name);
-      if (result)
-	gdk_font_ref (result);
-      
-      return result;
-    }
-}
-
-#ifdef G_ENABLE_DEBUG
-static const char *
-charset_name (DWORD charset)
-{
-  switch (charset)
-    {
-    case ANSI_CHARSET: return "ansi";
-    case DEFAULT_CHARSET: return "default";
-    case SYMBOL_CHARSET: return "symbol";
-    case SHIFTJIS_CHARSET: return "shiftjis";
-    case HANGEUL_CHARSET: return "hangeul";
-    case GB2312_CHARSET: return "gb2312";
-    case CHINESEBIG5_CHARSET: return "big5";
-    case JOHAB_CHARSET: return "johab";
-    case HEBREW_CHARSET: return "hebrew";
-    case ARABIC_CHARSET: return "arabic";
-    case GREEK_CHARSET: return "greek";
-    case TURKISH_CHARSET: return "turkish";
-    case VIETNAMESE_CHARSET: return "vietnamese";
-    case THAI_CHARSET: return "thai";
-    case EASTEUROPE_CHARSET: return "easteurope";
-    case RUSSIAN_CHARSET: return "russian";
-    case MAC_CHARSET: return "mac";
-    case BALTIC_CHARSET: return "baltic";
-    }
-  return "unknown";
-}
-#endif
-
-/* This table classifies Unicode characters according to the Microsoft
- * Unicode subset numbering. This is based on the table in "Developing
- * International Software for Windows 95 and Windows NT". This is almost,
- * but not quite, the same as the official Unicode block table in
- * Blocks.txt from ftp.unicode.org. The bit number field is the bitfield
- * number as in the FONTSIGNATURE struct's fsUsb field.
- * There are some grave bugs in the table in the books. For instance
- * it claims there are Hangul at U+3400..U+4DFF while this range in
- * fact contains CJK Unified Ideographs Extension A. Also, the whole
- * block of Hangul Syllables U+AC00..U+D7A3 is missing from the book.
- */
-
-typedef enum
-{
-  U_BASIC_LATIN = 0,
-  U_LATIN_1_SUPPLEMENT = 1,
-  U_LATIN_EXTENDED_A = 2,
-  U_LATIN_EXTENDED_B = 3,
-  U_IPA_EXTENSIONS = 4,
-  U_SPACING_MODIFIER_LETTERS = 5,
-  U_COMBINING_DIACRITICAL_MARKS = 6,
-  U_BASIC_GREEK = 7,
-  U_GREEK_SYMBOLS_AND_COPTIC = 8,
-  U_CYRILLIC = 9,
-  U_ARMENIAN = 10,
-  U_HEBREW_EXTENDED = 12,
-  U_BASIC_HEBREW = 11,
-  U_BASIC_ARABIC = 13,
-  U_ARABIC_EXTENDED = 14,
-  U_DEVANAGARI = 15,
-  U_BENGALI = 16,
-  U_GURMUKHI = 17,
-  U_GUJARATI = 18,
-  U_ORIYA = 19,
-  U_TAMIL = 20,
-  U_TELUGU = 21,
-  U_KANNADA = 22,
-  U_MALAYALAM = 23,
-  U_THAI = 24,
-  U_LAO = 25,
-  U_GEORGIAN_EXTENDED = 27,
-  U_BASIC_GEORGIAN = 26,
-  U_HANGUL_JAMO = 28,
-  U_LATIN_EXTENDED_ADDITIONAL = 29,
-  U_GREEK_EXTENDED = 30,
-  U_GENERAL_PUNCTUATION = 31,
-  U_SUPERSCRIPTS_AND_SUBSCRIPTS = 32,
-  U_CURRENCY_SYMBOLS = 33,
-  U_COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS = 34,
-  U_LETTERLIKE_SYMBOLS = 35,
-  U_NUMBER_FORMS = 36,
-  U_ARROWS = 37,
-  U_MATHEMATICAL_OPERATORS = 38,
-  U_MISCELLANEOUS_TECHNICAL = 39,
-  U_CONTROL_PICTURES = 40,
-  U_OPTICAL_CHARACTER_RECOGNITION = 41,
-  U_ENCLOSED_ALPHANUMERICS = 42,
-  U_BOX_DRAWING = 43,
-  U_BLOCK_ELEMENTS = 44,
-  U_GEOMETRIC_SHAPES = 45,
-  U_MISCELLANEOUS_SYMBOLS = 46,
-  U_DINGBATS = 47,
-  U_CJK_SYMBOLS_AND_PUNCTUATION = 48,
-  U_HIRAGANA = 49,
-  U_KATAKANA = 50,
-  U_BOPOMOFO = 51,
-  U_HANGUL_COMPATIBILITY_JAMO = 52,
-  U_CJK_MISCELLANEOUS = 53,
-  U_ENCLOSED_CJK = 54,
-  U_CJK_COMPATIBILITY = 55,
-  U_HANGUL = 56,
-  U_HANGUL_SUPPLEMENTARY_A = 57,
-  U_HANGUL_SUPPLEMENTARY_B = 58,
-  U_CJK_UNIFIED_IDEOGRAPHS = 59,
-  U_PRIVATE_USE_AREA = 60,
-  U_CJK_COMPATIBILITY_IDEOGRAPHS = 61,
-  U_ALPHABETIC_PRESENTATION_FORMS = 62,
-  U_ARABIC_PRESENTATION_FORMS_A = 63,
-  U_COMBINING_HALF_MARKS = 64,
-  U_CJK_COMPATIBILITY_FORMS = 65,
-  U_SMALL_FORM_VARIANTS = 66,
-  U_ARABIC_PRESENTATION_FORMS_B = 67,
-  U_SPECIALS = 69,
-  U_HALFWIDTH_AND_FULLWIDTH_FORMS = 68,
-  U_LAST_PLUS_ONE
-} unicode_subset;
-
-static struct {
-  wchar_t low, high;
-  unicode_subset bit; 
-  gchar *name;
-} utab[] =
-{
-  { 0x0000, 0x007E,
-    U_BASIC_LATIN, "Basic Latin" },
-  { 0x00A0, 0x00FF,
-    U_LATIN_1_SUPPLEMENT, "Latin-1 Supplement" },
-  { 0x0100, 0x017F,
-    U_LATIN_EXTENDED_A, "Latin Extended-A" },
-  { 0x0180, 0x024F,
-    U_LATIN_EXTENDED_B, "Latin Extended-B" },
-  { 0x0250, 0x02AF,
-    U_IPA_EXTENSIONS, "IPA Extensions" },
-  { 0x02B0, 0x02FF,
-    U_SPACING_MODIFIER_LETTERS, "Spacing Modifier Letters" },
-  { 0x0300, 0x036F,
-    U_COMBINING_DIACRITICAL_MARKS, "Combining Diacritical Marks" },
-  { 0x0370, 0x03CF,
-    U_BASIC_GREEK, "Basic Greek" },
-  { 0x03D0, 0x03FF,
-    U_GREEK_SYMBOLS_AND_COPTIC, "Greek Symbols and Coptic" },
-  { 0x0400, 0x04FF,
-    U_CYRILLIC, "Cyrillic" },
-  { 0x0530, 0x058F,
-    U_ARMENIAN, "Armenian" },
-  { 0x0590, 0x05CF,
-    U_HEBREW_EXTENDED, "Hebrew Extended" },
-  { 0x05D0, 0x05FF,
-    U_BASIC_HEBREW, "Basic Hebrew" },
-  { 0x0600, 0x0652,
-    U_BASIC_ARABIC, "Basic Arabic" },
-  { 0x0653, 0x06FF,
-    U_ARABIC_EXTENDED, "Arabic Extended" },
-  { 0x0900, 0x097F,
-    U_DEVANAGARI, "Devanagari" },
-  { 0x0980, 0x09FF,
-    U_BENGALI, "Bengali" },
-  { 0x0A00, 0x0A7F,
-    U_GURMUKHI, "Gurmukhi" },
-  { 0x0A80, 0x0AFF,
-    U_GUJARATI, "Gujarati" },
-  { 0x0B00, 0x0B7F,
-    U_ORIYA, "Oriya" },
-  { 0x0B80, 0x0BFF,
-    U_TAMIL, "Tamil" },
-  { 0x0C00, 0x0C7F,
-    U_TELUGU, "Telugu" },
-  { 0x0C80, 0x0CFF,
-    U_KANNADA, "Kannada" },
-  { 0x0D00, 0x0D7F,
-    U_MALAYALAM, "Malayalam" },
-  { 0x0E00, 0x0E7F,
-    U_THAI, "Thai" },
-  { 0x0E80, 0x0EFF,
-    U_LAO, "Lao" },
-  { 0x10A0, 0x10CF,
-    U_GEORGIAN_EXTENDED, "Georgian Extended" },
-  { 0x10D0, 0x10FF,
-    U_BASIC_GEORGIAN, "Basic Georgian" },
-  { 0x1100, 0x11FF,
-    U_HANGUL_JAMO, "Hangul Jamo" },
-  { 0x1E00, 0x1EFF,
-    U_LATIN_EXTENDED_ADDITIONAL, "Latin Extended Additional" },
-  { 0x1F00, 0x1FFF,
-    U_GREEK_EXTENDED, "Greek Extended" },
-  { 0x2000, 0x206F,
-    U_GENERAL_PUNCTUATION, "General Punctuation" },
-  { 0x2070, 0x209F,
-    U_SUPERSCRIPTS_AND_SUBSCRIPTS, "Superscripts and Subscripts" },
-  { 0x20A0, 0x20CF,
-    U_CURRENCY_SYMBOLS, "Currency Symbols" },
-  { 0x20D0, 0x20FF,
-    U_COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS, "Combining Diacritical Marks for Symbols" },
-  { 0x2100, 0x214F,
-    U_LETTERLIKE_SYMBOLS, "Letterlike Symbols" },
-  { 0x2150, 0x218F,
-    U_NUMBER_FORMS, "Number Forms" },
-  { 0x2190, 0x21FF,
-    U_ARROWS, "Arrows" },
-  { 0x2200, 0x22FF,
-    U_MATHEMATICAL_OPERATORS, "Mathematical Operators" },
-  { 0x2300, 0x23FF,
-    U_MISCELLANEOUS_TECHNICAL, "Miscellaneous Technical" },
-  { 0x2400, 0x243F,
-    U_CONTROL_PICTURES, "Control Pictures" },
-  { 0x2440, 0x245F,
-    U_OPTICAL_CHARACTER_RECOGNITION, "Optical Character Recognition" },
-  { 0x2460, 0x24FF,
-    U_ENCLOSED_ALPHANUMERICS, "Enclosed Alphanumerics" },
-  { 0x2500, 0x257F,
-    U_BOX_DRAWING, "Box Drawing" },
-  { 0x2580, 0x259F,
-    U_BLOCK_ELEMENTS, "Block Elements" },
-  { 0x25A0, 0x25FF,
-    U_GEOMETRIC_SHAPES, "Geometric Shapes" },
-  { 0x2600, 0x26FF,
-    U_MISCELLANEOUS_SYMBOLS, "Miscellaneous Symbols" },
-  { 0x2700, 0x27BF,
-    U_DINGBATS, "Dingbats" },
-  { 0x3000, 0x303F,
-    U_CJK_SYMBOLS_AND_PUNCTUATION, "CJK Symbols and Punctuation" },
-  { 0x3040, 0x309F,
-    U_HIRAGANA, "Hiragana" },
-  { 0x30A0, 0x30FF,
-    U_KATAKANA, "Katakana" },
-  { 0x3100, 0x312F,
-    U_BOPOMOFO, "Bopomofo" },
-  { 0x3130, 0x318F,
-    U_HANGUL_COMPATIBILITY_JAMO, "Hangul Compatibility Jamo" },
-  { 0x3190, 0x319F,
-    U_CJK_MISCELLANEOUS, "CJK Miscellaneous" },
-  { 0x3200, 0x32FF,
-    U_ENCLOSED_CJK, "Enclosed CJK" },
-  { 0x3300, 0x33FF,
-    U_CJK_COMPATIBILITY, "CJK Compatibility" },
-  /* The book claims:
-   * U+3400..U+3D2D = Hangul
-   * U+3D2E..U+44B7 = Hangul Supplementary A
-   * U+44B8..U+4DFF = Hangul Supplementary B
-   * but actually in Unicode
-   * U+3400..U+4DB5 = CJK Unified Ideographs Extension A
-   */
-  { 0x3400, 0x4DB5,
-    U_CJK_UNIFIED_IDEOGRAPHS, "CJK Unified Ideographs Extension A" },
-  { 0x4E00, 0x9FFF,
-    U_CJK_UNIFIED_IDEOGRAPHS, "CJK Unified Ideographs" },
-  /* This was missing completely from the book's table. */
-  { 0xAC00, 0xD7A3,
-    U_HANGUL, "Hangul Syllables" },
-  { 0xE000, 0xF8FF,
-    U_PRIVATE_USE_AREA, "Private Use Area" },
-  { 0xF900, 0xFAFF,
-    U_CJK_COMPATIBILITY_IDEOGRAPHS, "CJK Compatibility Ideographs" },
-  { 0xFB00, 0xFB4F,
-    U_ALPHABETIC_PRESENTATION_FORMS, "Alphabetic Presentation Forms" },
-  { 0xFB50, 0xFDFF,
-    U_ARABIC_PRESENTATION_FORMS_A, "Arabic Presentation Forms-A" },
-  { 0xFE20, 0xFE2F,
-    U_COMBINING_HALF_MARKS, "Combining Half Marks" },
-  { 0xFE30, 0xFE4F,
-    U_CJK_COMPATIBILITY_FORMS, "CJK Compatibility Forms" },
-  { 0xFE50, 0xFE6F,
-    U_SMALL_FORM_VARIANTS, "Small Form Variants" },
-  { 0xFE70, 0xFEFE,
-    U_ARABIC_PRESENTATION_FORMS_B, "Arabic Presentation Forms-B" },
-  { 0xFEFF, 0xFEFF,
-    U_SPECIALS, "Specials" },
-  { 0xFF00, 0xFFEF,
-    U_HALFWIDTH_AND_FULLWIDTH_FORMS, "Halfwidth and Fullwidth Forms" },
-  { 0xFFF0, 0xFFFD,
-    U_SPECIALS, "Specials" }
-};
-
-#ifdef G_ENABLE_DEBUG
-static void
-print_unicode_subranges (FONTSIGNATURE *fsp)
-{
-  int i;
-  gboolean checked[G_N_ELEMENTS (utab)];
-  gboolean need_comma = FALSE;
-
-  memset (checked, 0, sizeof (checked));
-
-  for (i = 0; i < G_N_ELEMENTS (utab); i++)
-    if (!checked[i]
-	&& (fsp->fsUsb[utab[i].bit/32] & (1 << (utab[i].bit % 32))))
-      {
-	g_print ("%s %s", (need_comma ? "," : ""), utab[i].name);
-	need_comma = TRUE;
-	checked[i] = TRUE;
-      }
-  if (!need_comma)
-    g_print (" none!");
-  g_print ("\n");
-}
-#endif
-
-static gboolean
-check_unicode_subranges (UINT           charset,
-			 FONTSIGNATURE *fsp)
-{
-  gint i;
-  gboolean retval = FALSE;
-
-  /* If the fsUsb bit array has at least one of the bits set, trust it */
-  for (i = 0; i < U_LAST_PLUS_ONE; i++)
-    if (i != U_PRIVATE_USE_AREA && (fsp->fsUsb[i/32] & (1 << (i % 32))))
-      return FALSE;
-
-  /* Otherwise, guess what subranges there should be in the font */
-  fsp->fsUsb[0] = fsp->fsUsb[1] = fsp->fsUsb[2] = fsp->fsUsb[3] = 0;
-
-#define set_bit(bitno) (fsp->fsUsb[(bitno)/32] |= (1 << ((bitno) % 32)))
-
-  /* Set Unicode subrange bits based on code pages supported.
-   * This is mostly just guesswork.
-   */
-
-#define check_cp(bit) (fsp->fsCsb[0] & (bit))
-
-  if (check_cp(FS_LATIN1))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_CURRENCY_SYMBOLS);
-      retval = TRUE;
-    }
-  if (check_cp (FS_LATIN2))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_CURRENCY_SYMBOLS);
-      retval = TRUE;
-    }
-  if (check_cp (FS_CYRILLIC))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_CYRILLIC);
-      retval = TRUE;
-    }
-  if (check_cp (FS_GREEK))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_BASIC_GREEK);
-      retval = TRUE;
-    }
-  if (check_cp (FS_TURKISH))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_CURRENCY_SYMBOLS);
-      retval = TRUE;
-    }
-  if (check_cp (FS_HEBREW))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_BASIC_HEBREW);
-      set_bit (U_HEBREW_EXTENDED);
-      retval = TRUE;
-    }
-  if (check_cp (FS_ARABIC))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_BASIC_ARABIC);
-      set_bit (U_ARABIC_EXTENDED);
-      retval = TRUE;
-    }
-  if (check_cp (FS_BALTIC))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_LATIN_EXTENDED_B);
-      retval = TRUE;
-    }
-  if (check_cp (FS_VIETNAMESE))
-    {
-      /* ??? */
-      set_bit (U_BASIC_LATIN);
-      retval = TRUE;
-    }
-  if (check_cp (FS_THAI))
-    {
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_THAI);
-      retval = TRUE;
-    }
-  if (check_cp (FS_JISJAPAN))
-    {
-      /* Based on MS Gothic */
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_CJK_SYMBOLS_AND_PUNCTUATION);
-      set_bit (U_HIRAGANA);
-      set_bit (U_KATAKANA);
-      set_bit (U_CJK_UNIFIED_IDEOGRAPHS);
-      set_bit (U_HALFWIDTH_AND_FULLWIDTH_FORMS);
-      retval = TRUE;
-    }
-  if (check_cp (FS_CHINESESIMP))
-    {
-      /* Based on MS Hei */
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_HIRAGANA);
-      set_bit (U_KATAKANA);
-      set_bit (U_BOPOMOFO);
-      set_bit (U_CJK_UNIFIED_IDEOGRAPHS);
-      retval = TRUE;
-    }
-  if (check_cp (FS_WANSUNG)
-      || check_cp (FS_JOHAB))	/* ??? */
-    {
-      /* Based on GulimChe. I wonder if all Korean fonts
-       * really support this large range of Unicode subranges?
-       */
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_CYRILLIC);
-      set_bit (U_HANGUL_JAMO);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_SUPERSCRIPTS_AND_SUBSCRIPTS);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_NUMBER_FORMS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_ENCLOSED_ALPHANUMERICS);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      set_bit (U_CJK_SYMBOLS_AND_PUNCTUATION);
-      set_bit (U_HIRAGANA);
-      set_bit (U_KATAKANA);
-      set_bit (U_HANGUL_COMPATIBILITY_JAMO);
-      set_bit (U_ENCLOSED_CJK);
-      set_bit (U_CJK_COMPATIBILITY_FORMS);
-      set_bit (U_HANGUL);
-      set_bit (U_CJK_UNIFIED_IDEOGRAPHS);
-      set_bit (U_CJK_COMPATIBILITY_IDEOGRAPHS);
-      set_bit (U_HALFWIDTH_AND_FULLWIDTH_FORMS);
-      retval = TRUE;
-    }
-  if (check_cp (FS_CHINESETRAD))
-    {
-      /* Based on MingLiU */
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_CJK_SYMBOLS_AND_PUNCTUATION);
-      set_bit (U_BOPOMOFO);
-      set_bit (U_CJK_UNIFIED_IDEOGRAPHS);
-      set_bit (U_CJK_COMPATIBILITY_IDEOGRAPHS);
-      set_bit (U_SMALL_FORM_VARIANTS);
-      set_bit (U_HALFWIDTH_AND_FULLWIDTH_FORMS);
-      retval = TRUE;
-    }
-  if (check_cp (FS_SYMBOL) || charset == MAC_CHARSET)
-    {
-      /* Non-Unicode encoding, I guess. Pretend it covers
-       * the single-byte range of values.
-       */
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      retval = TRUE;
-    }
-
-  if (retval)
-    return TRUE;
-
-  GDK_NOTE (MISC, g_print ("... No code page bits set!\n"));
-
-  /* Sigh. Not even any code page bits were set. Guess based on
-   * charset, then. These somewhat optimistic guesses are based on the
-   * table in Appendix M in the book "Developing ..."  mentioned
-   * above.
-   */
-  switch (charset)
-    {
-    case ANSI_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_COMBINING_DIACRITICAL_MARKS);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_SUPERSCRIPTS_AND_SUBSCRIPTS);
-      set_bit (U_CURRENCY_SYMBOLS);
-#if 0 /* I find this too hard to believe... */
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_CYRILLIC);
-      set_bit (U_BASIC_HEBREW);
-      set_bit (U_HEBREW_EXTENDED);
-      set_bit (U_BASIC_ARABIC);
-      set_bit (U_ARABIC_EXTENDED);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_NUMBER_FORMS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_ENCLOSED_ALPHANUMERICS);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      set_bit (U_HIRAGANA);
-      set_bit (U_KATAKANA);
-      set_bit (U_BOPOMOFO);
-      set_bit (U_HANGUL_COMPATIBILITY_JAMO);
-      set_bit (U_CJK_MISCELLANEOUS);
-      set_bit (U_CJK_COMPATIBILITY);
-      set_bit (U_HANGUL);
-      set_bit (U_HANGUL_SUPPLEMENTARY_A);
-      set_bit (U_CJK_COMPATIBILITY_IDEOGRAPHS);
-      set_bit (U_ALPHABETIC_PRESENTATION_FORMS);
-      set_bit (U_SMALL_FORM_VARIANTS);
-      set_bit (U_ARABIC_PRESENTATION_FORMS_B);
-      set_bit (U_HALFWIDTH_AND_FULLWIDTH_FORMS);
-      set_bit (U_SPECIALS);
-#endif
-      retval = TRUE;
-      break;
-    case SYMBOL_CHARSET:
-      /* Unggh */
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      retval = TRUE;
-      break;
-    case SHIFTJIS_CHARSET:
-    case HANGEUL_CHARSET:
-    case GB2312_CHARSET:
-    case CHINESEBIG5_CHARSET:
-    case JOHAB_CHARSET:
-      /* The table really does claim these "locales" (it doesn't
-       * talk about charsets per se) cover the same Unicode
-       * subranges
-       */
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS);
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_CYRILLIC);
-      set_bit (U_HANGUL_JAMO);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_SUPERSCRIPTS_AND_SUBSCRIPTS);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_NUMBER_FORMS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_ENCLOSED_ALPHANUMERICS);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      set_bit (U_CJK_SYMBOLS_AND_PUNCTUATION);
-      set_bit (U_HIRAGANA);
-      set_bit (U_KATAKANA);
-      set_bit (U_BOPOMOFO);
-      set_bit (U_HANGUL_COMPATIBILITY_JAMO);
-      set_bit (U_CJK_MISCELLANEOUS);
-      set_bit (U_CJK_COMPATIBILITY);
-      set_bit (U_HANGUL);
-      set_bit (U_HANGUL_SUPPLEMENTARY_A);
-      set_bit (U_CJK_UNIFIED_IDEOGRAPHS);
-      set_bit (U_CJK_COMPATIBILITY_IDEOGRAPHS);
-      set_bit (U_ALPHABETIC_PRESENTATION_FORMS);
-      set_bit (U_SMALL_FORM_VARIANTS);
-      set_bit (U_ARABIC_PRESENTATION_FORMS_B);
-      set_bit (U_SPECIALS);
-      retval = TRUE;
-      break;
-    case HEBREW_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_BASIC_HEBREW);
-      set_bit (U_HEBREW_EXTENDED);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      retval = TRUE; 
-      break;
-    case ARABIC_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_BASIC_ARABIC);
-      set_bit (U_ARABIC_EXTENDED);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      set_bit (U_HALFWIDTH_AND_FULLWIDTH_FORMS);
-      retval = TRUE;
-      break;
-    case GREEK_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_SUPERSCRIPTS_AND_SUBSCRIPTS);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      retval = TRUE;
-      break;
-    case TURKISH_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_SUPERSCRIPTS_AND_SUBSCRIPTS);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      retval = TRUE;
-      break;
-    case VIETNAMESE_CHARSET:
-    case THAI_CHARSET:
-      /* These are not in the table, so I have no idea */
-      break;
-    case BALTIC_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_SUPERSCRIPTS_AND_SUBSCRIPTS);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      retval = TRUE;
-      break;
-    case EASTEUROPE_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_LATIN_EXTENDED_A);
-      set_bit (U_LATIN_EXTENDED_B);
-      set_bit (U_SPACING_MODIFIER_LETTERS);
-      set_bit (U_BASIC_GREEK);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_SUPERSCRIPTS_AND_SUBSCRIPTS);
-      set_bit (U_CURRENCY_SYMBOLS);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      retval = TRUE;
-      break;
-    case RUSSIAN_CHARSET:
-      set_bit (U_BASIC_LATIN);
-      set_bit (U_LATIN_1_SUPPLEMENT);
-      set_bit (U_CYRILLIC);
-      set_bit (U_GENERAL_PUNCTUATION);
-      set_bit (U_LETTERLIKE_SYMBOLS);
-      set_bit (U_ARROWS);
-      set_bit (U_MATHEMATICAL_OPERATORS);
-      set_bit (U_MISCELLANEOUS_TECHNICAL);
-      set_bit (U_BOX_DRAWING);
-      set_bit (U_BLOCK_ELEMENTS);
-      set_bit (U_GEOMETRIC_SHAPES);
-      set_bit (U_MISCELLANEOUS_SYMBOLS);
-      retval = TRUE;
-      break;
-    }
-
-#undef set_bit
-  return retval;
-}
-
-static GdkWin32SingleFont *
-gdk_font_load_logfont (LOGFONT *lfp)
-{
-  GdkWin32SingleFont *singlefont;
-  HFONT hfont;
-  LOGFONT logfont;
-  CHARSETINFO csi;
-  HGDIOBJ oldfont;
-  int tries;
-  gchar face[100];
-
-  for (tries = 0; ; tries++)
-    {
-      GDK_NOTE (MISC, g_print ("... trying %ld,%ld,%ld,%ld,"
-			       "%ld,%d,%d,%d,"
-			       "%d,%d,%d,"
-			       "%d,%#.02x,\"%s\"\n",
-			       lfp->lfHeight, lfp->lfWidth,
-			       lfp->lfEscapement, lfp->lfOrientation,
-			       lfp->lfWeight, lfp->lfItalic,
-			       lfp->lfUnderline, lfp->lfStrikeOut,
-			       lfp->lfCharSet,
-			       lfp->lfOutPrecision, lfp->lfClipPrecision,
-			       lfp->lfQuality, lfp->lfPitchAndFamily,
-			       lfp->lfFaceName));
-      hfont = CreateFontIndirect (lfp);
-
-      if (hfont != NULL)
-	break;
-      
-      /* If we fail, try some similar fonts often found on Windows. */
-      if (tries == 0)
-	{
-	  if (g_ascii_strcasecmp (lfp->lfFaceName, "helvetica") == 0)
-	    strcpy (lfp->lfFaceName, "arial");
-	  else if (g_ascii_strcasecmp (lfp->lfFaceName, "new century schoolbook") == 0)
-	    strcpy (lfp->lfFaceName, "century schoolbook");
-	  else if (g_ascii_strcasecmp (lfp->lfFaceName, "courier") == 0)
-	    strcpy (lfp->lfFaceName, "courier new");
-	  else if (g_ascii_strcasecmp (lfp->lfFaceName, "lucida") == 0)
-	    strcpy (lfp->lfFaceName, "lucida sans unicode");
-	  else if (g_ascii_strcasecmp (lfp->lfFaceName, "lucidatypewriter") == 0)
-	    strcpy (lfp->lfFaceName, "lucida console");
-	  else if (g_ascii_strcasecmp (lfp->lfFaceName, "times") == 0)
-	    strcpy (lfp->lfFaceName, "times new roman");
-	}
-      else if (tries == 1)
-	{
-	  if (g_ascii_strcasecmp (lfp->lfFaceName, "courier") == 0)
-	    {
-	      strcpy (lfp->lfFaceName, "");
-	      lfp->lfPitchAndFamily |= FF_MODERN;
-	    }
-	  else if (g_ascii_strcasecmp (lfp->lfFaceName, "times new roman") == 0)
-	    {
-	      strcpy (lfp->lfFaceName, "");
-	      lfp->lfPitchAndFamily |= FF_ROMAN;
-	    }
-	  else if (g_ascii_strcasecmp (lfp->lfFaceName, "helvetica") == 0
-		   || g_ascii_strcasecmp (lfp->lfFaceName, "lucida") == 0)
-	    {
-	      strcpy (lfp->lfFaceName, "");
-	      lfp->lfPitchAndFamily |= FF_SWISS;
-	    }
-	  else
-	    {
-	      strcpy (lfp->lfFaceName, "");
-	      lfp->lfPitchAndFamily = (lfp->lfPitchAndFamily & 0x0F) | FF_DONTCARE;
-	    }
-	}
-      else
-	break;
-      tries++;
-    }
-
-  if (!hfont)
-    return NULL;
-      
-  singlefont = g_new (GdkWin32SingleFont, 1);
-  singlefont->hfont = hfont;
-  GetObject (singlefont->hfont, sizeof (logfont), &logfont);
-  oldfont = SelectObject (_gdk_display_hdc, singlefont->hfont);
-  memset (&singlefont->fs, 0, sizeof (singlefont->fs));
-  singlefont->charset = GetTextCharsetInfo (_gdk_display_hdc, &singlefont->fs, 0);
-  GetTextFace (_gdk_display_hdc, sizeof (face), face);
-  SelectObject (_gdk_display_hdc, oldfont);
-  if (TranslateCharsetInfo ((DWORD *) (gintptr) singlefont->charset, &csi,
-			    TCI_SRCCHARSET)
-      && singlefont->charset != MAC_CHARSET)
-    singlefont->codepage = csi.ciACP;
-  else
-    singlefont->codepage = 0;
-
-  GDK_NOTE (MISC, (g_print ("... = %p %s cs %s cp%d\n",
-			    singlefont->hfont, face,
-			    charset_name (singlefont->charset),
-			    singlefont->codepage),
-		   g_print ("... Unicode subranges:"),
-		   print_unicode_subranges (&singlefont->fs)));
-  if (check_unicode_subranges (singlefont->charset, &singlefont->fs))
-    GDK_NOTE (MISC, (g_print ("... Guesstimated Unicode subranges:"),
-		     print_unicode_subranges (&singlefont->fs)));
-
-  return singlefont;
-}
-
-static GdkWin32SingleFont *
-gdk_font_load_internal (const gchar *font_name)
-{
-  LOGFONT logfont;
-
-  char *fn;
-  int numfields, n1, n2;
-  char foundry[32], family[100], weight[32], slant[32], set_width[32],
-    spacing[32], registry[32], encoding[32];
-  char pixel_size[10], point_size[10], res_x[10], res_y[10], avg_width[10];
-  int c;
-  char *p;
-  int logpixelsy;
-
-  g_return_val_if_fail (font_name != NULL, NULL);
-
-  GDK_NOTE (MISC, g_print ("gdk_font_load_internal: %s\n", font_name));
-
-  numfields = sscanf (font_name,
-		      "-%30[^-]-%100[^-]-%30[^-]-%30[^-]-%30[^-]-%n",
-		      foundry,
-		      family,
-		      weight,
-		      slant,
-		      set_width,
-		      &n1);
-  if (numfields == 0)
-    {
-      /* Probably a plain Windows font name */
-      logfont.lfHeight = 0;
-      logfont.lfWidth = 0;
-      logfont.lfEscapement = 0;
-      logfont.lfOrientation = 0;
-      logfont.lfWeight = FW_DONTCARE;
-      logfont.lfItalic = FALSE;
-      logfont.lfUnderline = FALSE;
-      logfont.lfStrikeOut = FALSE;
-      logfont.lfCharSet = ANSI_CHARSET;
-      logfont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
-      logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
-      logfont.lfQuality = PROOF_QUALITY;
-      logfont.lfPitchAndFamily = DEFAULT_PITCH;
-      fn = g_filename_from_utf8 (font_name, -1, NULL, NULL, NULL);
-      strcpy (logfont.lfFaceName, fn);
-      g_free (fn);
-    }
-  else if (numfields != 5)
-    {
-      g_warning ("gdk_font_load: font name %s illegal", font_name);
-      return NULL;
-    }
-  else
-    {
-      /* It must be a XLFD name */
-
-      /* Check for hex escapes in the font family,
-       * put in there by logfont_to_xlfd. Convert them in-place.
-       */
-      p = family;
-      while (*p)
-	{
-	  if (*p == '%' && isxdigit (p[1]) && isxdigit (p[2]))
-	    {
-	      sscanf (p+1, "%2x", &c);
-	      *p = c;
-	      strcpy (p+1, p+3);
-	    }
-	  p++;
-	}
-
-      /* Skip add_style which often is empty in the requested font name */
-      while (font_name[n1] && font_name[n1] != '-')
-	n1++;
-      numfields++;
-
-      numfields += sscanf (font_name + n1,
-			   "-%8[^-]-%8[^-]-%8[^-]-%8[^-]-%30[^-]-%8[^-]-%30[^-]-%30[^-]%n",
-			   pixel_size,
-			   point_size,
-			   res_x,
-			   res_y,
-			   spacing,
-			   avg_width,
-			   registry,
-			   encoding,
-			   &n2);
-
-      if (numfields != 14 || font_name[n1 + n2] != '\0')
-	{
-	  g_warning ("gdk_font_load: font name %s illegal", font_name);
-	  return NULL;
-	}
-
-      logpixelsy = GetDeviceCaps (_gdk_display_hdc, LOGPIXELSY);
-
-      if (strcmp (pixel_size, "*") == 0)
-	if (strcmp (point_size, "*") == 0)
-	  logfont.lfHeight = 0;
-	else
-	  logfont.lfHeight = -(int) (((double) atoi (point_size))/720.*logpixelsy);
-      else
-	logfont.lfHeight = -atoi (pixel_size);
-
-      logfont.lfWidth = 0;
-      logfont.lfEscapement = 0;
-      logfont.lfOrientation = 0;
-
-      if (g_ascii_strcasecmp (weight, "thin") == 0)
-	logfont.lfWeight = FW_THIN;
-      else if (g_ascii_strcasecmp (weight, "extralight") == 0)
-	logfont.lfWeight = FW_EXTRALIGHT;
-      else if (g_ascii_strcasecmp (weight, "ultralight") == 0)
-#ifdef FW_ULTRALIGHT
-	logfont.lfWeight = FW_ULTRALIGHT;
-#else
-	logfont.lfWeight = FW_EXTRALIGHT; /* In fact, FW_ULTRALIGHT really is 
-					   * defined as FW_EXTRALIGHT anyway.
-					   */
-#endif
-      else if (g_ascii_strcasecmp (weight, "light") == 0)
-	logfont.lfWeight = FW_LIGHT;
-      else if (g_ascii_strcasecmp (weight, "normal") == 0)
-	logfont.lfWeight = FW_NORMAL;
-      else if (g_ascii_strcasecmp (weight, "regular") == 0)
-	logfont.lfWeight = FW_REGULAR;
-      else if (g_ascii_strcasecmp (weight, "medium") == 0)
-	logfont.lfWeight = FW_MEDIUM;
-      else if (g_ascii_strcasecmp (weight, "semibold") == 0)
-	logfont.lfWeight = FW_SEMIBOLD;
-      else if (g_ascii_strcasecmp (weight, "demibold") == 0)
-#ifdef FW_DEMIBOLD
-	logfont.lfWeight = FW_DEMIBOLD;
-#else
-	logfont.lfWeight = FW_SEMIBOLD;	/* As above */
-#endif
-      else if (g_ascii_strcasecmp (weight, "bold") == 0)
-	logfont.lfWeight = FW_BOLD;
-      else if (g_ascii_strcasecmp (weight, "extrabold") == 0)
-	logfont.lfWeight = FW_EXTRABOLD;
-      else if (g_ascii_strcasecmp (weight, "ultrabold") == 0)
-#ifdef FW_ULTRABOLD
-	logfont.lfWeight = FW_ULTRABOLD;
-#else
-	logfont.lfWeight = FW_EXTRABOLD; /* As above */
-#endif
-      else if (g_ascii_strcasecmp (weight, "heavy") == 0)
-	logfont.lfWeight = FW_HEAVY;
-      else if (g_ascii_strcasecmp (weight, "black") == 0)
-#ifdef FW_BLACK
-	logfont.lfWeight = FW_BLACK;
-#else
-	logfont.lfWeight = FW_HEAVY;	/* As above */
-#endif
-      else
-	logfont.lfWeight = FW_DONTCARE;
-
-      if (g_ascii_strcasecmp (slant, "italic") == 0
-	  || g_ascii_strcasecmp (slant, "oblique") == 0
-	  || g_ascii_strcasecmp (slant, "i") == 0
-	  || g_ascii_strcasecmp (slant, "o") == 0)
-	logfont.lfItalic = TRUE;
-      else
-	logfont.lfItalic = FALSE;
-      logfont.lfUnderline = FALSE;
-      logfont.lfStrikeOut = FALSE;
-      if (g_ascii_strcasecmp (registry, "iso8859") == 0)
-	if (strcmp (encoding, "1") == 0)
-	  logfont.lfCharSet = ANSI_CHARSET;
-	else if (strcmp (encoding, "2") == 0)
-	  logfont.lfCharSet = EASTEUROPE_CHARSET;
-	else if (strcmp (encoding, "7") == 0)
-	  logfont.lfCharSet = GREEK_CHARSET;
-	else if (strcmp (encoding, "8") == 0)
-	  logfont.lfCharSet = HEBREW_CHARSET;
-	else if (strcmp (encoding, "9") == 0)
-	  logfont.lfCharSet = TURKISH_CHARSET;
-	else
-	  logfont.lfCharSet = ANSI_CHARSET; /* XXX ??? */
-      else if (g_ascii_strcasecmp (registry, "jisx0208.1983") == 0)
-	logfont.lfCharSet = SHIFTJIS_CHARSET;
-      else if (g_ascii_strcasecmp (registry, "ksc5601.1987") == 0)
-	logfont.lfCharSet = HANGEUL_CHARSET;
-      else if (g_ascii_strcasecmp (registry, "gb2312.1980") == 0)
-	logfont.lfCharSet = GB2312_CHARSET;
-      else if (g_ascii_strcasecmp (registry, "big5") == 0)
-	logfont.lfCharSet = CHINESEBIG5_CHARSET;
-      else if (g_ascii_strcasecmp (registry, "windows") == 0
-	       || g_ascii_strcasecmp (registry, "microsoft") == 0)
-	if (g_ascii_strcasecmp (encoding, "symbol") == 0)
-	  logfont.lfCharSet = SYMBOL_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "shiftjis") == 0)
-	  logfont.lfCharSet = SHIFTJIS_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "gb2312") == 0)
-	  logfont.lfCharSet = GB2312_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "hangeul") == 0)
-	  logfont.lfCharSet = HANGEUL_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "big5") == 0)
-	  logfont.lfCharSet = CHINESEBIG5_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "johab") == 0)
-	  logfont.lfCharSet = JOHAB_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "hebrew") == 0)
-	  logfont.lfCharSet = HEBREW_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "arabic") == 0)
-	  logfont.lfCharSet = ARABIC_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "greek") == 0)
-	  logfont.lfCharSet = GREEK_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "turkish") == 0)
-	  logfont.lfCharSet = TURKISH_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "easteurope") == 0)
-	  logfont.lfCharSet = EASTEUROPE_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "russian") == 0)
-	  logfont.lfCharSet = RUSSIAN_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "mac") == 0)
-	  logfont.lfCharSet = MAC_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "baltic") == 0)
-	  logfont.lfCharSet = BALTIC_CHARSET;
-	else if (g_ascii_strcasecmp (encoding, "cp1251") == 0)
-	  logfont.lfCharSet = RUSSIAN_CHARSET;
-	else
-	  logfont.lfCharSet = ANSI_CHARSET; /* XXX ??? */
-      else
-	logfont.lfCharSet = ANSI_CHARSET; /* XXX ??? */
-      logfont.lfOutPrecision = OUT_TT_PRECIS;
-      logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
-      logfont.lfQuality = PROOF_QUALITY;
-      if (g_ascii_strcasecmp (spacing, "m") == 0)
-	logfont.lfPitchAndFamily = FIXED_PITCH;
-      else if (g_ascii_strcasecmp (spacing, "p") == 0)
-	logfont.lfPitchAndFamily = VARIABLE_PITCH;
-      else 
-	logfont.lfPitchAndFamily = DEFAULT_PITCH;
-      fn = g_filename_from_utf8 (family, -1, NULL, NULL, NULL);
-      strcpy (logfont.lfFaceName, fn);
-      g_free (fn);
-    }
-
-  return gdk_font_load_logfont (&logfont);
-}
-
-static GdkFont *
-gdk_font_from_one_singlefont (GdkWin32SingleFont *singlefont)
-{
-  GdkFont *font;
-  GdkFontPrivateWin32 *private;
-  HGDIOBJ oldfont;
-  TEXTMETRIC textmetric;
-
-  private = g_new (GdkFontPrivateWin32, 1);
-  font = (GdkFont*) private;
-
-  private->base.ref_count = 1;
-  private->names = NULL;
-  private->fonts = g_slist_append (NULL, singlefont);
-
-  /* Pretend all fonts are fontsets... Gtktext and gtkentry work better
-   * that way, they use wide chars, which is necessary for non-ASCII
-   * chars to work. (Yes, even Latin-1, as we use Unicode internally.)
-   */
-  font->type = GDK_FONT_FONTSET;
-  oldfont = SelectObject (_gdk_display_hdc, singlefont->hfont);
-  GetTextMetrics (_gdk_display_hdc, &textmetric);
-  SelectObject (_gdk_display_hdc, oldfont);
-  font->ascent = textmetric.tmAscent;
-  font->descent = textmetric.tmDescent;
-
-  GDK_NOTE (MISC, g_print ("... asc %d desc %d\n",
-			   font->ascent, font->descent));
-
-  return font;
-}
-
-GdkFont*
-gdk_font_load_for_display (GdkDisplay  *display,
-                           const gchar *font_name)
-{
-  GdkFont *font;
-  GdkFontPrivateWin32 *private;
-  GdkWin32SingleFont *singlefont;
-  HGDIOBJ oldfont;
-  TEXTMETRIC textmetric;
-
-  g_return_val_if_fail (font_name != NULL, NULL);
-  g_return_val_if_fail (display == gdk_display_get_default (), NULL);
-
-  font = gdk_font_hash_lookup (GDK_FONT_FONTSET, font_name);
-  if (font)
-    return font;
-
-  private = g_new (GdkFontPrivateWin32, 1);
-  font = (GdkFont*) private;
-
-  singlefont = gdk_font_load_internal (font_name);
-
-  private->base.ref_count = 1;
-  private->names = NULL;
-  private->fonts = g_slist_append (NULL, singlefont);
-
-  /* Pretend all fonts are fontsets... Gtktext and gtkentry work better
-   * that way, they use wide chars, which is necessary for non-ASCII
-   * chars to work. (Yes, even Latin-1, as we use Unicode internally.)
-   */
-  font->type = GDK_FONT_FONTSET;
-  oldfont = SelectObject (_gdk_display_hdc, singlefont->hfont);
-  GetTextMetrics (_gdk_display_hdc, &textmetric);
-  SelectObject (_gdk_display_hdc, oldfont);
-  font->ascent = textmetric.tmAscent;
-  font->descent = textmetric.tmDescent;
-
-  GDK_NOTE (MISC, g_print ("... asc %d desc %d\n",
-			   font->ascent, font->descent));
-
-  gdk_font_hash_insert (GDK_FONT_FONTSET, font, font_name);
-
-  return gdk_font_from_one_singlefont (gdk_font_load_internal (font_name));
-}
-
-GdkFont*
-gdk_font_from_description_for_display (GdkDisplay           *display,
-                                       PangoFontDescription *font_desc)
-{
-  LOGFONT logfont;
-  int size;
-
-  g_return_val_if_fail (font_desc != NULL, NULL);
-  g_return_val_if_fail (display == gdk_display_get_default (), NULL);
-
-  size = PANGO_PIXELS (pango_font_description_get_size (font_desc));
-
-  logfont.lfHeight = - MulDiv (size,
-  			       GetDeviceCaps (_gdk_display_hdc, LOGPIXELSY),
-			       72);
-  logfont.lfWidth = 0;
-  logfont.lfEscapement = 0;
-  logfont.lfOrientation = 0;
-  logfont.lfWeight = FW_DONTCARE;
-  logfont.lfItalic = FALSE;
-  logfont.lfUnderline = FALSE;
-  logfont.lfStrikeOut = FALSE;
-  logfont.lfCharSet = ANSI_CHARSET;
-  logfont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
-  logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
-  logfont.lfQuality = PROOF_QUALITY;
-  logfont.lfPitchAndFamily = DEFAULT_PITCH;
-  strcpy (logfont.lfFaceName, "Arial");
-
-  return gdk_font_from_one_singlefont (gdk_font_load_logfont (&logfont));
-}
-
-GdkFont*
-gdk_fontset_load (const gchar *fontset_name)
-{
-  GdkFont *font;
-  GdkFontPrivateWin32 *private;
-  GdkWin32SingleFont *singlefont;
-  HGDIOBJ oldfont;
-  TEXTMETRIC textmetric;
-  gchar *fs;
-  gchar *b, *p, *s;
-
-  g_return_val_if_fail (fontset_name != NULL, NULL);
-
-  font = gdk_font_hash_lookup (GDK_FONT_FONTSET, fontset_name);
-  if (font)
-    return font;
-
-  s = fs = g_strdup (fontset_name);
-  while (*s && isspace (*s))
-    s++;
-
-  g_return_val_if_fail (*s, NULL);
-
-  private = g_new (GdkFontPrivateWin32, 1);
-  font = (GdkFont*) private;
-
-  private->base.ref_count = 1;
-  private->names = NULL;
-  private->fonts = NULL;
-
-  font->type = GDK_FONT_FONTSET;
-  font->ascent = 0;
-  font->descent = 0;
-
-  while (TRUE)
-    {
-      if ((p = strchr (s, ',')) != NULL)
-	b = p;
-      else
-	b = s + strlen (s);
-
-      while (isspace (b[-1]))
-	b--;
-      *b = '\0';
-      singlefont = gdk_font_load_internal (s);
-      if (singlefont)
-	{
-	  private->fonts = g_slist_append (private->fonts, singlefont);
-	  oldfont = SelectObject (_gdk_display_hdc, singlefont->hfont);
-	  GetTextMetrics (_gdk_display_hdc, &textmetric);
-	  SelectObject (_gdk_display_hdc, oldfont);
-	  font->ascent = MAX (font->ascent, textmetric.tmAscent);
-	  font->descent = MAX (font->descent, textmetric.tmDescent);
-	}
-      if (p)
-	{
-	  s = p + 1;
-	  while (*s && isspace (*s))
-	    s++;
-	}
-      else
-	break;
-      if (!*s)
-	break;
-    }
-  
-  g_free (fs);
-
-  gdk_font_hash_insert (GDK_FONT_FONTSET, font, fontset_name);
-
-  return font;
-}
-
-GdkFont*
-gdk_fontset_load_for_display (GdkDisplay  *display,
-			      const gchar *fontset_name)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-  
-  return gdk_fontset_load (fontset_name);
-}
-
-void
-_gdk_font_destroy (GdkFont *font)
-{
-  GdkFontPrivateWin32 *private = (GdkFontPrivateWin32 *) font;
-  GdkWin32SingleFont *singlefont;
-  GSList *list;
-
-  singlefont = (GdkWin32SingleFont *) private->fonts->data;
-  GDK_NOTE (MISC, g_print ("_gdk_font_destroy %p\n",
-			   singlefont->hfont));
-
-  gdk_font_hash_remove (font->type, font);
-  
-  switch (font->type)
-    {
-    case GDK_FONT_FONT:
-      DeleteObject (singlefont->hfont);
-      break;
-      
-    case GDK_FONT_FONTSET:
-      list = private->fonts;
-      while (list)
-	{
-	  singlefont = (GdkWin32SingleFont *) list->data;
-	  DeleteObject (singlefont->hfont);
-	  
-	  list = list->next;
-	}
-      g_slist_free (private->fonts);
-      break;
-    }
-  g_free (font);
-}
-
-gint
-_gdk_font_strlen (GdkFont     *font,
-		  const gchar *str)
-{
-  g_return_val_if_fail (font != NULL, -1);
-  g_return_val_if_fail (str != NULL, -1);
-
-  return strlen (str);
-}
-
-gint
-gdk_font_id (const GdkFont *font)
-{
-  const GdkFontPrivateWin32 *private;
-
-  g_return_val_if_fail (font != NULL, 0);
-
-  private = (const GdkFontPrivateWin32 *) font;
-
-  /* FIXME: What to do on Win64? */
-  if (font->type == GDK_FONT_FONT)
-    return (gint) (gintptr) ((GdkWin32SingleFont *) private->fonts->data)->hfont;
-  else
-    return 0;
-}
-
-gboolean
-gdk_font_equal (const GdkFont *fonta,
-                const GdkFont *fontb)
-{
-  const GdkFontPrivateWin32 *privatea;
-  const GdkFontPrivateWin32 *privateb;
-
-  g_return_val_if_fail (fonta != NULL, FALSE);
-  g_return_val_if_fail (fontb != NULL, FALSE);
-
-  privatea = (const GdkFontPrivateWin32 *) fonta;
-  privateb = (const GdkFontPrivateWin32 *) fontb;
-
-  if (fonta->type == GDK_FONT_FONT && fontb->type == GDK_FONT_FONT)
-    return (((GdkWin32SingleFont *) privatea->fonts->data)->hfont
-	    == ((GdkWin32SingleFont *) privateb->fonts->data)->hfont);
-  else if (fonta->type == GDK_FONT_FONTSET && fontb->type == GDK_FONT_FONTSET)
-    {
-      GSList *lista = privatea->fonts;
-      GSList *listb = privateb->fonts;
-
-      while (lista && listb)
-	{
-	  if (((GdkWin32SingleFont *) lista->data)->hfont
-	      != ((GdkWin32SingleFont *) listb->data)->hfont)
-	    return FALSE;
-	  lista = lista->next;
-	  listb = listb->next;
-	}
-      if (lista || listb)
-	return FALSE;
-      else
-	return TRUE;
-    }
-  else
-    return FALSE;
-}
-
-/* Return the Unicode Subset bitfield number for a Unicode character */
-
-static int
-unicode_classify (wchar_t wc)
-{
-  int min = 0;
-  int max = G_N_ELEMENTS (utab) - 1;
-  int mid;
-
-  while (max >= min)
-    {
-      mid = (min + max) / 2;
-      if (utab[mid].high < wc)
-	min = mid + 1;
-      else if (wc < utab[mid].low)
-	max = mid - 1;
-      else if (utab[mid].low <= wc && wc <= utab[mid].high)
-	return utab[mid].bit;
-      else
-	break;
-    }
-  /* Fallback... returning -1 might cause problems. Returning
-   * U_BASIC_LATIN won't help handling strange characters, but won't
-   * do harm either.
-   */
-  return U_BASIC_LATIN;
-}
-
-void
-_gdk_wchar_text_handle (GdkFont       *font,
-		       const wchar_t *wcstr,
-		       int            wclen,
-		       void         (*handler)(GdkWin32SingleFont *,
-					       const wchar_t *,
-					       int,
-					       void *),
-		       void          *arg)
-{
-  GdkFontPrivateWin32 *private;
-  GdkWin32SingleFont *singlefont;
-  GSList *list;
-  int  block;
-  const wchar_t *start, *end, *wcp;
-
-  wcp = wcstr;
-  end = wcp + wclen;
-  private = (GdkFontPrivateWin32 *) font;
-
-  g_assert (private->base.ref_count > 0);
-
-  GDK_NOTE (MISC, g_print ("_gdk_wchar_text_handle: "));
-
-  while (wcp < end)
-    {
-      /* Split Unicode string into pieces of the same class */
-      start = wcp;
-      block = unicode_classify (*wcp);
-      while (wcp + 1 < end && unicode_classify (wcp[1]) == block)
-	wcp++;
-
-      /* Find a font in the fontset that can handle this class */
-      list = private->fonts;
-      while (list)
-	{
-	  singlefont = (GdkWin32SingleFont *) list->data;
-	  
-	  if (singlefont->fs.fsUsb[block/32] & (1 << (block % 32)))
-	    break;
-
-	  list = list->next;
-	}
-
-      if (!list)
-	singlefont = NULL;
-
-      GDK_NOTE (MISC, g_print ("%" G_GSIZE_FORMAT ":%" G_GSIZE_FORMAT ":%d:%p ",
-			       start-wcstr, wcp-wcstr, block,
-			       (singlefont ? singlefont->hfont : 0)));
-
-      /* Call the callback function */
-      (*handler) (singlefont, start, wcp+1 - start, arg);
-      wcp++;
-    }
-  GDK_NOTE (MISC, g_print ("\n"));
-}
-
-typedef struct
-{
-  SIZE total;
-} gdk_text_size_arg;
-
-static void
-gdk_text_size_handler (GdkWin32SingleFont *singlefont,
-		       const wchar_t      *wcstr,
-		       int		   wclen,
-		       void		  *argp)
-{
-  SIZE this_size;
-  HGDIOBJ oldfont;
-  gdk_text_size_arg *arg = (gdk_text_size_arg *) argp;
-
-  if (!singlefont)
-    return;
-
-  if ((oldfont = SelectObject (_gdk_display_hdc, singlefont->hfont)) == NULL)
-    {
-      WIN32_GDI_FAILED ("SelectObject");
-      return;
-    }
-  GetTextExtentPoint32W (_gdk_display_hdc, wcstr, wclen, &this_size);
-  SelectObject (_gdk_display_hdc, oldfont);
-
-  arg->total.cx += this_size.cx;
-  arg->total.cy = MAX (arg->total.cy, this_size.cy);
-}
-
-gint
-gdk_text_width (GdkFont      *font,
-		const gchar  *text,
-		gint          text_length)
-{
-  gint width = -1;
-
-  gdk_text_extents (font, text, text_length, NULL, NULL, &width, NULL, NULL);
-
-  return width;
-}
-
-gint
-gdk_text_width_wc (GdkFont	  *font,
-		   const GdkWChar *text,
-		   gint		   text_length)
-{
-  gint width = -1;
-
-  gdk_text_extents_wc (font, text, text_length, NULL, NULL, &width, NULL, NULL);
-
-  return width;
-}
-
-void
-gdk_text_extents (GdkFont     *font,
-                  const gchar *text,
-                  gint         text_length,
-		  gint        *lbearing,
-		  gint        *rbearing,
-		  gint        *width,
-		  gint        *ascent,
-		  gint        *descent)
-{
-  gdk_text_size_arg arg;
-  glong wlen;
-  wchar_t *wcstr, wc;
-
-  g_return_if_fail (font != NULL);
-  g_return_if_fail (text != NULL);
-
-  if (text_length == 0)
-    {
-      if (lbearing)
-	*lbearing = 0;
-      if (rbearing)
-	*rbearing = 0;
-      if (width)
-	*width = 0;
-      if (ascent)
-	*ascent = 0;
-      if (descent)
-	*descent = 0;
-      return;
-    }
-
-  g_assert (font->type == GDK_FONT_FONT || font->type == GDK_FONT_FONTSET);
-
-  arg.total.cx = arg.total.cy = 0;
-
-  if (text_length == 1)
-    {
-      wc = (guchar) text[0];
-      _gdk_wchar_text_handle (font, &wc, 1, gdk_text_size_handler, &arg);
-    }
-  else
-    {
-      wcstr = g_utf8_to_utf16 (text, text_length, NULL, &wlen, NULL);
-      _gdk_wchar_text_handle (font, wcstr, wlen, gdk_text_size_handler, &arg);
-      g_free (wcstr);
-    }
-
-  /* XXX This is quite bogus */
-  if (lbearing)
-    *lbearing = 0;
-  if (rbearing)
-    *rbearing = arg.total.cx;
-  /* What should be the difference between width and rbearing? */
-  if (width)
-    *width = arg.total.cx;
-  if (ascent)
-    *ascent = arg.total.cy + 1;
-  if (descent)
-    *descent = font->descent + 1;
-}
-
-void
-gdk_text_extents_wc (GdkFont        *font,
-		     const GdkWChar *text,
-		     gint            text_length,
-		     gint           *lbearing,
-		     gint           *rbearing,
-		     gint           *width,
-		     gint           *ascent,
-		     gint           *descent)
-{
-  gdk_text_size_arg arg;
-  wchar_t *wcstr;
-  gint i;
-
-  g_return_if_fail (font != NULL);
-  g_return_if_fail (text != NULL);
-
-  if (text_length == 0)
-    {
-      if (lbearing)
-	*lbearing = 0;
-      if (rbearing)
-	*rbearing = 0;
-      if (width)
-	*width = 0;
-      if (ascent)
-	*ascent = 0;
-      if (descent)
-	*descent = 0;
-      return;
-    }
-
-  g_assert (font->type == GDK_FONT_FONT || font->type == GDK_FONT_FONTSET);
-
-  if (sizeof (wchar_t) != sizeof (GdkWChar))
-    {
-      wcstr = g_new (wchar_t, text_length);
-      for (i = 0; i < text_length; i++)
-	wcstr[i] = text[i];
-    }
-  else
-    wcstr = (wchar_t *) text;
-
-  arg.total.cx = arg.total.cy = 0;
-
-  _gdk_wchar_text_handle (font, wcstr, text_length,
-			 gdk_text_size_handler, &arg);
-
-  if (sizeof (wchar_t) != sizeof (GdkWChar))
-    g_free (wcstr);
-
-  /* XXX This is quite bogus */
-  if (lbearing)
-    *lbearing = 0;
-  if (rbearing)
-    *rbearing = arg.total.cx;
-  if (width)
-    *width = arg.total.cx;
-  if (ascent)
-    *ascent = arg.total.cy + 1;
-  if (descent)
-    *descent = font->descent + 1;
-}
-
-GdkDisplay* 
-gdk_font_get_display (GdkFont* font)
-{
-  return _gdk_display;
-}
diff --git a/gdk/win32/gdkgc-win32.c b/gdk/win32/gdkgc-win32.c
deleted file mode 100644
index e7e6fd8..0000000
--- a/gdk/win32/gdkgc-win32.c
+++ /dev/null
@@ -1,1153 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2004 Tor Lillqvist
- * Copyright (C) 2000-2004 Hans Breuer
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#define LINE_ATTRIBUTES (GDK_GC_LINE_WIDTH|GDK_GC_LINE_STYLE| \
-			 GDK_GC_CAP_STYLE|GDK_GC_JOIN_STYLE)
-
-#include "config.h"
-#include <string.h>
-
-#include "gdkgc.h"
-#include "gdkfont.h"
-#include "gdkpixmap.h"
-#include "gdkregion-generic.h"
-#include "gdkprivate-win32.h"
-
-static void gdk_win32_gc_get_values (GdkGC           *gc,
-				     GdkGCValues     *values);
-static void gdk_win32_gc_set_values (GdkGC           *gc,
-				     GdkGCValues     *values,
-				     GdkGCValuesMask  values_mask);
-static void gdk_win32_gc_set_dashes (GdkGC           *gc,
-				     gint             dash_offset,
-				     gint8            dash_list[],
-				     gint             n);
-
-static void gdk_gc_win32_class_init (GdkGCWin32Class *klass);
-static void gdk_gc_win32_finalize   (GObject         *object);
-
-static gpointer parent_class = NULL;
-
-GType
-_gdk_gc_win32_get_type (void)
-{
-  static GType object_type = 0;
-
-  if (!object_type)
-    {
-      const GTypeInfo object_info =
-      {
-        sizeof (GdkGCWin32Class),
-        (GBaseInitFunc) NULL,
-        (GBaseFinalizeFunc) NULL,
-        (GClassInitFunc) gdk_gc_win32_class_init,
-        NULL,           /* class_finalize */
-        NULL,           /* class_data */
-        sizeof (GdkGCWin32),
-        0,              /* n_preallocs */
-        (GInstanceInitFunc) NULL,
-      };
-      
-      object_type = g_type_register_static (GDK_TYPE_GC,
-                                            "GdkGCWin32",
-                                            &object_info, 0);
-    }
-  
-  return object_type;
-}
-
-static void
-gdk_gc_win32_class_init (GdkGCWin32Class *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GdkGCClass *gc_class = GDK_GC_CLASS (klass);
-  
-  parent_class = g_type_class_peek_parent (klass);
-
-  object_class->finalize = gdk_gc_win32_finalize;
-
-  gc_class->get_values = gdk_win32_gc_get_values;
-  gc_class->set_values = gdk_win32_gc_set_values;
-  gc_class->set_dashes = gdk_win32_gc_set_dashes;
-}
-
-static void
-gdk_gc_win32_finalize (GObject *object)
-{
-  GdkGCWin32 *win32_gc = GDK_GC_WIN32 (object);
-  
-  if (win32_gc->hcliprgn != NULL)
-    DeleteObject (win32_gc->hcliprgn);
-  
-  if (win32_gc->values_mask & GDK_GC_FONT)
-    gdk_font_unref (win32_gc->font);
-  
-  g_free (win32_gc->pen_dashes);
-  
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-static void
-fixup_pen (GdkGCWin32 *win32_gc)
-{
-  win32_gc->pen_style = 0;
-
-  /* First look at GDK width and end cap style, set GDI pen type and
-   * end cap.
-   */
-  if (win32_gc->pen_width == 0 &&
-      win32_gc->cap_style == GDK_CAP_NOT_LAST)
-    {
-      /* Use a cosmetic pen, always width 1 */
-      win32_gc->pen_style |= PS_COSMETIC;
-    }
-  else if (win32_gc->pen_width <= 1 &&
-	   win32_gc->cap_style == GDK_CAP_BUTT)
-    {
-      /* For 1 pixel wide lines PS_ENDCAP_ROUND means draw both ends,
-       * even for one pixel length lines. But if we are drawing dashed
-       * lines we can't use PS_ENDCAP_ROUND.
-       */
-      if (win32_gc->line_style == GDK_LINE_SOLID)
-	win32_gc->pen_style |= PS_GEOMETRIC | PS_ENDCAP_ROUND;
-      else
-	win32_gc->pen_style |= PS_GEOMETRIC | PS_ENDCAP_FLAT;
-    }
-  else
-    {
-      win32_gc->pen_style |= PS_GEOMETRIC;
-      switch (win32_gc->cap_style)
-	{
-	/* For non-zero-width lines X11's CapNotLast works like CapButt */
-	case GDK_CAP_NOT_LAST:
-	case GDK_CAP_BUTT:
-	  win32_gc->pen_style |= PS_ENDCAP_FLAT;
-	  break;
-	case GDK_CAP_ROUND:
-	  win32_gc->pen_style |= PS_ENDCAP_ROUND;
-	  break;
-	case GDK_CAP_PROJECTING:
-	  win32_gc->pen_style |= PS_ENDCAP_SQUARE;
-	  break;
-	}
-    }
-
-  /* Next look at GDK line style, set GDI pen style attribute */
-  switch (win32_gc->line_style)
-    {
-    case GDK_LINE_SOLID:
-      win32_gc->pen_style |= PS_SOLID;
-      break;
-    case GDK_LINE_ON_OFF_DASH:
-    case GDK_LINE_DOUBLE_DASH:
-      if (win32_gc->pen_dashes == NULL)
-	{
-	  win32_gc->pen_dashes = g_new (DWORD, 1);
-	  win32_gc->pen_dashes[0] = 4;
-	  win32_gc->pen_num_dashes = 1;
-	}
-
-      if (!(win32_gc->pen_style & PS_TYPE_MASK) == PS_GEOMETRIC &&
-	  win32_gc->pen_dashes[0] == 1 &&
-	  (win32_gc->pen_num_dashes == 1 ||
-	   (win32_gc->pen_num_dashes == 2 && win32_gc->pen_dashes[0] == 1)))
-	win32_gc->pen_style |= PS_ALTERNATE;
-      else
-	win32_gc->pen_style |= PS_USERSTYLE;
-     break;
-    }
-
-  /* Last, for if the GDI pen is geometric, set the join attribute */
-  if ((win32_gc->pen_style & PS_TYPE_MASK) == PS_GEOMETRIC)
-    {
-      switch (win32_gc->join_style)
-	{
-	case GDK_JOIN_MITER:
-	  win32_gc->pen_style |= PS_JOIN_MITER;
-	  break;
-	case GDK_JOIN_ROUND:
-	  win32_gc->pen_style |= PS_JOIN_ROUND;
-	  break;
-	case GDK_JOIN_BEVEL:
-	  win32_gc->pen_style |= PS_JOIN_BEVEL;
-	  break;
-	}
-    }
-}
-
-static void
-gdk_win32_gc_values_to_win32values (GdkGCValues    *values,
-				    GdkGCValuesMask mask,
-				    GdkGCWin32     *win32_gc)
-{				    
-#ifdef G_ENABLE_DEBUG
-  char *s = "";
-#endif
-
-  GDK_NOTE (GC, g_print ("{"));
-
-  if (mask & GDK_GC_FOREGROUND)
-    {
-      win32_gc->values_mask |= GDK_GC_FOREGROUND;
-      GDK_NOTE (GC, (g_print ("fg=%.06x",
-			      _gdk_gc_get_fg_pixel (&win32_gc->parent_instance)),
-		     s = ","));
-    }
-  
-  if (mask & GDK_GC_BACKGROUND)
-    {
-      win32_gc->values_mask |= GDK_GC_BACKGROUND;
-      GDK_NOTE (GC, (g_print ("%sbg=%.06x", s,
-			      _gdk_gc_get_bg_pixel (&win32_gc->parent_instance)),
-		     s = ","));
-    }
-
-  if ((mask & GDK_GC_FONT) && (values->font->type == GDK_FONT_FONT
-			       || values->font->type == GDK_FONT_FONTSET))
-    {
-      if (win32_gc->font != NULL)
-	gdk_font_unref (win32_gc->font);
-      win32_gc->font = values->font;
-      if (win32_gc->font != NULL)
-	{
-	  gdk_font_ref (win32_gc->font);
-	  win32_gc->values_mask |= GDK_GC_FONT;
-	  GDK_NOTE (GC, (g_print ("%sfont=%p", s, win32_gc->font),
-			 s = ","));
-	}
-      else
-	{
-	  win32_gc->values_mask &= ~GDK_GC_FONT;
-	  GDK_NOTE (GC, (g_print ("%sfont=NULL", s),
-			 s = ","));
-	}
-    }
-
-  if (mask & GDK_GC_FUNCTION)
-    {
-      GDK_NOTE (GC, (g_print ("%srop2=", s),
-		     s = ","));
-      switch (values->function)
-	{
-#define CASE(x,y) case GDK_##x: win32_gc->rop2 = R2_##y; GDK_NOTE (GC, g_print (#y)); break
-	CASE (COPY, COPYPEN);
-	CASE (INVERT, NOT);
-	CASE (XOR, XORPEN);
-	CASE (CLEAR, BLACK);
-	CASE (AND, MASKPEN);
-	CASE (AND_REVERSE, MASKPENNOT);
-	CASE (AND_INVERT, MASKNOTPEN);
-	CASE (NOOP, NOP);
-	CASE (OR, MERGEPEN);
-	CASE (EQUIV, NOTXORPEN);
-	CASE (OR_REVERSE, MERGEPENNOT);
-	CASE (COPY_INVERT, NOTCOPYPEN);
-	CASE (OR_INVERT, MERGENOTPEN);
-	CASE (NAND, NOTMASKPEN);
-	CASE (NOR, NOTMERGEPEN);
-	CASE (SET, WHITE);
-#undef CASE
-	}
-      win32_gc->values_mask |= GDK_GC_FUNCTION;
-    }
-
-  if (mask & GDK_GC_FILL)
-    {
-      win32_gc->values_mask |= GDK_GC_FILL;
-      GDK_NOTE (GC, (g_print ("%sfill=%s", s,
-			      _gdk_win32_fill_style_to_string (values->fill)),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_TILE)
-    {
-      if (values->tile != NULL)
-	{
-	  win32_gc->values_mask |= GDK_GC_TILE;
-	  GDK_NOTE (GC,
-		    (g_print ("%stile=%p", s,
-			      GDK_PIXMAP_HBITMAP (values->tile)),
-		     s = ","));
-	}
-      else
-	{
-	  win32_gc->values_mask &= ~GDK_GC_TILE;
-	  GDK_NOTE (GC, (g_print ("%stile=NULL", s),
-			 s = ","));
-	}
-    }
-
-  if (mask & GDK_GC_STIPPLE)
-    {
-      if (values->stipple != NULL)
-	{
-	  win32_gc->values_mask |= GDK_GC_STIPPLE;
-	  GDK_NOTE (GC,
-		    (g_print ("%sstipple=%p", s,
-			      GDK_PIXMAP_HBITMAP (values->stipple)),
-		     s = ","));
-	}
-      else
-	{
-	  win32_gc->values_mask &= ~GDK_GC_STIPPLE;
-	  GDK_NOTE (GC, (g_print ("%sstipple=NULL", s),
-			 s = ","));
-	}
-    }
-
-  if (mask & GDK_GC_CLIP_MASK)
-    {
-      if (win32_gc->hcliprgn != NULL)
-	DeleteObject (win32_gc->hcliprgn);
-
-      if (values->clip_mask != NULL)
-	{
-	  win32_gc->hcliprgn = _gdk_win32_bitmap_to_hrgn (values->clip_mask);
-	  win32_gc->values_mask |= GDK_GC_CLIP_MASK;
-	}
-      else
-	{
-	  win32_gc->hcliprgn = NULL;
-	  win32_gc->values_mask &= ~GDK_GC_CLIP_MASK;
-	}
-      GDK_NOTE (GC, (g_print ("%sclip=%p", s, win32_gc->hcliprgn),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_SUBWINDOW)
-    {
-      win32_gc->subwindow_mode = values->subwindow_mode;
-      win32_gc->values_mask |= GDK_GC_SUBWINDOW;
-      GDK_NOTE (GC, (g_print ("%ssubw=%d", s, win32_gc->subwindow_mode),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_TS_X_ORIGIN)
-    {
-      win32_gc->values_mask |= GDK_GC_TS_X_ORIGIN;
-      GDK_NOTE (GC, (g_print ("%sts_x=%d", s, values->ts_x_origin),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_TS_Y_ORIGIN)
-    {
-      win32_gc->values_mask |= GDK_GC_TS_Y_ORIGIN;
-      GDK_NOTE (GC, (g_print ("%sts_y=%d", s, values->ts_y_origin),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_CLIP_X_ORIGIN)
-    {
-      win32_gc->values_mask |= GDK_GC_CLIP_X_ORIGIN;
-      GDK_NOTE (GC, (g_print ("%sclip_x=%d", s, values->clip_x_origin),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_CLIP_Y_ORIGIN)
-    {
-      win32_gc->values_mask |= GDK_GC_CLIP_Y_ORIGIN;
-      GDK_NOTE (GC, (g_print ("%sclip_y=%d", s, values->clip_y_origin),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_EXPOSURES)
-    {
-      win32_gc->graphics_exposures = values->graphics_exposures;
-      win32_gc->values_mask |= GDK_GC_EXPOSURES;
-      GDK_NOTE (GC, (g_print ("%sexp=%d", s, win32_gc->graphics_exposures),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_LINE_WIDTH)
-    {
-      win32_gc->pen_width = values->line_width;
-      win32_gc->values_mask |= GDK_GC_LINE_WIDTH;
-      GDK_NOTE (GC, (g_print ("%spw=%d", s, win32_gc->pen_width),
-		     s = ","));
-    }
-
-  if (mask & GDK_GC_LINE_STYLE)
-    {
-      win32_gc->line_style = values->line_style;
-      win32_gc->values_mask |= GDK_GC_LINE_STYLE;
-    }
-
-  if (mask & GDK_GC_CAP_STYLE)
-    {
-      win32_gc->cap_style = values->cap_style;
-      win32_gc->values_mask |= GDK_GC_CAP_STYLE;
-    }
-
-  if (mask & GDK_GC_JOIN_STYLE)
-    {
-      win32_gc->join_style = values->join_style;
-      win32_gc->values_mask |= GDK_GC_JOIN_STYLE;
-    }
-
-  if (mask & (GDK_GC_LINE_WIDTH|GDK_GC_LINE_STYLE|GDK_GC_CAP_STYLE|GDK_GC_JOIN_STYLE))
-    {
-      fixup_pen (win32_gc);
-      GDK_NOTE (GC, (g_print ("%sps|=PS_STYLE_%s|PS_ENDCAP_%s|PS_JOIN_%s", s,
-			      _gdk_win32_psstyle_to_string (win32_gc->pen_style),
-			      _gdk_win32_psendcap_to_string (win32_gc->pen_style),
-			      _gdk_win32_psjoin_to_string (win32_gc->pen_style)),
-		     s = ","));
-    }
-
-  GDK_NOTE (GC, g_print ("} mask=(%s)", _gdk_win32_gcvalues_mask_to_string (win32_gc->values_mask)));
-}
-
-GdkGC*
-_gdk_win32_gc_new (GdkDrawable	  *drawable,
-		   GdkGCValues	  *values,
-		   GdkGCValuesMask values_mask)
-{
-  GdkGC *gc;
-  GdkGCWin32 *win32_gc;
-
-  /* NOTICE that the drawable here has to be the impl drawable,
-   * not the publically-visible drawables.
-   */
-  g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_WIN32 (drawable), NULL);
-
-  gc = g_object_new (_gdk_gc_win32_get_type (), NULL);
-  win32_gc = GDK_GC_WIN32 (gc);
-
-  _gdk_gc_init (gc, drawable, values, values_mask);
-
-  win32_gc->hcliprgn = NULL;
-
-  win32_gc->font = NULL;
-  win32_gc->rop2 = R2_COPYPEN;
-  win32_gc->subwindow_mode = GDK_CLIP_BY_CHILDREN;
-  win32_gc->graphics_exposures = TRUE;
-  win32_gc->pen_width = 0;
-  /* Don't get confused by the PS_ENDCAP_ROUND. For narrow GDI pens
-   * (width == 1), PS_GEOMETRIC|PS_ENDCAP_ROUND works like X11's
-   * CapButt.
-   */
-  win32_gc->pen_style = PS_GEOMETRIC|PS_ENDCAP_ROUND|PS_JOIN_MITER;
-  win32_gc->line_style = GDK_LINE_SOLID;
-  win32_gc->cap_style = GDK_CAP_BUTT;
-  win32_gc->join_style = GDK_JOIN_MITER;
-  win32_gc->pen_dashes = NULL;
-  win32_gc->pen_num_dashes = 0;
-  win32_gc->pen_dash_offset = 0;
-  win32_gc->pen_hbrbg = NULL;
-
-  win32_gc->values_mask = GDK_GC_FUNCTION | GDK_GC_FILL;
-
-  GDK_NOTE (GC, g_print ("_gdk_win32_gc_new: %p: ", win32_gc));
-  gdk_win32_gc_values_to_win32values (values, values_mask, win32_gc);
-  GDK_NOTE (GC, g_print ("\n"));
-
-  win32_gc->hdc = NULL;
-
-  return gc;
-}
-
-static void
-gdk_win32_gc_get_values (GdkGC       *gc,
-			 GdkGCValues *values)
-{
-  GdkGCWin32 *win32_gc = GDK_GC_WIN32 (gc);
-
-  values->foreground.pixel = _gdk_gc_get_fg_pixel (gc);
-  values->background.pixel = _gdk_gc_get_bg_pixel (gc);
-  values->font = win32_gc->font;
-
-  switch (win32_gc->rop2)
-    {
-    case R2_COPYPEN:
-      values->function = GDK_COPY; break;
-    case R2_NOT:
-      values->function = GDK_INVERT; break;
-    case R2_XORPEN:
-      values->function = GDK_XOR; break;
-    case R2_BLACK:
-      values->function = GDK_CLEAR; break;
-    case R2_MASKPEN:
-      values->function = GDK_AND; break;
-    case R2_MASKPENNOT:
-      values->function = GDK_AND_REVERSE; break;
-    case R2_MASKNOTPEN:
-      values->function = GDK_AND_INVERT; break;
-    case R2_NOP:
-      values->function = GDK_NOOP; break;
-    case R2_MERGEPEN:
-      values->function = GDK_OR; break;
-    case R2_NOTXORPEN:
-      values->function = GDK_EQUIV; break;
-    case R2_MERGEPENNOT:
-      values->function = GDK_OR_REVERSE; break;
-    case R2_NOTCOPYPEN:
-      values->function = GDK_COPY_INVERT; break;
-    case R2_MERGENOTPEN:
-      values->function = GDK_OR_INVERT; break;
-    case R2_NOTMASKPEN:
-      values->function = GDK_NAND; break;
-    case R2_NOTMERGEPEN:
-      values->function = GDK_NOR; break;
-    case R2_WHITE:
-      values->function = GDK_SET; break;
-    }
-
-  values->fill = _gdk_gc_get_fill (gc);
-  values->tile = _gdk_gc_get_tile (gc);
-  values->stipple = _gdk_gc_get_stipple (gc);
-
-  /* Also the X11 backend always returns a NULL clip_mask */
-  values->clip_mask = NULL;
-
-  values->subwindow_mode = win32_gc->subwindow_mode;
-  values->ts_x_origin = win32_gc->parent_instance.ts_x_origin;
-  values->ts_y_origin = win32_gc->parent_instance.ts_y_origin;
-  values->clip_x_origin = win32_gc->parent_instance.clip_x_origin;
-  values->clip_y_origin = win32_gc->parent_instance.clip_y_origin;
-  values->graphics_exposures = win32_gc->graphics_exposures;
-  values->line_width = win32_gc->pen_width;
-  
-  values->line_style = win32_gc->line_style;
-  values->cap_style = win32_gc->cap_style;
-  values->join_style = win32_gc->join_style;
-}
-
-static void
-gdk_win32_gc_set_values (GdkGC           *gc,
-			 GdkGCValues     *values,
-			 GdkGCValuesMask  mask)
-{
-  g_return_if_fail (GDK_IS_GC (gc));
-
-  GDK_NOTE (GC, g_print ("gdk_win32_gc_set_values: %p: ", GDK_GC_WIN32 (gc)));
-  gdk_win32_gc_values_to_win32values (values, mask, GDK_GC_WIN32 (gc));
-  GDK_NOTE (GC, g_print ("\n"));
-}
-
-static void
-gdk_win32_gc_set_dashes (GdkGC *gc,
-			 gint	dash_offset,
-			 gint8  dash_list[],
-			 gint   n)
-{
-  GdkGCWin32 *win32_gc;
-  int i;
-
-  g_return_if_fail (GDK_IS_GC (gc));
-  g_return_if_fail (dash_list != NULL);
-
-  win32_gc = GDK_GC_WIN32 (gc);
-
-  win32_gc->pen_num_dashes = n;
-  g_free (win32_gc->pen_dashes);
-  win32_gc->pen_dashes = g_new (DWORD, n);
-  for (i = 0; i < n; i++)
-    win32_gc->pen_dashes[i] = dash_list[i];
-  win32_gc->pen_dash_offset = dash_offset;
-  fixup_pen (win32_gc);
-}
-
-void
-_gdk_windowing_gc_set_clip_region (GdkGC           *gc,
-                                   const GdkRegion *region,
-				   gboolean         reset_origin)
-{
-  GdkGCWin32 *win32_gc = GDK_GC_WIN32 (gc);
-
-  if (win32_gc->hcliprgn)
-    DeleteObject (win32_gc->hcliprgn);
-
-  if (region)
-    {
-      GDK_NOTE (GC, g_print ("gdk_gc_set_clip_region: %p: %s\n",
-			     win32_gc,
-			     _gdk_win32_gdkregion_to_string (region)));
-
-      win32_gc->hcliprgn = _gdk_win32_gdkregion_to_hrgn (region, 0, 0);
-      win32_gc->values_mask |= GDK_GC_CLIP_MASK;
-    }
-  else
-    {
-      GDK_NOTE (GC, g_print ("gdk_gc_set_clip_region: NULL\n"));
-
-      win32_gc->hcliprgn = NULL;
-      win32_gc->values_mask &= ~GDK_GC_CLIP_MASK;
-    }
-
-  if (reset_origin)
-    {
-      gc->clip_x_origin = 0;
-      gc->clip_y_origin = 0;
-      win32_gc->values_mask &= ~(GDK_GC_CLIP_X_ORIGIN | GDK_GC_CLIP_Y_ORIGIN);
-    }
-}
-
-void
-_gdk_windowing_gc_copy (GdkGC *dst_gc,
-			GdkGC *src_gc)
-{
-  GdkGCWin32 *dst_win32_gc = GDK_GC_WIN32 (dst_gc);
-  GdkGCWin32 *src_win32_gc = GDK_GC_WIN32 (src_gc);
-
-  GDK_NOTE (GC, g_print ("gdk_gc_copy: %p := %p\n", dst_win32_gc, src_win32_gc));
-
-  if (dst_win32_gc->hcliprgn != NULL)
-    DeleteObject (dst_win32_gc->hcliprgn);
-
-  if (dst_win32_gc->font != NULL)
-    gdk_font_unref (dst_win32_gc->font);
-
-  g_free (dst_win32_gc->pen_dashes);
-  
-  dst_win32_gc->hcliprgn = src_win32_gc->hcliprgn;
-  if (dst_win32_gc->hcliprgn)
-    {
-      /* create a new region, to copy to */
-      dst_win32_gc->hcliprgn = CreateRectRgn (0,0,1,1);
-      /* overwrite from source */
-      CombineRgn (dst_win32_gc->hcliprgn, src_win32_gc->hcliprgn,
-		  NULL, RGN_COPY);
-    }
-
-  dst_win32_gc->values_mask = src_win32_gc->values_mask; 
-  dst_win32_gc->font = src_win32_gc->font;
-  if (dst_win32_gc->font != NULL)
-    gdk_font_ref (dst_win32_gc->font);
-
-  dst_win32_gc->rop2 = src_win32_gc->rop2;
-
-  dst_win32_gc->subwindow_mode = src_win32_gc->subwindow_mode;
-  dst_win32_gc->graphics_exposures = src_win32_gc->graphics_exposures;
-  dst_win32_gc->pen_width = src_win32_gc->pen_width;
-  dst_win32_gc->pen_style = src_win32_gc->pen_style;
-  dst_win32_gc->line_style = src_win32_gc->line_style;
-  dst_win32_gc->cap_style = src_win32_gc->cap_style;
-  dst_win32_gc->join_style = src_win32_gc->join_style;
-  if (src_win32_gc->pen_dashes)
-    dst_win32_gc->pen_dashes = g_memdup (src_win32_gc->pen_dashes, 
-                                         sizeof (DWORD) * src_win32_gc->pen_num_dashes);
-  else
-    dst_win32_gc->pen_dashes = NULL;
-  dst_win32_gc->pen_num_dashes = src_win32_gc->pen_num_dashes;
-  dst_win32_gc->pen_dash_offset = src_win32_gc->pen_dash_offset;
-
-
-  dst_win32_gc->hdc = NULL;
-  dst_win32_gc->saved_dc = FALSE;
-  dst_win32_gc->holdpal = NULL;
-  dst_win32_gc->pen_hbrbg = NULL;
-}
-
-GdkScreen *  
-gdk_gc_get_screen (GdkGC *gc)
-{
-  g_return_val_if_fail (GDK_IS_GC_WIN32 (gc), NULL);
-  
-  return _gdk_screen;
-}
-
-static guint bitmask[9] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };
-
-COLORREF
-_gdk_win32_colormap_color (GdkColormap *colormap,
-                           gulong       pixel)
-{
-  const GdkVisual *visual;
-  GdkColormapPrivateWin32 *colormap_private;
-  guchar r, g, b;
-
-  if (colormap == NULL)
-    return DIBINDEX (pixel & 1);
-
-  colormap_private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-  g_assert (colormap_private != NULL);
-
-  visual = colormap->visual;
-  switch (visual->type)
-    {
-    case GDK_VISUAL_GRAYSCALE:
-    case GDK_VISUAL_PSEUDO_COLOR:
-    case GDK_VISUAL_STATIC_COLOR:
-      return PALETTEINDEX (pixel);
-
-    case GDK_VISUAL_TRUE_COLOR:
-      r = (pixel & visual->red_mask) >> visual->red_shift;
-      r = (r * 255) / bitmask[visual->red_prec];
-      g = (pixel & visual->green_mask) >> visual->green_shift;
-      g = (g * 255) / bitmask[visual->green_prec];
-      b = (pixel & visual->blue_mask) >> visual->blue_shift;
-      b = (b * 255) / bitmask[visual->blue_prec];
-      return RGB (r, g, b);
-
-    default:
-      g_assert_not_reached ();
-      return 0;
-    }
-}
-
-gboolean
-predraw (GdkGC       *gc,
-	 GdkColormap *colormap)
-{
-  GdkGCWin32 *win32_gc = (GdkGCWin32 *) gc;
-  GdkColormapPrivateWin32 *colormap_private;
-  gint k;
-  gboolean ok = TRUE;
-
-  if (colormap &&
-      (colormap->visual->type == GDK_VISUAL_PSEUDO_COLOR ||
-       colormap->visual->type == GDK_VISUAL_STATIC_COLOR))
-    {
-      colormap_private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-      g_assert (colormap_private != NULL);
-
-      if (!(win32_gc->holdpal = SelectPalette (win32_gc->hdc, colormap_private->hpal, FALSE)))
-	WIN32_GDI_FAILED ("SelectPalette"), ok = FALSE;
-      else if ((k = RealizePalette (win32_gc->hdc)) == GDI_ERROR)
-	WIN32_GDI_FAILED ("RealizePalette"), ok = FALSE;
-      else if (k > 0)
-	GDK_NOTE (COLORMAP, g_print ("predraw: realized %p: %d colors\n",
-				     colormap_private->hpal, k));
-    }
-
-  return ok;
-}
-
-static GdkDrawableImplWin32 *
-get_impl_drawable (GdkDrawable *drawable)
-{
-  if (GDK_IS_OFFSCREEN_WINDOW (drawable))
-    return _gdk_offscreen_window_get_real_drawable (GDK_OFFSCREEN_WINDOW (drawable));
-  if (GDK_IS_DRAWABLE_IMPL_WIN32 (drawable))
-    return GDK_DRAWABLE_IMPL_WIN32(drawable);
-  else if (GDK_IS_WINDOW (drawable))
-    return GDK_DRAWABLE_IMPL_WIN32 ((GDK_WINDOW_OBJECT (drawable))->impl);
-  else if (GDK_IS_PIXMAP (drawable))
-    return GDK_DRAWABLE_IMPL_WIN32 ((GDK_PIXMAP_OBJECT (drawable))->impl);
-  else
-    g_assert_not_reached ();
-
-  return NULL;
-}
-
-/**
- * gdk_win32_hdc_get:
- * @drawable: destination #GdkDrawable
- * @gc: #GdkGC to use for drawing on @drawable
- * @usage: mask indicating what properties needs to be set up
- *
- * Allocates a Windows device context handle (HDC) for drawing into
- * @drawable, and sets it up appropriately according to @usage.
- *
- * Each #GdkGC can at one time have only one HDC associated with it.
- *
- * The following flags in @mask are handled:
- *
- * If %GDK_GC_FOREGROUND is set in @mask, a solid brush of the
- * foreground color in @gc is selected into the HDC. The text color of
- * the HDC is also set. If the @drawable has a palette (256-color
- * mode), the palette is selected and realized.
- *
- * If any of the line attribute flags (%GDK_GC_LINE_WIDTH,
- * %GDK_GC_LINE_STYLE, %GDK_GC_CAP_STYLE and %GDK_GC_JOIN_STYLE) is
- * set in @mask, a solid pen of the foreground color and appropriate
- * width and stule is created and selected into the HDC. Note that the
- * dash properties are not completely implemented.
- *
- * If the %GDK_GC_FONT flag is set, the background mix mode is set to
- * %TRANSPARENT. and the text alignment is set to
- * %TA_BASELINE|%TA_LEFT. Note that no font gets selected into the HDC
- * by this function.
- *
- * Some things are done regardless of @mask: If the function in @gc is
- * any other than %GDK_COPY, the raster operation of the HDC is
- * set. If @gc has a clip mask, the clip region of the HDC is set.
- *
- * Note that the fill style, tile, stipple, and tile and stipple
- * origins in the @gc are ignored by this function. (In general, tiles
- * and stipples can't be implemented directly on Win32; you need to do
- * multiple pass drawing and blitting to implement tiles or
- * stipples. GDK does just that when you call the GDK drawing
- * functions with a GC that asks for tiles or stipples.)
- *
- * When the HDC is no longer used, it should be released by calling
- * <function>gdk_win32_hdc_release()</function> with the same
- * parameters.
- *
- * If you modify the HDC by calling <function>SelectObject</function>
- * you should undo those modifications before calling
- * <function>gdk_win32_hdc_release()</function>.
- *
- * Return value: The HDC.
- **/
-HDC
-gdk_win32_hdc_get (GdkDrawable    *drawable,
-		   GdkGC          *gc,
-		   GdkGCValuesMask usage)
-{
-  GdkGCWin32 *win32_gc = (GdkGCWin32 *) gc;
-  GdkDrawableImplWin32 *impl = NULL;
-  gboolean ok = TRUE;
-  COLORREF fg = RGB (0, 0, 0), bg = RGB (255, 255, 255);
-  HPEN hpen;
-  HBRUSH hbr;
-
-  g_assert (win32_gc->hdc == NULL);
-
-  impl = get_impl_drawable (drawable);
-  
-  win32_gc->hdc = _gdk_win32_drawable_acquire_dc (GDK_DRAWABLE (impl));
-  ok = win32_gc->hdc != NULL;
-
-  if (ok && (win32_gc->saved_dc = SaveDC (win32_gc->hdc)) == 0)
-    WIN32_GDI_FAILED ("SaveDC"), ok = FALSE;
-      
-  if (ok && (usage & (GDK_GC_FOREGROUND | GDK_GC_BACKGROUND)))
-      ok = predraw (gc, impl->colormap);
-
-  if (ok && (usage & GDK_GC_FOREGROUND))
-    {
-      fg = _gdk_win32_colormap_color (impl->colormap, _gdk_gc_get_fg_pixel (gc));
-      if ((hbr = CreateSolidBrush (fg)) == NULL)
-	WIN32_GDI_FAILED ("CreateSolidBrush"), ok = FALSE;
-
-      if (ok && SelectObject (win32_gc->hdc, hbr) == NULL)
-	WIN32_GDI_FAILED ("SelectObject"), ok = FALSE;
-
-      if (ok && SetTextColor (win32_gc->hdc, fg) == CLR_INVALID)
-	WIN32_GDI_FAILED ("SetTextColor"), ok = FALSE;
-    }
-
-  if (ok && (usage & LINE_ATTRIBUTES))
-    {
-      /* For drawing GDK_LINE_DOUBLE_DASH */
-      if ((usage & GDK_GC_BACKGROUND) && win32_gc->line_style == GDK_LINE_DOUBLE_DASH)
-        {
-          bg = _gdk_win32_colormap_color (impl->colormap, _gdk_gc_get_bg_pixel (gc));
-          if ((win32_gc->pen_hbrbg = CreateSolidBrush (bg)) == NULL)
-	    WIN32_GDI_FAILED ("CreateSolidBrush"), ok = FALSE;
-        }
-
-      if (ok)
-        {
-	  LOGBRUSH logbrush;
-	  DWORD style_count = 0;
-	  const DWORD *style = NULL;
-
-	  /* Create and select pen */
-	  logbrush.lbStyle = BS_SOLID;
-	  logbrush.lbColor = fg;
-	  logbrush.lbHatch = 0;
-
-	  if ((win32_gc->pen_style & PS_STYLE_MASK) == PS_USERSTYLE)
-	    {
-	      style_count = win32_gc->pen_num_dashes;
-	      style = win32_gc->pen_dashes;
-	    }
-
-	  if ((hpen = ExtCreatePen (win32_gc->pen_style,
-				    MAX (win32_gc->pen_width, 1),
-				    &logbrush, 
-				    style_count, style)) == NULL)
-	    WIN32_GDI_FAILED ("ExtCreatePen"), ok = FALSE;
-	  
-	  if (ok && SelectObject (win32_gc->hdc, hpen) == NULL)
-	    WIN32_GDI_FAILED ("SelectObject"), ok = FALSE;
-	}
-    }
-
-  if (ok && (usage & GDK_GC_FONT))
-    {
-      if (SetBkMode (win32_gc->hdc, TRANSPARENT) == 0)
-	WIN32_GDI_FAILED ("SetBkMode"), ok = FALSE;
-  
-      if (ok && SetTextAlign (win32_gc->hdc, TA_BASELINE|TA_LEFT|TA_NOUPDATECP) == GDI_ERROR)
-	WIN32_GDI_FAILED ("SetTextAlign"), ok = FALSE;
-    }
-  
-  if (ok && win32_gc->rop2 != R2_COPYPEN)
-    if (SetROP2 (win32_gc->hdc, win32_gc->rop2) == 0)
-      WIN32_GDI_FAILED ("SetROP2"), ok = FALSE;
-
-  if (ok &&
-      (win32_gc->values_mask & GDK_GC_CLIP_MASK) &&
-      win32_gc->hcliprgn != NULL)
-    {
-      if (SelectClipRgn (win32_gc->hdc, win32_gc->hcliprgn) == ERROR)
-	WIN32_API_FAILED ("SelectClipRgn"), ok = FALSE;
-
-      if (ok && win32_gc->values_mask & (GDK_GC_CLIP_X_ORIGIN | GDK_GC_CLIP_Y_ORIGIN) &&
-	  OffsetClipRgn (win32_gc->hdc,
-	    win32_gc->values_mask & GDK_GC_CLIP_X_ORIGIN ? gc->clip_x_origin : 0,
-	    win32_gc->values_mask & GDK_GC_CLIP_Y_ORIGIN ? gc->clip_y_origin : 0) == ERROR)
-	WIN32_API_FAILED ("OffsetClipRgn"), ok = FALSE;
-    }
-  else if (ok)
-    SelectClipRgn (win32_gc->hdc, NULL);
-
-  GDK_NOTE (GC, (g_print ("gdk_win32_hdc_get: %p (%s): ",
-			  win32_gc, _gdk_win32_gcvalues_mask_to_string (usage)),
-		 _gdk_win32_print_dc (win32_gc->hdc)));
-
-  return win32_gc->hdc;
-}
-
-/**
- * gdk_win32_hdc_release:
- * @drawable: destination #GdkDrawable
- * @gc: #GdkGC to use for drawing on @drawable
- * @usage: mask indicating what properties were set up
- *
- * This function deallocates the Windows device context allocated by
- * <funcion>gdk_win32_hdc_get()</function>. It should be called with
- * the same parameters.
- **/
-void
-gdk_win32_hdc_release (GdkDrawable    *drawable,
-		       GdkGC          *gc,
-		       GdkGCValuesMask usage)
-{
-  GdkGCWin32 *win32_gc = (GdkGCWin32 *) gc;
-  GdkDrawableImplWin32 *impl = NULL;
-  HGDIOBJ hpen = NULL;
-  HGDIOBJ hbr = NULL;
-
-  GDK_NOTE (GC, g_print ("gdk_win32_hdc_release: %p: %p (%s)\n",
-			 win32_gc, win32_gc->hdc,
-			 _gdk_win32_gcvalues_mask_to_string (usage)));
-
-  impl = get_impl_drawable (drawable);
-
-  if (win32_gc->holdpal != NULL)
-    {
-      gint k;
-      
-      if (!SelectPalette (win32_gc->hdc, win32_gc->holdpal, FALSE))
-	WIN32_GDI_FAILED ("SelectPalette");
-      else if ((k = RealizePalette (win32_gc->hdc)) == GDI_ERROR)
-	WIN32_GDI_FAILED ("RealizePalette");
-      else if (k > 0)
-	GDK_NOTE (COLORMAP, g_print ("gdk_win32_hdc_release: realized %p: %d colors\n",
-				     win32_gc->holdpal, k));
-      win32_gc->holdpal = NULL;
-    }
-
-  if (usage & LINE_ATTRIBUTES)
-    if ((hpen = GetCurrentObject (win32_gc->hdc, OBJ_PEN)) == NULL)
-      WIN32_GDI_FAILED ("GetCurrentObject");
-  
-  if (usage & GDK_GC_FOREGROUND)
-    if ((hbr = GetCurrentObject (win32_gc->hdc, OBJ_BRUSH)) == NULL)
-      WIN32_GDI_FAILED ("GetCurrentObject");
-
-  GDI_CALL (RestoreDC, (win32_gc->hdc, win32_gc->saved_dc));
-
-  _gdk_win32_drawable_release_dc (GDK_DRAWABLE (impl));
-
-  if (hpen != NULL)
-    GDI_CALL (DeleteObject, (hpen));
-  
-  if (hbr != NULL)
-    GDI_CALL (DeleteObject, (hbr));
-
-  if (win32_gc->pen_hbrbg != NULL)
-    GDI_CALL (DeleteObject, (win32_gc->pen_hbrbg));
-
-  win32_gc->hdc = NULL;
-}
-
-/* This function originally from Jean-Edouard Lachand-Robert, and
- * available at www.codeguru.com. Simplified for our needs, not sure
- * how much of the original code left any longer. Now handles just
- * one-bit deep bitmaps (in Window parlance, ie those that GDK calls
- * bitmaps (and not pixmaps), with zero pixels being transparent.
- */
-
-/* _gdk_win32_bitmap_to_hrgn : Create a region from the
- * "non-transparent" pixels of a bitmap.
- */
-
-HRGN
-_gdk_win32_bitmap_to_hrgn (GdkPixmap *pixmap)
-{
-  HRGN hRgn = NULL;
-  HRGN h;
-  DWORD maxRects;
-  RGNDATA *pData;
-  guchar *bits;
-  gint width, height, bpl;
-  guchar *p;
-  gint x, y;
-
-  g_assert (GDK_PIXMAP_OBJECT(pixmap)->depth == 1);
-
-  bits = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl)->bits;
-  width = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl)->width;
-  height = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl)->height;
-  bpl = ((width - 1)/32 + 1)*4;
-
-  /* For better performances, we will use the ExtCreateRegion()
-   * function to create the region. This function take a RGNDATA
-   * structure on entry. We will add rectangles by amount of
-   * ALLOC_UNIT number in this structure.
-   */
-  #define ALLOC_UNIT  100
-  maxRects = ALLOC_UNIT;
-
-  pData = g_malloc (sizeof (RGNDATAHEADER) + (sizeof (RECT) * maxRects));
-  pData->rdh.dwSize = sizeof (RGNDATAHEADER);
-  pData->rdh.iType = RDH_RECTANGLES;
-  pData->rdh.nCount = pData->rdh.nRgnSize = 0;
-  SetRect (&pData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);
-
-  for (y = 0; y < height; y++)
-    {
-      /* Scan each bitmap row from left to right*/
-      p = (guchar *) bits + y * bpl;
-      for (x = 0; x < width; x++)
-	{
-	  /* Search for a continuous range of "non transparent pixels"*/
-	  gint x0 = x;
-	  while (x < width)
-	    {
-	      if ((((p[x/8])>>(7-(x%8)))&1) == 0)
-		/* This pixel is "transparent"*/
-		break;
-	      x++;
-	    }
-	  
-	  if (x > x0)
-	    {
-	      RECT *pr;
-	      /* Add the pixels (x0, y) to (x, y+1) as a new rectangle
-	       * in the region
-	       */
-	      if (pData->rdh.nCount >= maxRects)
-		{
-		  maxRects += ALLOC_UNIT;
-		  pData = g_realloc (pData, sizeof(RGNDATAHEADER)
-				     + (sizeof(RECT) * maxRects));
-		}
-	      pr = (RECT *) &pData->Buffer;
-	      SetRect (&pr[pData->rdh.nCount], x0, y, x, y+1);
-	      if (x0 < pData->rdh.rcBound.left)
-		pData->rdh.rcBound.left = x0;
-	      if (y < pData->rdh.rcBound.top)
-		pData->rdh.rcBound.top = y;
-	      if (x > pData->rdh.rcBound.right)
-		pData->rdh.rcBound.right = x;
-	      if (y+1 > pData->rdh.rcBound.bottom)
-		pData->rdh.rcBound.bottom = y+1;
-	      pData->rdh.nCount++;
-	      
-	      /* On Windows98, ExtCreateRegion() may fail if the
-	       * number of rectangles is too large (ie: >
-	       * 4000). Therefore, we have to create the region by
-	       * multiple steps.
-	       */
-	      if (pData->rdh.nCount == 2000)
-		{
-		  HRGN h = ExtCreateRegion (NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * maxRects), pData);
-		  if (hRgn)
-		    {
-		      CombineRgn(hRgn, hRgn, h, RGN_OR);
-		      DeleteObject(h);
-		    }
-		  else
-		    hRgn = h;
-		  pData->rdh.nCount = 0;
-		  SetRect (&pData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);
-		}
-	    }
-	}
-    }
-  
-  /* Create or extend the region with the remaining rectangles*/
-  h = ExtCreateRegion (NULL, sizeof (RGNDATAHEADER)
-		       + (sizeof (RECT) * maxRects), pData);
-  if (hRgn)
-    {
-      CombineRgn (hRgn, hRgn, h, RGN_OR);
-      DeleteObject (h);
-    }
-  else
-    hRgn = h;
-
-  /* Clean up*/
-  g_free (pData);
-
-  return hRgn;
-}
-
-HRGN
-_gdk_win32_gdkregion_to_hrgn (const GdkRegion *region,
-			      gint             x_origin,
-			      gint             y_origin)
-{
-  HRGN hrgn;
-  RGNDATA *rgndata;
-  RECT *rect;
-  GdkRegionBox *boxes = region->rects;
-  guint nbytes =
-    sizeof (RGNDATAHEADER) + (sizeof (RECT) * region->numRects);
-  int i;
-
-  rgndata = g_malloc (nbytes);
-  rgndata->rdh.dwSize = sizeof (RGNDATAHEADER);
-  rgndata->rdh.iType = RDH_RECTANGLES;
-  rgndata->rdh.nCount = rgndata->rdh.nRgnSize = 0;
-  SetRect (&rgndata->rdh.rcBound,
-	   G_MAXLONG, G_MAXLONG, G_MINLONG, G_MINLONG);
-
-  for (i = 0; i < region->numRects; i++)
-    {
-      rect = ((RECT *) rgndata->Buffer) + rgndata->rdh.nCount++;
-
-      rect->left = boxes[i].x1 + x_origin;
-      rect->right = boxes[i].x2 + x_origin;
-      rect->top = boxes[i].y1 + y_origin;
-      rect->bottom = boxes[i].y2 + y_origin;
-
-      if (rect->left < rgndata->rdh.rcBound.left)
-	rgndata->rdh.rcBound.left = rect->left;
-      if (rect->right > rgndata->rdh.rcBound.right)
-	rgndata->rdh.rcBound.right = rect->right;
-      if (rect->top < rgndata->rdh.rcBound.top)
-	rgndata->rdh.rcBound.top = rect->top;
-      if (rect->bottom > rgndata->rdh.rcBound.bottom)
-	rgndata->rdh.rcBound.bottom = rect->bottom;
-    }
-  if ((hrgn = ExtCreateRegion (NULL, nbytes, rgndata)) == NULL)
-    WIN32_API_FAILED ("ExtCreateRegion");
-
-  g_free (rgndata);
-
-  return (hrgn);
-}
diff --git a/gdk/win32/gdkgeometry-win32.c b/gdk/win32/gdkgeometry-win32.c
deleted file mode 100644
index 23b6a4a..0000000
--- a/gdk/win32/gdkgeometry-win32.c
+++ /dev/null
@@ -1,285 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/* gdkgeometry-win32.c: emulation of 32 bit coordinates within the
- * limits of Win32 GDI. The idea of big window emulation is more or less
- * a copy of the X11 version, and the equvalent of guffaw scrolling
- * is ScrollWindowEx(). While we determine the invalidated region
- * ourself during scrolling, we do not pass SW_INVALIDATE to
- * ScrollWindowEx() to avoid a unnecessary WM_PAINT.
- *
- * Bits are always scrolled correctly by ScrollWindowEx(), but
- * some big children may hit the coordinate boundary (i.e.
- * win32_x/win32_y < -16383) after scrolling. They needed to be moved
- * back to the real position determined by gdk_window_compute_position().
- * This is handled in gdk_window_postmove().
- * 
- * The X11 version by Owen Taylor <otaylor@redhat.com>
- * Copyright Red Hat, Inc. 2000
- * Win32 hack by Tor Lillqvist <tml@iki.fi>
- * and Hans Breuer <hans@breuer.org>
- * Modified by Ivan, Wong Yat Cheung <email@ivanwong.info>
- * so that big window emulation finally works.
- */
-
-#include "config.h"
-#include "gdk.h"		/* For gdk_rectangle_intersect */
-#include "gdkregion.h"
-#include "gdkregion-generic.h"
-#include "gdkinternals.h"
-#include "gdkprivate-win32.h"
-
-#define SIZE_LIMIT 32767
-
-typedef struct _GdkWindowParentPos GdkWindowParentPos;
-
-static void tmp_unset_bg (GdkWindow *window);
-static void tmp_reset_bg (GdkWindow *window);
-
-void
-_gdk_window_move_resize_child (GdkWindow *window,
-			       gint       x,
-			       gint       y,
-			       gint       width,
-			       gint       height)
-{
-  GdkWindowImplWin32 *impl;
-  GdkWindowObject *obj;
-
-  g_return_if_fail (window != NULL);
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  obj = GDK_WINDOW_OBJECT (window);
-  impl = GDK_WINDOW_IMPL_WIN32 (obj->impl);
-
-  GDK_NOTE (MISC, g_print ("_gdk_window_move_resize_child: %s@%+d%+d %dx%d@%+d%+d\n",
-			   _gdk_win32_drawable_description (window),
-			   obj->x, obj->y, width, height, x, y));
-
-  if (width > 65535 || height > 65535)
-  {
-    g_warning ("Native children wider or taller than 65535 pixels are not supported.");
-
-    if (width > 65535)
-      width = 65535;
-    if (height > 65535)
-      height = 65535;
-  }
-
-  obj->x = x;
-  obj->y = y;
-  obj->width = width;
-  obj->height = height;
-
-  _gdk_win32_window_tmp_unset_parent_bg (window);
-  _gdk_win32_window_tmp_unset_bg (window, TRUE);
-  
-  GDK_NOTE (MISC, g_print ("... SetWindowPos(%p,NULL,%d,%d,%d,%d,"
-			   "NOACTIVATE|NOZORDER)\n",
-			   GDK_WINDOW_HWND (window),
-			   obj->x + obj->parent->abs_x, obj->y + obj->parent->abs_y, 
-			   width, height));
-
-  API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), NULL,
-			   obj->x + obj->parent->abs_x, obj->y + obj->parent->abs_y, 
-			   width, height,
-			   SWP_NOACTIVATE | SWP_NOZORDER));
-
-  //_gdk_win32_window_tmp_reset_parent_bg (window);
-  _gdk_win32_window_tmp_reset_bg (window, TRUE);
-}
-
-void
-_gdk_win32_window_tmp_unset_bg (GdkWindow *window,
-				gboolean recurse)
-{
-  GdkWindowObject *private;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  private = (GdkWindowObject *)window;
-
-  if (private->input_only || private->destroyed ||
-      (private->window_type != GDK_WINDOW_ROOT &&
-       !GDK_WINDOW_IS_MAPPED (window)))
-    return;
-
-  if (_gdk_window_has_impl (window) &&
-      GDK_WINDOW_IS_WIN32 (window) &&
-      private->window_type != GDK_WINDOW_ROOT &&
-      private->window_type != GDK_WINDOW_FOREIGN)
-    tmp_unset_bg (window);
-
-  if (recurse)
-    {
-      GList *l;
-
-      for (l = private->children; l != NULL; l = l->next)
-	_gdk_win32_window_tmp_unset_bg (l->data, TRUE);
-    }
-}
-
-static void
-tmp_unset_bg (GdkWindow *window)
-{
-  GdkWindowImplWin32 *impl;
-  GdkWindowObject *obj;
-
-  obj = (GdkWindowObject *) window;
-  impl = GDK_WINDOW_IMPL_WIN32 (obj->impl);
-
-  impl->no_bg = TRUE;
-
-  /*
-   * The X version sets background = None to avoid updateing for a moment.
-   * Not sure if this could really emulate it.
-   */
-  if (obj->bg_pixmap != GDK_NO_BG)
-    {
-      ///* handled in WM_ERASEBKGRND proceesing */;
-
-      //HDC hdc = GetDC (GDK_WINDOW_HWND (window));
-      //erase_background (window, hdc);
-    }
-}
-
-static void
-tmp_reset_bg (GdkWindow *window)
-{
-  GdkWindowObject *obj;
-  GdkWindowImplWin32 *impl;
-
-  obj = GDK_WINDOW_OBJECT (window);
-  impl = GDK_WINDOW_IMPL_WIN32 (obj->impl);
-
-  impl->no_bg = FALSE;
-}
-
-void
-_gdk_win32_window_tmp_unset_parent_bg (GdkWindow *window)
-{
-  GdkWindowObject *private = (GdkWindowObject*)window;
-
-  if (GDK_WINDOW_TYPE (private->parent) == GDK_WINDOW_ROOT)
-    return;
-
-  window = _gdk_window_get_impl_window ((GdkWindow*)private->parent);
-  _gdk_win32_window_tmp_unset_bg (window, FALSE);
-}
-
-void
-_gdk_win32_window_tmp_reset_bg (GdkWindow *window,
-				gboolean   recurse)
-{
-  GdkWindowObject *private = (GdkWindowObject*)window;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (private->input_only || private->destroyed ||
-      (private->window_type != GDK_WINDOW_ROOT && !GDK_WINDOW_IS_MAPPED (window)))
-    return;
-
-  if (_gdk_window_has_impl (window) &&
-      GDK_WINDOW_IS_WIN32 (window) &&
-      private->window_type != GDK_WINDOW_ROOT &&
-      private->window_type != GDK_WINDOW_FOREIGN)
-    {
-      tmp_reset_bg (window);
-    }
-
-  if (recurse)
-    {
-      GList *l;
-
-      for (l = private->children; l != NULL; l = l->next)
-	_gdk_win32_window_tmp_reset_bg (l->data, TRUE);
-    }
-}
-
-/*
-void
-_gdk_win32_window_tmp_reset_bg (GdkWindow *window)
-{
-  GdkWindowImplWin32 *impl;
-  GdkWindowObject *obj;
-
-  obj = (GdkWindowObject *) window;
-  impl = GDK_WINDOW_IMPL_WIN32 (obj->impl);
-
-  impl->no_bg = FALSE;
-}
-*/
-
-#if 0
-static GdkRegion *
-gdk_window_clip_changed (GdkWindow    *window,
-			 GdkRectangle *old_clip,
-			 GdkRectangle *new_clip)
-{
-  GdkWindowImplWin32 *impl;
-  GdkWindowObject *obj;
-  GdkRegion *old_clip_region;
-  GdkRegion *new_clip_region;
-  
-  if (((GdkWindowObject *)window)->input_only)
-    return NULL;
-
-  obj = (GdkWindowObject *) window;
-  impl = GDK_WINDOW_IMPL_WIN32 (obj->impl);
-  
-  old_clip_region = gdk_region_rectangle (old_clip);
-  new_clip_region = gdk_region_rectangle (new_clip);
-
-  /* Trim invalid region of window to new clip rectangle
-   */
-  if (obj->update_area)
-    gdk_region_intersect (obj->update_area, new_clip_region);
-
-  /* Invalidate newly exposed portion of window
-   */
-  gdk_region_subtract (new_clip_region, old_clip_region);
-  if (!gdk_region_empty (new_clip_region))
-    gdk_window_tmp_unset_bg (window);
-  else
-    {
-      gdk_region_destroy (new_clip_region);
-      new_clip_region = NULL;
-    }
-
-  gdk_region_destroy (old_clip_region);
-
-  return new_clip_region;
-}
-#endif
-
-#if 0
-static void
-gdk_window_post_scroll (GdkWindow    *window,
-			GdkRegion    *new_clip_region)
-{
-  GDK_NOTE (EVENTS,
-	    g_print ("gdk_window_clip_changed: invalidating region: %s\n",
-		     _gdk_win32_gdkregion_to_string (new_clip_region)));
-
-  gdk_window_invalidate_region (window, new_clip_region, FALSE);
-  g_print ("gdk_window_post_scroll\n");
-  gdk_region_destroy (new_clip_region);
-}
-
-#endif
diff --git a/gdk/win32/gdkglobals-win32.c b/gdk/win32/gdkglobals-win32.c
deleted file mode 100644
index 1a876d0..0000000
--- a/gdk/win32/gdkglobals-win32.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include "gdktypes.h"
-#include "gdkprivate-win32.h"
-
-GdkDisplay	 *_gdk_display = NULL;
-GdkScreen	 *_gdk_screen = NULL;
-GdkWindow	 *_gdk_root = NULL;
-
-gint		  _gdk_num_monitors;
-GdkWin32Monitor  *_gdk_monitors = NULL;
-
-gint		  _gdk_offset_x, _gdk_offset_y;
-
-HDC		  _gdk_display_hdc;
-HINSTANCE	  _gdk_dll_hinstance;
-HINSTANCE	  _gdk_app_hmodule;
-
-HKL		  _gdk_input_locale;
-gboolean	  _gdk_input_locale_is_ime;
-UINT		  _gdk_input_codepage;
-
-GdkAtom           _gdk_selection;
-GdkAtom	          _wm_transient_for;
-GdkAtom		  _targets;
-GdkAtom		  _delete;
-GdkAtom		  _save_targets;
-GdkAtom           _utf8_string;
-GdkAtom		  _text;
-GdkAtom		  _compound_text;
-GdkAtom		  _text_uri_list;
-GdkAtom		  _text_html;
-GdkAtom		  _image_png;
-GdkAtom		  _image_jpeg;
-GdkAtom		  _image_bmp;
-GdkAtom		  _image_gif;
-
-GdkAtom		  _local_dnd;
-GdkAtom		  _gdk_win32_dropfiles;
-GdkAtom		  _gdk_ole2_dnd;
-
-UINT		  _cf_png;
-UINT		  _cf_jfif;
-UINT		  _cf_gif;
-UINT		  _cf_url;
-UINT		  _cf_html_format;
-UINT		  _cf_text_html;
-
-GdkWin32DndState  _dnd_target_state = GDK_WIN32_DND_NONE;
-GdkWin32DndState  _dnd_source_state = GDK_WIN32_DND_NONE;
-
-gint		  _gdk_input_ignore_wintab = FALSE;
-gint		  _gdk_max_colors = 0;
-
-gboolean	  _modal_operation_in_progress = FALSE;
-HWND              _modal_move_resize_window = NULL;
-gboolean	  _ignore_destroy_clipboard = FALSE;
-
-HGLOBAL           _delayed_rendering_data = NULL;
-GHashTable       *_format_atom_table = NULL;
diff --git a/gdk/win32/gdkim-win32.c b/gdk/win32/gdkim-win32.c
deleted file mode 100644
index b621721..0000000
--- a/gdk/win32/gdkim-win32.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2004 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <string.h>
-#include <locale.h>
-
-#include "gdkpixmap.h"
-#include "gdkinternals.h"
-#include "gdki18n.h"
-#include "gdkwin32.h"
-
-gchar*
-gdk_set_locale (void)
-{
-  if (!setlocale (LC_ALL, ""))
-    g_warning ("locale not supported by C library");
-  
-  return g_win32_getlocale ();
-}
-
-gchar *
-gdk_wcstombs (const GdkWChar *src)
-{
-  const gchar *charset;
-
-  g_get_charset (&charset);
-  return g_convert ((char *) src, -1, charset, "UCS-4LE", NULL, NULL, NULL);
-}
-
-gint
-gdk_mbstowcs (GdkWChar    *dest,
-	      const gchar *src,
-	      gint         dest_max)
-{
-  gint retval;
-  gsize nwritten;
-  gint n_ucs4;
-  gunichar *ucs4;
-  const gchar *charset;
-
-  g_get_charset (&charset);
-  ucs4 = (gunichar *) g_convert (src, -1, "UCS-4LE", charset, NULL, &nwritten, NULL);
-  n_ucs4 = nwritten * sizeof (GdkWChar);
-
-  retval = MIN (dest_max, n_ucs4);
-  memmove (dest, ucs4, retval * sizeof (GdkWChar));
-  g_free (ucs4);
-
-  return retval;
-}
diff --git a/gdk/win32/gdkimage-win32.c b/gdk/win32/gdkimage-win32.c
deleted file mode 100644
index 5292f20..0000000
--- a/gdk/win32/gdkimage-win32.c
+++ /dev/null
@@ -1,431 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include "gdkimage.h"
-#include "gdkpixmap.h"
-#include "gdkscreen.h" /* gdk_screen_get_default() */
-#include "gdkprivate-win32.h"
-
-static GList *image_list = NULL;
-static gpointer parent_class = NULL;
-
-static void gdk_win32_image_destroy (GdkImage      *image);
-static void gdk_image_init          (GdkImage      *image);
-static void gdk_image_class_init    (GdkImageClass *klass);
-static void gdk_image_finalize      (GObject       *object);
-
-GType
-gdk_image_get_type (void)
-{
-  static GType object_type = 0;
-
-  if (!object_type)
-    {
-      const GTypeInfo object_info =
-      {
-        sizeof (GdkImageClass),
-        (GBaseInitFunc) NULL,
-        (GBaseFinalizeFunc) NULL,
-        (GClassInitFunc) gdk_image_class_init,
-        NULL,           /* class_finalize */
-        NULL,           /* class_data */
-        sizeof (GdkImage),
-        0,              /* n_preallocs */
-        (GInstanceInitFunc) gdk_image_init,
-      };
-      
-      object_type = g_type_register_static (G_TYPE_OBJECT,
-                                            "GdkImage",
-                                            &object_info, 0);
-    }
-  
-  return object_type;
-}
-
-static void
-gdk_image_init (GdkImage *image)
-{
-  image->windowing_data = NULL;
-}
-
-static void
-gdk_image_class_init (GdkImageClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  parent_class = g_type_class_peek_parent (klass);
-
-  object_class->finalize = gdk_image_finalize;
-}
-
-static void
-gdk_image_finalize (GObject *object)
-{
-  GdkImage *image = GDK_IMAGE (object);
-
-  gdk_win32_image_destroy (image);
-  
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-void
-_gdk_image_exit (void)
-{
-  GdkImage *image;
-
-  while (image_list)
-    {
-      image = image_list->data;
-      gdk_win32_image_destroy (image);
-    }
-}
-
-/*
- * Create a GdkImage _without_ an associated GdkPixmap. The caller is
- * responsible for creating a GdkPixmap object and making the association.
- */
-
-static GdkImage *
-_gdk_win32_new_image (GdkVisual *visual,
-		      gint       width,
-		      gint       height,
-		      gint       depth,
-		      guchar    *bits)
-{
-  GdkImage *image;
-
-  image = g_object_new (gdk_image_get_type (), NULL);
-  image->windowing_data = NULL;
-  image->type = GDK_IMAGE_SHARED;
-  image->visual = visual;
-  image->byte_order = GDK_LSB_FIRST;
-  image->width = width;
-  image->height = height;
-  image->depth = depth;
-  image->bits_per_pixel = _gdk_windowing_get_bits_for_depth (gdk_display_get_default (), depth);
-  switch (depth)
-    {
-    case 1:
-    case 4:
-    case 5:
-    case 6:
-    case 7:
-    case 8:
-      image->bpp = 1;
-      break;
-    case 15:
-    case 16:
-      image->bpp = 2;
-      break;
-    case 24:
-      image->bpp = image->bits_per_pixel / 8;
-      break;
-    case 32:
-      image->bpp = 4;
-      break;
-    default:
-      g_warning ("_gdk_win32_new_image: depth=%d", image->depth);
-      g_assert_not_reached ();
-    }
-  if (depth == 1)
-    image->bpl = ((width - 1)/32 + 1)*4;
-  else if (depth == 4)
-    image->bpl = ((width - 1)/8 + 1)*4;
-  else
-    image->bpl = ((width*image->bpp - 1)/4 + 1)*4;
-  image->mem = bits;
-
-  return image;
-}
-
-GdkImage *
-gdk_image_new_bitmap (GdkVisual *visual,
-		      gpointer   data,
-		      gint       w,
-		      gint       h)
-{
-  GdkPixmap *pixmap;
-  GdkImage *image;
-  guchar *bits;
-  gint data_bpl = (w-1)/8 + 1;
-  gint i;
-
-  pixmap = gdk_pixmap_new (NULL, w, h, 1);
-
-  if (pixmap == NULL)
-    return NULL;
-
-  GDK_NOTE (IMAGE, g_print ("gdk_image_new_bitmap: %dx%d=%p\n",
-			    w, h, GDK_PIXMAP_HBITMAP (pixmap)));
-
-  bits = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl)->bits;
-  image = _gdk_win32_new_image (visual, w, h, 1, bits);
-  image->windowing_data = pixmap;
-  
-  if (data_bpl != image->bpl)
-    {
-      for (i = 0; i < h; i++)
-	memmove ((guchar *) image->mem + i*image->bpl, ((guchar *) data) + i*data_bpl, data_bpl);
-    }
-  else
-    memmove (image->mem, data, data_bpl*h);
-
-  return image;
-}
-
-void
-_gdk_windowing_image_init (void)
-{
-  /* Nothing needed AFAIK */
-}
-
-GdkImage*
-_gdk_image_new_for_depth (GdkScreen    *screen,
-			  GdkImageType  type,
-			  GdkVisual    *visual,
-			  gint          width,
-			  gint          height,
-			  gint          depth)
-{
-  GdkPixmap *pixmap;
-  GdkImage *image;
-  guchar *bits;
-
-  g_return_val_if_fail (!visual || GDK_IS_VISUAL (visual), NULL);
-  g_return_val_if_fail (visual || depth != -1, NULL);
-  g_return_val_if_fail (screen == gdk_screen_get_default (), NULL);
- 
-  if (visual)
-    depth = visual->depth;
-
-  pixmap = gdk_pixmap_new (NULL, width, height, depth);
-
-  if (pixmap == NULL)
-    return NULL;
-
-  GDK_NOTE (IMAGE, g_print ("_gdk_image_new_for_depth: %dx%dx%d=%p\n",
-			    width, height, depth, GDK_PIXMAP_HBITMAP (pixmap)));
-  
-  bits = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl)->bits;
-  image = _gdk_win32_new_image (visual, width, height, depth, bits);
-  image->windowing_data = pixmap;
-  
-  return image;
-}
-
-GdkImage*
-_gdk_win32_copy_to_image (GdkDrawable    *drawable,
-			  GdkImage       *image,
-			  gint            src_x,
-			  gint            src_y,
-			  gint            dest_x,
-			  gint            dest_y,
-			  gint            width,
-			  gint            height)
-{
-  GdkGC *gc;
-  GdkScreen *screen = gdk_drawable_get_screen (drawable);
-  
-  g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_WIN32 (drawable), NULL);
-  g_return_val_if_fail (image != NULL || (dest_x == 0 && dest_y == 0), NULL);
-
-  GDK_NOTE (IMAGE, g_print ("_gdk_win32_copy_to_image: %p\n",
-			    GDK_DRAWABLE_HANDLE (drawable)));
-
-  if (!image)
-    image = _gdk_image_new_for_depth (screen, GDK_IMAGE_FASTEST, NULL, width, height,
-				      gdk_drawable_get_depth (drawable));
-
-  gc = gdk_gc_new ((GdkDrawable *) image->windowing_data);
-  _gdk_win32_blit
-    (FALSE,
-     GDK_DRAWABLE_IMPL_WIN32 (GDK_PIXMAP_OBJECT (image->windowing_data)->impl),
-     gc, drawable, src_x, src_y, dest_x, dest_y, width, height);
-  g_object_unref (gc);
-
-  return image;
-}
-
-guint32
-gdk_image_get_pixel (GdkImage *image,
-		     gint      x,
-		     gint      y)
-{
-  guchar *pixelp;
-
-  g_return_val_if_fail (image != NULL, 0);
-  g_return_val_if_fail (x >= 0 && x < image->width, 0);
-  g_return_val_if_fail (y >= 0 && y < image->height, 0);
-
-  if (!(x >= 0 && x < image->width && y >= 0 && y < image->height))
-      return 0;
-
-  if (image->depth == 1)
-    return (((guchar *) image->mem)[y * image->bpl + (x >> 3)] & (1 << (7 - (x & 0x7)))) != 0;
-
-  if (image->depth == 4)
-    {
-      pixelp = (guchar *) image->mem + y * image->bpl + (x >> 1);
-      if (x&1)
-	return (*pixelp) & 0x0F;
-
-      return (*pixelp) >> 4;
-    }
-    
-  pixelp = (guchar *) image->mem + y * image->bpl + x * image->bpp;
-      
-  switch (image->bpp)
-    {
-    case 1:
-      return *pixelp;
-      
-      /* Windows is always LSB, no need to check image->byte_order. */
-    case 2:
-      return pixelp[0] | (pixelp[1] << 8);
-      
-    case 3:
-      return pixelp[0] | (pixelp[1] << 8) | (pixelp[2] << 16);
-
-    case 4:
-      return pixelp[0] | (pixelp[1] << 8) | (pixelp[2] << 16);
-    }
-  g_assert_not_reached ();
-  return 0;
-}
-
-void
-gdk_image_put_pixel (GdkImage *image,
-		     gint       x,
-		     gint       y,
-		     guint32    pixel)
-{
-  guchar *pixelp;
-
-  g_return_if_fail (image != NULL);
-  g_return_if_fail (x >= 0 && x < image->width);
-  g_return_if_fail (y >= 0 && y < image->height);
-
-  if  (!(x >= 0 && x < image->width && y >= 0 && y < image->height))
-    return;
-
-  GdiFlush ();
-  if (image->depth == 1)
-    if (pixel & 1)
-      ((guchar *) image->mem)[y * image->bpl + (x >> 3)] |= (1 << (7 - (x & 0x7)));
-    else
-      ((guchar *) image->mem)[y * image->bpl + (x >> 3)] &= ~(1 << (7 - (x & 0x7)));
-  else if (image->depth == 4)
-    {
-      pixelp = (guchar *) image->mem + y * image->bpl + (x >> 1);
-
-      if (x&1)
-	{
-	  *pixelp &= 0xF0;
-	  *pixelp |= (pixel & 0x0F);
-	}
-      else
-	{
-	  *pixelp &= 0x0F;
-	  *pixelp |= (pixel << 4);
-	}
-    }
-  else
-    {
-      pixelp = (guchar *) image->mem + y * image->bpl + x * image->bpp;
-      
-      /* Windows is always LSB, no need to check image->byte_order. */
-      switch (image->bpp)
-	{
-	case 4:
-	  pixelp[3] = 0;
-	case 3:
-	  pixelp[2] = ((pixel >> 16) & 0xFF);
-	case 2:
-	  pixelp[1] = ((pixel >> 8) & 0xFF);
-	case 1:
-	  pixelp[0] = (pixel & 0xFF);
-	}
-    }
-}
-
-static void
-gdk_win32_image_destroy (GdkImage *image)
-{
-  GdkPixmap *pixmap;
-
-  g_return_if_fail (GDK_IS_IMAGE (image));
-
-  pixmap = image->windowing_data;
-
-  if (pixmap == NULL)		/* This means that _gdk_image_exit()
-				 * destroyed the image already, and
-				 * now we're called a second time from
-				 * _finalize()
-				 */
-    return;
-  
-  GDK_NOTE (IMAGE, g_print ("gdk_win32_image_destroy: %p\n",
-			    GDK_PIXMAP_HBITMAP (pixmap)));
-
-  g_object_unref (pixmap);
-  image->windowing_data = NULL;
-}
-
-gint
-_gdk_windowing_get_bits_for_depth (GdkDisplay *display,
-                                   gint        depth)
-{
-  g_return_val_if_fail (display == gdk_display_get_default (), 0);
-
-  switch (depth)
-    {
-    case 1:
-      return 1;
-
-    case 2:
-    case 3:
-    case 4:
-      return 4;
-
-    case 5:
-    case 6:
-    case 7:
-    case 8:
-      return 8;
-
-    case 15:
-    case 16:
-      return 16;
-
-    case 24:
-    case 32:
-      return 32;
-    }
-  g_assert_not_reached ();
-  return 0;
-}
diff --git a/gdk/win32/gdkinput-win32.c b/gdk/win32/gdkinput-win32.c
deleted file mode 100644
index 3fe7aaf..0000000
--- a/gdk/win32/gdkinput-win32.c
+++ /dev/null
@@ -1,1347 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2007 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-
-#include "gdk.h"
-#include "gdkinput.h"
-#include "gdkinternals.h"
-#include "gdkprivate-win32.h"
-#include "gdkinput-win32.h"
-
-#define WINTAB32_DLL "Wintab32.dll"
-
-#define PACKETDATA (PK_CONTEXT | PK_CURSOR | PK_BUTTONS | PK_X | PK_Y  | PK_NORMAL_PRESSURE | PK_ORIENTATION)
-/* We want everything in absolute mode */
-#define PACKETMODE (0)
-#include <pktdef.h>
-
-#define DEBUG_WINTAB 1		/* Verbose debug messages enabled */
-
-#define PROXIMITY_OUT_DELAY 200 /* In milliseconds, see set_ignore_core */
-
-#define TWOPI (2.*G_PI)
-
-/* Forward declarations */
-
-static GdkDevicePrivate *gdk_input_find_dev_from_ctx (HCTX hctx,
-						      UINT id);
-static GList     *wintab_contexts = NULL;
-
-static GdkWindow *wintab_window = NULL;
-
-static GdkDevicePrivate *_gdk_device_in_proximity;
-
-typedef UINT (WINAPI *t_WTInfoA) (UINT a, UINT b, LPVOID c);
-typedef UINT (WINAPI *t_WTInfoW) (UINT a, UINT b, LPVOID c);
-typedef BOOL (WINAPI *t_WTEnable) (HCTX a, BOOL b);
-typedef HCTX (WINAPI *t_WTOpenA) (HWND a, LPLOGCONTEXTA b, BOOL c);
-typedef BOOL (WINAPI *t_WTGetA) (HCTX a, LPLOGCONTEXTA b);
-typedef BOOL (WINAPI *t_WTSetA) (HCTX a, LPLOGCONTEXTA b);
-typedef BOOL (WINAPI *t_WTOverlap) (HCTX a, BOOL b);
-typedef BOOL (WINAPI *t_WTPacket) (HCTX a, UINT b, LPVOID c);
-typedef int (WINAPI *t_WTQueueSizeSet) (HCTX a, int b);
-
-static t_WTInfoA p_WTInfoA;
-static t_WTInfoW p_WTInfoW;
-static t_WTEnable p_WTEnable;
-static t_WTOpenA p_WTOpenA;
-static t_WTGetA p_WTGetA;
-static t_WTSetA p_WTSetA;
-static t_WTOverlap p_WTOverlap;
-static t_WTPacket p_WTPacket;
-static t_WTQueueSizeSet p_WTQueueSizeSet;
-
-static GdkDevicePrivate *
-gdk_input_find_dev_from_ctx (HCTX hctx,
-			     UINT cursor)
-{
-  GList *tmp_list = _gdk_input_devices;
-  GdkDevicePrivate *gdkdev;
-
-  while (tmp_list)
-    {
-      gdkdev = (GdkDevicePrivate *) (tmp_list->data);
-      if (gdkdev->hctx == hctx && gdkdev->cursor == cursor)
-	return gdkdev;
-      tmp_list = tmp_list->next;
-    }
-  return NULL;
-}
-
-
-#if DEBUG_WINTAB
-
-#ifdef G_ENABLE_DEBUG
-static void
-print_lc(LOGCONTEXT *lc)
-{
-  g_print ("lcName = %s\n", lc->lcName);
-  g_print ("lcOptions =");
-  if (lc->lcOptions & CXO_SYSTEM) g_print (" CXO_SYSTEM");
-  if (lc->lcOptions & CXO_PEN) g_print (" CXO_PEN");
-  if (lc->lcOptions & CXO_MESSAGES) g_print (" CXO_MESSAGES");
-  if (lc->lcOptions & CXO_MARGIN) g_print (" CXO_MARGIN");
-  if (lc->lcOptions & CXO_MGNINSIDE) g_print (" CXO_MGNINSIDE");
-  if (lc->lcOptions & CXO_CSRMESSAGES) g_print (" CXO_CSRMESSAGES");
-  g_print ("\n");
-  g_print ("lcStatus =");
-  if (lc->lcStatus & CXS_DISABLED) g_print (" CXS_DISABLED");
-  if (lc->lcStatus & CXS_OBSCURED) g_print (" CXS_OBSCURED");
-  if (lc->lcStatus & CXS_ONTOP) g_print (" CXS_ONTOP");
-  g_print ("\n");
-  g_print ("lcLocks =");
-  if (lc->lcLocks & CXL_INSIZE) g_print (" CXL_INSIZE");
-  if (lc->lcLocks & CXL_INASPECT) g_print (" CXL_INASPECT");
-  if (lc->lcLocks & CXL_SENSITIVITY) g_print (" CXL_SENSITIVITY");
-  if (lc->lcLocks & CXL_MARGIN) g_print (" CXL_MARGIN");
-  g_print ("\n");
-  g_print ("lcMsgBase = %#x, lcDevice = %#x, lcPktRate = %d\n",
-	  lc->lcMsgBase, lc->lcDevice, lc->lcPktRate);
-  g_print ("lcPktData =");
-  if (lc->lcPktData & PK_CONTEXT) g_print (" PK_CONTEXT");
-  if (lc->lcPktData & PK_STATUS) g_print (" PK_STATUS");
-  if (lc->lcPktData & PK_TIME) g_print (" PK_TIME");
-  if (lc->lcPktData & PK_CHANGED) g_print (" PK_CHANGED");
-  if (lc->lcPktData & PK_SERIAL_NUMBER) g_print (" PK_SERIAL_NUMBER");
-  if (lc->lcPktData & PK_CURSOR) g_print (" PK_CURSOR");
-  if (lc->lcPktData & PK_BUTTONS) g_print (" PK_BUTTONS");
-  if (lc->lcPktData & PK_X) g_print (" PK_X");
-  if (lc->lcPktData & PK_Y) g_print (" PK_Y");
-  if (lc->lcPktData & PK_Z) g_print (" PK_Z");
-  if (lc->lcPktData & PK_NORMAL_PRESSURE) g_print (" PK_NORMAL_PRESSURE");
-  if (lc->lcPktData & PK_TANGENT_PRESSURE) g_print (" PK_TANGENT_PRESSURE");
-  if (lc->lcPktData & PK_ORIENTATION) g_print (" PK_ORIENTATION");
-  if (lc->lcPktData & PK_ROTATION) g_print (" PK_ROTATION");
-  g_print ("\n");
-  g_print ("lcPktMode =");
-  if (lc->lcPktMode & PK_CONTEXT) g_print (" PK_CONTEXT");
-  if (lc->lcPktMode & PK_STATUS) g_print (" PK_STATUS");
-  if (lc->lcPktMode & PK_TIME) g_print (" PK_TIME");
-  if (lc->lcPktMode & PK_CHANGED) g_print (" PK_CHANGED");
-  if (lc->lcPktMode & PK_SERIAL_NUMBER) g_print (" PK_SERIAL_NUMBER");
-  if (lc->lcPktMode & PK_CURSOR) g_print (" PK_CURSOR");
-  if (lc->lcPktMode & PK_BUTTONS) g_print (" PK_BUTTONS");
-  if (lc->lcPktMode & PK_X) g_print (" PK_X");
-  if (lc->lcPktMode & PK_Y) g_print (" PK_Y");
-  if (lc->lcPktMode & PK_Z) g_print (" PK_Z");
-  if (lc->lcPktMode & PK_NORMAL_PRESSURE) g_print (" PK_NORMAL_PRESSURE");
-  if (lc->lcPktMode & PK_TANGENT_PRESSURE) g_print (" PK_TANGENT_PRESSURE");
-  if (lc->lcPktMode & PK_ORIENTATION) g_print (" PK_ORIENTATION");
-  if (lc->lcPktMode & PK_ROTATION) g_print (" PK_ROTATION");
-  g_print ("\n");
-  g_print ("lcMoveMask =");
-  if (lc->lcMoveMask & PK_CONTEXT) g_print (" PK_CONTEXT");
-  if (lc->lcMoveMask & PK_STATUS) g_print (" PK_STATUS");
-  if (lc->lcMoveMask & PK_TIME) g_print (" PK_TIME");
-  if (lc->lcMoveMask & PK_CHANGED) g_print (" PK_CHANGED");
-  if (lc->lcMoveMask & PK_SERIAL_NUMBER) g_print (" PK_SERIAL_NUMBER");
-  if (lc->lcMoveMask & PK_CURSOR) g_print (" PK_CURSOR");
-  if (lc->lcMoveMask & PK_BUTTONS) g_print (" PK_BUTTONS");
-  if (lc->lcMoveMask & PK_X) g_print (" PK_X");
-  if (lc->lcMoveMask & PK_Y) g_print (" PK_Y");
-  if (lc->lcMoveMask & PK_Z) g_print (" PK_Z");
-  if (lc->lcMoveMask & PK_NORMAL_PRESSURE) g_print (" PK_NORMAL_PRESSURE");
-  if (lc->lcMoveMask & PK_TANGENT_PRESSURE) g_print (" PK_TANGENT_PRESSURE");
-  if (lc->lcMoveMask & PK_ORIENTATION) g_print (" PK_ORIENTATION");
-  if (lc->lcMoveMask & PK_ROTATION) g_print (" PK_ROTATION");
-  g_print ("\n");
-  g_print ("lcBtnDnMask = %#x, lcBtnUpMask = %#x\n",
-	  (guint) lc->lcBtnDnMask, (guint) lc->lcBtnUpMask);
-  g_print ("lcInOrgX = %ld, lcInOrgY = %ld, lcInOrgZ = %ld\n",
-	  lc->lcInOrgX, lc->lcInOrgY, lc->lcInOrgZ);
-  g_print ("lcInExtX = %ld, lcInExtY = %ld, lcInExtZ = %ld\n",
-	  lc->lcInExtX, lc->lcInExtY, lc->lcInExtZ);
-  g_print ("lcOutOrgX = %ld, lcOutOrgY = %ld, lcOutOrgZ = %ld\n",
-	  lc->lcOutOrgX, lc->lcOutOrgY, lc->lcOutOrgZ);
-  g_print ("lcOutExtX = %ld, lcOutExtY = %ld, lcOutExtZ = %ld\n",
-	  lc->lcOutExtX, lc->lcOutExtY, lc->lcOutExtZ);
-  g_print ("lcSensX = %g, lcSensY = %g, lcSensZ = %g\n",
-	  lc->lcSensX / 65536., lc->lcSensY / 65536., lc->lcSensZ / 65536.);
-  g_print ("lcSysMode = %d\n", lc->lcSysMode);
-  g_print ("lcSysOrgX = %d, lcSysOrgY = %d\n",
-	  lc->lcSysOrgX, lc->lcSysOrgY);
-  g_print ("lcSysExtX = %d, lcSysExtY = %d\n",
-	  lc->lcSysExtX, lc->lcSysExtY);
-  g_print ("lcSysSensX = %g, lcSysSensY = %g\n",
-	  lc->lcSysSensX / 65536., lc->lcSysSensY / 65536.);
-}
-
-static void
-print_cursor (int index)
-{
-  int size;
-  int i;
-  char *name;
-  BOOL active;
-  WTPKT wtpkt;
-  BYTE buttons;
-  BYTE buttonbits;
-  char *btnnames;
-  char *p;
-  BYTE buttonmap[32];
-  BYTE sysbtnmap[32];
-  BYTE npbutton;
-  UINT npbtnmarks[2];
-  UINT *npresponse;
-  BYTE tpbutton;
-  UINT tpbtnmarks[2];
-  UINT *tpresponse;
-  DWORD physid;
-  UINT mode;
-  UINT minpktdata;
-  UINT minbuttons;
-  UINT capabilities;
-
-  size = (*p_WTInfoA) (WTI_CURSORS + index, CSR_NAME, NULL);
-  name = g_malloc (size + 1);
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_NAME, name);
-  g_print ("NAME: %s\n", name);
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_ACTIVE, &active);
-  g_print ("ACTIVE: %s\n", active ? "YES" : "NO");
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_PKTDATA, &wtpkt);
-  g_print ("PKTDATA: %#x:", (guint) wtpkt);
-#define BIT(x) if (wtpkt & PK_##x) g_print (" " #x)
-  BIT (CONTEXT);
-  BIT (STATUS);
-  BIT (TIME);
-  BIT (CHANGED);
-  BIT (SERIAL_NUMBER);
-  BIT (BUTTONS);
-  BIT (X);
-  BIT (Y);
-  BIT (Z);
-  BIT (NORMAL_PRESSURE);
-  BIT (TANGENT_PRESSURE);
-  BIT (ORIENTATION);
-  BIT (ROTATION);
-#undef BIT
-  g_print ("\n");
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_BUTTONS, &buttons);
-  g_print ("BUTTONS: %d\n", buttons);
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_BUTTONBITS, &buttonbits);
-  g_print ("BUTTONBITS: %d\n", buttonbits);
-  size = (*p_WTInfoA) (WTI_CURSORS + index, CSR_BTNNAMES, NULL);
-  g_print ("BTNNAMES:");
-  if (size > 0)
-    {
-      btnnames = g_malloc (size + 1);
-      (*p_WTInfoA) (WTI_CURSORS + index, CSR_BTNNAMES, btnnames);
-      p = btnnames;
-      while (*p)
-	{
-	  g_print (" %s", p);
-	  p += strlen (p) + 1;
-	}
-    }
-  g_print ("\n");
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_BUTTONMAP, buttonmap);
-  g_print ("BUTTONMAP:");
-  for (i = 0; i < buttons; i++)
-    g_print (" %d", buttonmap[i]);
-  g_print ("\n");
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_SYSBTNMAP, sysbtnmap);
-  g_print ("SYSBTNMAP:");
-  for (i = 0; i < buttons; i++)
-    g_print (" %d", sysbtnmap[i]);
-  g_print ("\n");
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_NPBUTTON, &npbutton);
-  g_print ("NPBUTTON: %d\n", npbutton);
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_NPBTNMARKS, npbtnmarks);
-  g_print ("NPBTNMARKS: %d %d\n", npbtnmarks[0], npbtnmarks[1]);
-  size = (*p_WTInfoA) (WTI_CURSORS + index, CSR_NPRESPONSE, NULL);
-  g_print ("NPRESPONSE:");
-  if (size > 0)
-    {
-      npresponse = g_malloc (size);
-      (*p_WTInfoA) (WTI_CURSORS + index, CSR_NPRESPONSE, npresponse);
-      for (i = 0; i < size / sizeof (UINT); i++)
-	g_print (" %d", npresponse[i]);
-    }
-  g_print ("\n");
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_TPBUTTON, &tpbutton);
-  g_print ("TPBUTTON: %d\n", tpbutton);
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_TPBTNMARKS, tpbtnmarks);
-  g_print ("TPBTNMARKS: %d %d\n", tpbtnmarks[0], tpbtnmarks[1]);
-  size = (*p_WTInfoA) (WTI_CURSORS + index, CSR_TPRESPONSE, NULL);
-  g_print ("TPRESPONSE:");
-  if (size > 0)
-    {
-      tpresponse = g_malloc (size);
-      (*p_WTInfoA) (WTI_CURSORS + index, CSR_TPRESPONSE, tpresponse);
-      for (i = 0; i < size / sizeof (UINT); i++)
-	g_print (" %d", tpresponse[i]);
-    }
-  g_print ("\n");
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_PHYSID, &physid);
-  g_print ("PHYSID: %#x\n", (guint) physid);
-  (*p_WTInfoA) (WTI_CURSORS + index, CSR_CAPABILITIES, &capabilities);
-  g_print ("CAPABILITIES: %#x:", capabilities);
-#define BIT(x) if (capabilities & CRC_##x) g_print (" " #x)
-  BIT (MULTIMODE);
-  BIT (AGGREGATE);
-  BIT (INVERT);
-#undef BIT
-  g_print ("\n");
-  if (capabilities & CRC_MULTIMODE)
-    {
-      (*p_WTInfoA) (WTI_CURSORS + index, CSR_MODE, &mode);
-      g_print ("MODE: %d\n", mode);
-    }
-  if (capabilities & CRC_AGGREGATE)
-    {
-      (*p_WTInfoA) (WTI_CURSORS + index, CSR_MINPKTDATA, &minpktdata);
-      g_print ("MINPKTDATA: %d\n", minpktdata);
-      (*p_WTInfoA) (WTI_CURSORS + index, CSR_MINBUTTONS, &minbuttons);
-      g_print ("MINBUTTONS: %d\n", minbuttons);
-    }
-}
-#endif
-#endif
-
-void
-_gdk_input_wintab_init_check (void)
-{
-  static gboolean wintab_initialized = FALSE;
-  GdkDevicePrivate *gdkdev;
-  GdkWindowAttr wa;
-  WORD specversion;
-  HCTX *hctx;
-  UINT ndevices, ncursors, ncsrtypes, firstcsr, hardware;
-  BOOL active;
-  DWORD physid;
-  AXIS axis_x, axis_y, axis_npressure, axis_or[3];
-  int i, k, n;
-  int devix, cursorix;
-  wchar_t devname[100], csrname[100];
-  gchar *devname_utf8, *csrname_utf8;
-  BOOL defcontext_done;
-  HMODULE wintab32;
-  char *wintab32_dll_path;
-  char dummy;
-
-  if (wintab_initialized)
-    return;
-  
-  wintab_initialized = TRUE;
-  
-  wintab_contexts = NULL;
-
-  if (_gdk_input_ignore_wintab)
-    return;
-
-  n = GetSystemDirectory (&dummy, 0);
-
-  if (n <= 0)
-    return;
-
-  wintab32_dll_path = g_malloc (n + 1 + strlen (WINTAB32_DLL));
-  k = GetSystemDirectory (wintab32_dll_path, n);
-  
-  if (k == 0 || k > n)
-    {
-      g_free (wintab32_dll_path);
-      return;
-    }
-
-  if (!G_IS_DIR_SEPARATOR (wintab32_dll_path[strlen (wintab32_dll_path) -1]))
-    strcat (wintab32_dll_path, G_DIR_SEPARATOR_S);
-  strcat (wintab32_dll_path, WINTAB32_DLL);
-
-  if ((wintab32 = LoadLibrary (wintab32_dll_path)) == NULL)
-    return;
-
-  if ((p_WTInfoA = (t_WTInfoA) GetProcAddress (wintab32, "WTInfoA")) == NULL)
-    return;
-  if ((p_WTInfoW = (t_WTInfoW) GetProcAddress (wintab32, "WTInfoW")) == NULL)
-    return;
-  if ((p_WTEnable = (t_WTEnable) GetProcAddress (wintab32, "WTEnable")) == NULL)
-    return;
-  if ((p_WTOpenA = (t_WTOpenA) GetProcAddress (wintab32, "WTOpenA")) == NULL)
-    return;
-  if ((p_WTGetA = (t_WTGetA) GetProcAddress (wintab32, "WTGetA")) == NULL)
-    return;
-  if ((p_WTSetA = (t_WTSetA) GetProcAddress (wintab32, "WTSetA")) == NULL)
-    return;
-  if ((p_WTOverlap = (t_WTOverlap) GetProcAddress (wintab32, "WTOverlap")) == NULL)
-    return;
-  if ((p_WTPacket = (t_WTPacket) GetProcAddress (wintab32, "WTPacket")) == NULL)
-    return;
-  if ((p_WTQueueSizeSet = (t_WTQueueSizeSet) GetProcAddress (wintab32, "WTQueueSizeSet")) == NULL)
-    return;
-    
-  if (!(*p_WTInfoA) (0, 0, NULL))
-    return;
-
-  (*p_WTInfoA) (WTI_INTERFACE, IFC_SPECVERSION, &specversion);
-  GDK_NOTE (INPUT, g_print ("Wintab interface version %d.%d\n",
-			    HIBYTE (specversion), LOBYTE (specversion)));
-  (*p_WTInfoA) (WTI_INTERFACE, IFC_NDEVICES, &ndevices);
-  (*p_WTInfoA) (WTI_INTERFACE, IFC_NCURSORS, &ncursors);
-#if DEBUG_WINTAB
-  GDK_NOTE (INPUT, g_print ("NDEVICES: %d, NCURSORS: %d\n",
-			    ndevices, ncursors));
-#endif
-  /* Create a dummy window to receive wintab events */
-  wa.wclass = GDK_INPUT_OUTPUT;
-  wa.event_mask = GDK_ALL_EVENTS_MASK;
-  wa.width = 2;
-  wa.height = 2;
-  wa.x = -100;
-  wa.y = -100;
-  wa.window_type = GDK_WINDOW_TOPLEVEL;
-  if ((wintab_window = gdk_window_new (NULL, &wa, GDK_WA_X|GDK_WA_Y)) == NULL)
-    {
-      g_warning ("gdk_input_wintab_init: gdk_window_new failed");
-      return;
-    }
-  g_object_ref (wintab_window);
-      
-  for (devix = 0; devix < ndevices; devix++)
-    {
-      LOGCONTEXT lc;
-      
-      /* We open the Wintab device (hmm, what if there are several, or
-       * can there even be several, probably not?) as a system
-       * pointing device, i.e. it controls the normal Windows
-       * cursor. This seems much more natural.
-       */
-
-      (*p_WTInfoW) (WTI_DEVICES + devix, DVC_NAME, devname);
-      devname_utf8 = g_utf16_to_utf8 (devname, -1, NULL, NULL, NULL);
-#ifdef DEBUG_WINTAB
-      GDK_NOTE (INPUT, (g_print("Device %d: %s\n", devix, devname_utf8)));
-#endif
-      (*p_WTInfoA) (WTI_DEVICES + devix, DVC_NCSRTYPES, &ncsrtypes);
-      (*p_WTInfoA) (WTI_DEVICES + devix, DVC_FIRSTCSR, &firstcsr);
-      (*p_WTInfoA) (WTI_DEVICES + devix, DVC_HARDWARE, &hardware);
-      (*p_WTInfoA) (WTI_DEVICES + devix, DVC_X, &axis_x);
-      (*p_WTInfoA) (WTI_DEVICES + devix, DVC_Y, &axis_y);
-      (*p_WTInfoA) (WTI_DEVICES + devix, DVC_NPRESSURE, &axis_npressure);
-      (*p_WTInfoA) (WTI_DEVICES + devix, DVC_ORIENTATION, axis_or);
-
-      defcontext_done = FALSE;
-      if (HIBYTE (specversion) > 1 || LOBYTE (specversion) >= 1)
-	{
-	  /* Try to get device-specific default context */
-	  /* Some drivers, e.g. Aiptek, don't provide this info */
-	  if ((*p_WTInfoA) (WTI_DSCTXS + devix, 0, &lc) > 0)
-	    defcontext_done = TRUE;
-#if DEBUG_WINTAB
-	  if (defcontext_done)
-	    GDK_NOTE (INPUT, (g_print("Using device-specific default context\n")));
-	  else
-	    GDK_NOTE (INPUT, (g_print("Note: Driver did not provide device specific default context info despite claiming to support version 1.1\n")));
-#endif
-	}
-
-      if (!defcontext_done)
-	(*p_WTInfoA) (WTI_DEFSYSCTX, 0, &lc);
-#if DEBUG_WINTAB
-      GDK_NOTE (INPUT, (g_print("Default context:\n"), print_lc(&lc)));
-#endif
-      lc.lcOptions |= CXO_MESSAGES | CXO_CSRMESSAGES;
-      lc.lcStatus = 0;
-      lc.lcMsgBase = WT_DEFBASE;
-      lc.lcPktRate = 0;
-      lc.lcPktData = PACKETDATA;
-      lc.lcPktMode = PACKETMODE;
-      lc.lcMoveMask = PACKETDATA;
-      lc.lcBtnUpMask = lc.lcBtnDnMask = ~0;
-      lc.lcOutOrgX = axis_x.axMin;
-      lc.lcOutOrgY = axis_y.axMin;
-      lc.lcOutExtX = axis_x.axMax - axis_x.axMin + 1;
-      lc.lcOutExtY = axis_y.axMax - axis_y.axMin + 1;
-      lc.lcOutExtY = -lc.lcOutExtY; /* We want Y growing downward */
-#if DEBUG_WINTAB
-      GDK_NOTE (INPUT, (g_print("context for device %d:\n", devix),
-			print_lc(&lc)));
-#endif
-      hctx = g_new (HCTX, 1);
-      if ((*hctx = (*p_WTOpenA) (GDK_WINDOW_HWND (wintab_window), &lc, TRUE)) == NULL)
-	{
-	  g_warning ("gdk_input_wintab_init: WTOpen failed");
-	  return;
-	}
-      GDK_NOTE (INPUT, g_print ("opened Wintab device %d %p\n",
-				devix, *hctx));
-      
-      wintab_contexts = g_list_append (wintab_contexts, hctx);
-
-      (*p_WTOverlap) (*hctx, TRUE);
-
-#if DEBUG_WINTAB
-      GDK_NOTE (INPUT, (g_print("context for device %d after WTOpen:\n", devix),
-			print_lc(&lc)));
-#endif
-      /* Increase packet queue size to reduce the risk of lost packets.
-       * According to the specs, if the function fails we must try again
-       * with a smaller queue size.
-       */
-      GDK_NOTE (INPUT, g_print("Attempting to increase queue size\n"));
-      for (i = 128; i >= 1; i >>= 1)
-	{
-	  if ((*p_WTQueueSizeSet) (*hctx, i))
-	    {
-	      GDK_NOTE (INPUT, g_print("Queue size set to %d\n", i));
-	      break;
-	    }
-	}
-      if (!i)
-	GDK_NOTE (INPUT, g_print("Whoops, no queue size could be set\n"));
-      for (cursorix = firstcsr; cursorix < firstcsr + ncsrtypes; cursorix++)
-	{
-#ifdef DEBUG_WINTAB
-	  GDK_NOTE (INPUT, (g_print("Cursor %d:\n", cursorix), print_cursor (cursorix)));
-#endif
-	  active = FALSE;
-	  (*p_WTInfoA) (WTI_CURSORS + cursorix, CSR_ACTIVE, &active);
-	  if (!active)
-	    continue;
-
-	  /* Wacom tablets seem to report cursors corresponding to
-	   * nonexistent pens or pucks. At least my ArtPad II reports
-	   * six cursors: a puck, pressure stylus and eraser stylus,
-	   * and then the same three again. I only have a
-	   * pressure-sensitive pen. The puck instances, and the
-	   * second instances of the styluses report physid zero. So
-	   * at least for Wacom, skip cursors with physid zero.
-	   */
-	  (*p_WTInfoA) (WTI_CURSORS + cursorix, CSR_PHYSID, &physid);
-	  if (wcscmp (devname, L"WACOM Tablet") == 0 && physid == 0)
-	    continue;
-
-	  gdkdev = g_object_new (GDK_TYPE_DEVICE, NULL);
-	  (*p_WTInfoW) (WTI_CURSORS + cursorix, CSR_NAME, csrname);
-	  csrname_utf8 = g_utf16_to_utf8 (csrname, -1, NULL, NULL, NULL);
-	  gdkdev->info.name = g_strconcat (devname_utf8, " ", csrname_utf8, NULL);
-	  g_free (csrname_utf8);
-	  gdkdev->info.source = GDK_SOURCE_PEN;
-	  gdkdev->info.mode = GDK_MODE_SCREEN;
-	  gdkdev->info.has_cursor = TRUE;
-	  gdkdev->hctx = *hctx;
-	  gdkdev->cursor = cursorix;
-	  (*p_WTInfoA) (WTI_CURSORS + cursorix, CSR_PKTDATA, &gdkdev->pktdata);
-	  gdkdev->info.num_axes = 0;
-	  if (gdkdev->pktdata & PK_X)
-	    gdkdev->info.num_axes++;
-	  if (gdkdev->pktdata & PK_Y)
-	    gdkdev->info.num_axes++;
-	  if (gdkdev->pktdata & PK_NORMAL_PRESSURE)
-	    gdkdev->info.num_axes++;
-	  /* The wintab driver for the Wacom ArtPad II reports
-	   * PK_ORIENTATION in CSR_PKTDATA, but the tablet doesn't
-	   * actually sense tilt. Catch this by noticing that the
-	   * orientation axis's azimuth resolution is zero.
-	   */
-	  if ((gdkdev->pktdata & PK_ORIENTATION)
-	      && axis_or[0].axResolution == 0)
-	    gdkdev->pktdata &= ~PK_ORIENTATION;
-	  
-	  if (gdkdev->pktdata & PK_ORIENTATION)
-	    gdkdev->info.num_axes += 2; /* x and y tilt */
-
-	  gdkdev->info.axes = g_new (GdkDeviceAxis, gdkdev->info.num_axes);
-	  gdkdev->axes = g_new (GdkAxisInfo, gdkdev->info.num_axes);
-	  gdkdev->last_axis_data = g_new (gint, gdkdev->info.num_axes);
-	  
-	  k = 0;
-	  if (gdkdev->pktdata & PK_X)
-	    {
-	      gdkdev->axes[k].resolution = axis_x.axResolution / 65535.;
-	      gdkdev->axes[k].min_value = axis_x.axMin;
-	      gdkdev->axes[k].max_value = axis_x.axMax;
-	      gdkdev->info.axes[k].use = GDK_AXIS_X;
-	      gdkdev->info.axes[k].min = axis_x.axMin;
-	      gdkdev->info.axes[k].max = axis_x.axMax;
-	      k++;
-	    }
-	  if (gdkdev->pktdata & PK_Y)
-	    {
-	      gdkdev->axes[k].resolution = axis_y.axResolution / 65535.;
-	      gdkdev->axes[k].min_value = axis_y.axMin;
-	      gdkdev->axes[k].max_value = axis_y.axMax;
-	      gdkdev->info.axes[k].use = GDK_AXIS_Y;
-	      gdkdev->info.axes[k].min = axis_y.axMin;
-	      gdkdev->info.axes[k].max = axis_y.axMax;
-	      k++;
-	    }
-	  if (gdkdev->pktdata & PK_NORMAL_PRESSURE)
-	    {
-	      gdkdev->axes[k].resolution = axis_npressure.axResolution / 65535.;
-	      gdkdev->axes[k].min_value = axis_npressure.axMin;
-	      gdkdev->axes[k].max_value = axis_npressure.axMax;
-	      gdkdev->info.axes[k].use = GDK_AXIS_PRESSURE;
-	      /* GIMP seems to expect values in the range 0-1 */
-	      gdkdev->info.axes[k].min = 0.0; /*axis_npressure.axMin;*/
-	      gdkdev->info.axes[k].max = 1.0; /*axis_npressure.axMax;*/
-	      k++;
-	    }
-	  if (gdkdev->pktdata & PK_ORIENTATION)
-	    {
-	      GdkAxisUse axis;
-	      
-	      gdkdev->orientation_axes[0] = axis_or[0];
-	      gdkdev->orientation_axes[1] = axis_or[1];
-	      for (axis = GDK_AXIS_XTILT; axis <= GDK_AXIS_YTILT; axis++)
-		{
-		  /* Wintab gives us aximuth and altitude, which
-		   * we convert to x and y tilt in the -1000..1000 range
-		   */
-		  gdkdev->axes[k].resolution = 1000;
-		  gdkdev->axes[k].min_value = -1000;
-		  gdkdev->axes[k].max_value = 1000;
-		  gdkdev->info.axes[k].use = axis;
-		  gdkdev->info.axes[k].min = -1.0;
-		  gdkdev->info.axes[k].max = 1.0;
-		  k++;
-		}
-	    }
-	  gdkdev->info.num_keys = 0;
-	  gdkdev->info.keys = NULL;
-	  GDK_NOTE (INPUT, g_print ("device: (%d) %s axes: %d\n",
-				    cursorix,
-				    gdkdev->info.name,
-				    gdkdev->info.num_axes));
-	  for (i = 0; i < gdkdev->info.num_axes; i++)
-	    GDK_NOTE (INPUT, g_print ("... axis %d: %d--%d@%d\n",
-				      i,
-				      gdkdev->axes[i].min_value, 
-				      gdkdev->axes[i].max_value, 
-				      gdkdev->axes[i].resolution));
-	  _gdk_input_devices = g_list_append (_gdk_input_devices,
-					      gdkdev);
-	}
-      g_free (devname_utf8);
-    }
-}
-
-static void
-decode_tilt (gint   *axis_data,
-	     AXIS   *axes,
-	     PACKET *packet)
-{
-  /* As I don't have a tilt-sensing tablet,
-   * I cannot test this code.
-   */
-  
-  double az, el;
-
-  az = TWOPI * packet->pkOrientation.orAzimuth /
-    (axes[0].axResolution / 65536.);
-  el = TWOPI * packet->pkOrientation.orAltitude /
-    (axes[1].axResolution / 65536.);
-  
-  /* X tilt */
-  axis_data[0] = cos (az) * cos (el) * 1000;
-  /* Y tilt */
-  axis_data[1] = sin (az) * cos (el) * 1000;
-}
-
-static void
-gdk_input_translate_coordinates (GdkDevicePrivate *gdkdev,
-				 GdkWindow        *window,
-				 gint             *axis_data,
-				 gdouble          *axis_out,
-				 gdouble          *x_out,
-				 gdouble          *y_out)
-{
-  GdkWindowObject *priv, *impl_window;
-  GdkWindowImplWin32 *root_impl;
-
-  int i;
-  int x_axis = 0;
-  int y_axis = 0;
-
-  double device_width, device_height, x_min, y_min;
-  double x_offset, y_offset, x_scale, y_scale;
-
-  priv = (GdkWindowObject *) window;
-  impl_window = (GdkWindowObject *)_gdk_window_get_impl_window (window);
-
-  for (i=0; i<gdkdev->info.num_axes; i++)
-    {
-      switch (gdkdev->info.axes[i].use)
-	{
-	case GDK_AXIS_X:
-	  x_axis = i;
-	  break;
-	case GDK_AXIS_Y:
-	  y_axis = i;
-	  break;
-	default:
-	  break;
-	}
-    }
-  
-  device_width = gdkdev->axes[x_axis].max_value - gdkdev->axes[x_axis].min_value;
-  x_min = gdkdev->axes[x_axis].min_value;
-  device_height = gdkdev->axes[y_axis].max_value - gdkdev->axes[y_axis].min_value;
-  y_min = gdkdev->axes[y_axis].min_value;
-
-  if (gdkdev->info.mode == GDK_MODE_SCREEN) 
-    {
-      root_impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (_gdk_root)->impl);
-      x_scale = GDK_WINDOW_OBJECT (_gdk_root)->width / device_width;
-      y_scale = GDK_WINDOW_OBJECT (_gdk_root)->height / device_height;
-
-      x_offset = - impl_window->input_window->root_x - priv->abs_x;
-      y_offset = - impl_window->input_window->root_y - priv->abs_y;
-    }
-  else				/* GDK_MODE_WINDOW */
-    {
-      double x_resolution = gdkdev->axes[x_axis].resolution;
-      double y_resolution = gdkdev->axes[y_axis].resolution;
-      double device_aspect = (device_height*y_resolution) / (device_width * x_resolution);
-
-      if (device_aspect * priv->width >= priv->height)
-	{
-	  /* device taller than window */
-	  x_scale = priv->width / device_width;
-	  y_scale = (x_scale * x_resolution) / y_resolution;
-
-	  x_offset = 0;
-	  y_offset = -(device_height * y_scale - priv->height) / 2;
-	}
-      else
-	{
-	  /* window taller than device */
-	  y_scale = priv->height / device_height;
-	  x_scale = (y_scale * y_resolution)  / x_resolution;
-
-	  y_offset = 0;
-	  x_offset = - (device_width * x_scale - priv->width) / 2;
-	}
-    }
-
-  for (i = 0; i < gdkdev->info.num_axes; i++)
-    {
-      switch (gdkdev->info.axes[i].use)
-	{
-	case GDK_AXIS_X:
-	  axis_out[i] = x_offset + x_scale * axis_data[x_axis];
-	  if (x_out)
-	    *x_out = axis_out[i];
-	  break;
-	case GDK_AXIS_Y:
-	  axis_out[i] = y_offset + y_scale * axis_data[y_axis];
-	  if (y_out)
-	    *y_out = axis_out[i];
-	  break;
-	default:
-	  axis_out[i] =
-	    (gdkdev->info.axes[i].max * (axis_data[i] - gdkdev->axes[i].min_value) +
-	     gdkdev->info.axes[i].min * (gdkdev->axes[i].max_value - axis_data[i])) /
-	    (gdkdev->axes[i].max_value - gdkdev->axes[i].min_value);
-	  break;
-	}
-    }
-}
-
-static void
-gdk_input_get_root_relative_geometry (HWND w,
-				      int  *x_ret,
-				      int  *y_ret)
-{
-  POINT pt;
-
-  pt.x = 0;
-  pt.y = 0;
-  ClientToScreen (w, &pt);
-
-  if (x_ret)
-    *x_ret = pt.x + _gdk_offset_x;
-  if (y_ret)
-    *y_ret = pt.y + _gdk_offset_y;
-}
-
-void
-_gdk_input_configure_event (GdkWindow         *window)
-{
-  GdkInputWindow *input_window;
-  GdkWindowObject *impl_window;
-  int root_x, root_y;
-
-  g_return_if_fail (window != NULL);
-
-  impl_window = (GdkWindowObject *)_gdk_window_get_impl_window (window);
-  input_window = impl_window->input_window;
-
-  gdk_input_get_root_relative_geometry (GDK_WINDOW_HWND (window),
-					&root_x, &root_y);
-
-  input_window->root_x = root_x;
-  input_window->root_y = root_y;
-}
-
-/*
- * Get the currently active keyboard modifiers (ignoring the mouse buttons)
- * We could use gdk_window_get_pointer but that function does a lot of other
- * expensive things besides getting the modifiers. This code is somewhat based
- * on build_pointer_event_state from gdkevents-win32.c
- */
-static guint
-get_modifier_key_state (void)
-{
-  guint state;
-  
-  state = 0;
-  /* High-order bit is up/down, low order bit is toggled/untoggled */
-  if (GetKeyState (VK_CONTROL) < 0)
-    state |= GDK_CONTROL_MASK;
-  if (GetKeyState (VK_SHIFT) < 0)
-    state |= GDK_SHIFT_MASK;
-  if (GetKeyState (VK_MENU) < 0)
-    state |= GDK_MOD1_MASK;
-  if (GetKeyState (VK_CAPITAL) & 0x1)
-    state |= GDK_LOCK_MASK;
-
-  return state;
-}
-
-#if 0
-static guint ignore_core_timer = 0;
-
-static gboolean
-ignore_core_timefunc (gpointer data)
-{
-  /* The delay has passed */
-  _gdk_input_ignore_core = FALSE;
-  ignore_core_timer = 0;
-
-  return FALSE; /* remove timeout */
-}
-
-/*
- * Set or unset the _gdk_input_ignore_core variable that tells GDK
- * to ignore events for the core pointer when the tablet is in proximity
- * The unsetting is delayed slightly so that if a tablet event arrives
- * just after proximity out, it does not cause a core pointer event
- * which e.g. causes GIMP to switch tools.
- */
-static void
-set_ignore_core (gboolean ignore)
-{
-  if (ignore)
-    {
-      _gdk_input_ignore_core = TRUE;
-      /* Remove any pending clear */
-      if (ignore_core_timer)
-        {
-	  g_source_remove (ignore_core_timer);
-	  ignore_core_timer = 0;
-	}
-    }
-  else
-    if (!ignore_core_timer)
-      ignore_core_timer = gdk_threads_add_timeout (PROXIMITY_OUT_DELAY,
-					 ignore_core_timefunc, NULL);
-}
-
-#endif
-
-void
-_gdk_input_update_for_device_mode (GdkDevicePrivate *gdkdev)
-{
-  LOGCONTEXT lc;
-
-  if (gdkdev != _gdk_device_in_proximity)
-    return;
-
-  if (p_WTGetA (gdkdev->hctx, &lc))
-    {
-      if (gdkdev->info.mode == GDK_MODE_SCREEN &&
-	  (lc.lcOptions & CXO_SYSTEM) == 0)
-	{
-	  lc.lcOptions |= CXO_SYSTEM;
-	  p_WTSetA (gdkdev->hctx, &lc);
-	}
-      else if (gdkdev->info.mode == GDK_MODE_WINDOW &&
-	       (lc.lcOptions & CXO_SYSTEM) != 0)
-	{
-	  lc.lcOptions &= ~CXO_SYSTEM;
-	  p_WTSetA (gdkdev->hctx, &lc);
-	}
-    }
-}
-
-static GdkWindow *
-find_window_for_input_event (MSG* msg, int *x, int *y)
-{
-  POINT pt;
-  GdkWindow *window;
-  HWND hwnd;
-  RECT rect;
-
-  pt = msg->pt;
-
-  window = NULL;
-  hwnd = WindowFromPoint (pt);
-  if (hwnd != NULL)
-    {
-      POINT client_pt = pt;
-
-      ScreenToClient (hwnd, &client_pt);
-      GetClientRect (hwnd, &rect);
-      if (PtInRect (&rect, client_pt))
-	window = gdk_win32_handle_table_lookup ((GdkNativeWindow) hwnd);
-    }
-
-  /* need to also adjust the coordinates to the new window */
-  if (window)
-    ScreenToClient (GDK_WINDOW_HWND (window), &pt);
-
-  *x = pt.x;
-  *y = pt.y;
-
-  if (window)
-    return window;
-
-  return _gdk_root;
-}
-
-gboolean 
-_gdk_input_other_event (GdkEvent  *event,
-			MSG       *msg,
-			GdkWindow *window)
-{
-  GdkWindowObject *obj, *impl_window;
-  GdkWindow *native_window;
-  GdkInputWindow *input_window;
-  GdkDevicePrivate *gdkdev = NULL;
-  guint key_state;
-
-  PACKET packet;
-  gint k;
-  gint x, y;
-  guint translated_buttons, button_diff, button_mask;
-  /* Translation from tablet button state to GDK button state for
-   * buttons 1-3 - swap button 2 and 3.
-   */
-  static guint button_map[8] = {0, 1, 4, 5, 2, 3, 6, 7};
-
-  if (window != wintab_window)
-    {
-      g_warning ("_gdk_input_other_event: not wintab_window?");
-      return FALSE;
-    }
-
-  native_window = find_window_for_input_event (msg, &x, &y);
-
-  GDK_NOTE (EVENTS_OR_INPUT,
-	    g_print ("_gdk_input_other_event: native_window=%p %+d%+d\n",
-		     GDK_WINDOW_HWND (native_window), x, y));
-
-  if (msg->message == WT_PACKET || msg->message == WT_CSRCHANGE)
-    {
-      if (!(*p_WTPacket) ((HCTX) msg->lParam, msg->wParam, &packet))
-	return FALSE;
-    }
-
-  switch (msg->message)
-    {
-    case WT_PACKET:
-      /* Don't produce any button or motion events while a window is being
-       * moved or resized, see bug #151090.
-       */
-      if (_modal_operation_in_progress)
-	{
-	  GDK_NOTE (EVENTS_OR_INPUT, g_print ("... ignored when moving/sizing\n"));
-	  return FALSE;
-	}
-
-      if ((gdkdev = gdk_input_find_dev_from_ctx ((HCTX) msg->lParam,
-						 packet.pkCursor)) == NULL)
-	return FALSE;
-
-      if (gdkdev->info.mode == GDK_MODE_DISABLED)
-	return FALSE;
-      
-      k = 0;
-      if (gdkdev->pktdata & PK_X)
-	gdkdev->last_axis_data[k++] = packet.pkX;
-      if (gdkdev->pktdata & PK_Y)
-	gdkdev->last_axis_data[k++] = packet.pkY;
-      if (gdkdev->pktdata & PK_NORMAL_PRESSURE)
-	gdkdev->last_axis_data[k++] = packet.pkNormalPressure;
-      if (gdkdev->pktdata & PK_ORIENTATION)
-	{
-	  decode_tilt (gdkdev->last_axis_data + k,
-		       gdkdev->orientation_axes, &packet);
-	  k += 2;
-	}
-
-      g_assert (k == gdkdev->info.num_axes);
-
-      translated_buttons = button_map[packet.pkButtons & 0x07] | (packet.pkButtons & ~0x07);
-
-      if (translated_buttons != gdkdev->button_state)
-	{
-	  /* At least one button has changed state so produce a button event
-	   * If more than one button has changed state (unlikely),
-	   * just care about the first and act on the next the next time
-	   * we get a packet
-	   */
-	  button_diff = translated_buttons ^ gdkdev->button_state;
-	  
-	  /* Gdk buttons are numbered 1.. */
-	  event->button.button = 1;
-
-	  for (button_mask = 1; button_mask != 0x80000000;
-	       button_mask <<= 1, event->button.button++)
-	    {
-	      if (button_diff & button_mask)
-	        {
-		  /* Found a button that has changed state */
-		  break;
-		}
-	    }
-
-	  if (!(translated_buttons & button_mask))
-	    event->any.type = GDK_BUTTON_RELEASE;
-	  else
-	    event->any.type = GDK_BUTTON_PRESS;
-	  gdkdev->button_state ^= button_mask;
-	}
-      else
-	{
-	  event->any.type = GDK_MOTION_NOTIFY;
-	}
-
-      if (native_window == _gdk_root)
-	return FALSE;
-
-      window = _gdk_window_get_input_window_for_event (native_window,
-						       event->any.type,
-						       gdkdev->button_state << 8,
-						       x, y, 0);
-
-      obj = GDK_WINDOW_OBJECT (window);
-
-      if (window == NULL ||
-	  obj->extension_events == 0)
-	return FALSE;
-      
-      impl_window = (GdkWindowObject *)_gdk_window_get_impl_window (window);
-      input_window = impl_window->input_window;
-
-      g_assert (input_window != NULL);
-
-      if (gdkdev->info.mode == GDK_MODE_WINDOW && 
-	  (obj->extension_events & GDK_ALL_DEVICES_MASK) == 0)
-	return FALSE;
-
-      event->any.window = window;
-      key_state = get_modifier_key_state ();
-      if (event->any.type == GDK_BUTTON_PRESS || 
-	  event->any.type == GDK_BUTTON_RELEASE)
-	{
-	  event->button.time = _gdk_win32_get_next_tick (msg->time);
-	  event->button.device = &gdkdev->info;
-	  
-	  event->button.axes = g_new(gdouble, gdkdev->info.num_axes);
-
-	  gdk_input_translate_coordinates (gdkdev, window,
-					   gdkdev->last_axis_data,
-					   event->button.axes,
-					   &event->button.x, 
-					   &event->button.y);
-
-	  /* Also calculate root coordinates. Note that input_window->root_x
-	     is in GDK root coordinates. */
-	  event->button.x_root = event->button.x + input_window->root_x;
-	  event->button.y_root = event->button.y + input_window->root_y;
-
-	  event->button.state = ((gdkdev->button_state << 8)
-				 & (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK
-				    | GDK_BUTTON3_MASK | GDK_BUTTON4_MASK
-				    | GDK_BUTTON5_MASK))
-				| key_state;
-	  GDK_NOTE (EVENTS_OR_INPUT,
-		    g_print ("WINTAB button %s:%d %g,%g\n",
-			     (event->button.type == GDK_BUTTON_PRESS ?
-			      "press" : "release"),
-			     event->button.button,
-			     event->button.x, event->button.y));
-	}
-      else
-	{
-	  event->motion.time = _gdk_win32_get_next_tick (msg->time);
-	  event->motion.is_hint = FALSE;
-	  event->motion.device = &gdkdev->info;
-
-	  event->motion.axes = g_new(gdouble, gdkdev->info.num_axes);
-
-	  gdk_input_translate_coordinates (gdkdev, window,
-					   gdkdev->last_axis_data,
-					   event->motion.axes,
-					   &event->motion.x, 
-					   &event->motion.y);
-
-	  /* Also calculate root coordinates. Note that input_window->root_x
-	     is in GDK root coordinates. */
-	  event->motion.x_root = event->motion.x + input_window->root_x;
-	  event->motion.y_root = event->motion.y + input_window->root_y;
-
-	  event->motion.state = ((gdkdev->button_state << 8)
-				 & (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK
-				    | GDK_BUTTON3_MASK | GDK_BUTTON4_MASK
-				    | GDK_BUTTON5_MASK))
-				| key_state;
-
-	  GDK_NOTE (EVENTS_OR_INPUT,
-		    g_print ("WINTAB motion: %g,%g\n",
-			     event->motion.x, event->motion.y));
-	}
-      return TRUE;
-
-    case WT_CSRCHANGE:
-      if ((gdkdev = gdk_input_find_dev_from_ctx ((HCTX) msg->lParam,
-						 packet.pkCursor)) == NULL)
-	return FALSE;
-
-      _gdk_device_in_proximity = gdkdev;
-
-      _gdk_input_update_for_device_mode (gdkdev);
-
-      window = NULL;
-      if (native_window != _gdk_root)
-	window = _gdk_window_get_input_window_for_event (native_window,
-							 GDK_PROXIMITY_IN,
-							 0,
-							 x, y, 0);
-      if (window)
-	{
-	  event->proximity.type = GDK_PROXIMITY_IN;
-	  event->proximity.window = window;
-	  event->proximity.time = _gdk_win32_get_next_tick (msg->time);
-	  event->proximity.device = &_gdk_device_in_proximity->info;
-	}
-
-      GDK_NOTE (EVENTS_OR_INPUT,
-		g_print ("WINTAB proximity in\n"));
-
-      return TRUE;
-
-    case WT_PROXIMITY:
-      /* TODO: Set ignore_core if in input_window */
-      if (LOWORD (msg->lParam) == 0)
-	{
-	  _gdk_input_in_proximity = FALSE;
-
-	  window = NULL;
-	  if (native_window != _gdk_root)
-	    window = _gdk_window_get_input_window_for_event (native_window,
-							     GDK_PROXIMITY_IN,
-							     0,
-							     x, y, 0);
-	  if (window)
-	    {
-	      event->proximity.type = GDK_PROXIMITY_OUT;
-	      event->proximity.window = window;
-	      event->proximity.time = _gdk_win32_get_next_tick (msg->time);
-	      event->proximity.device = &_gdk_device_in_proximity->info;
-	    }
-
-	  GDK_NOTE (EVENTS_OR_INPUT,
-		    g_print ("WINTAB proximity out\n"));
-
-	  return TRUE;
-	}
-      else
-	_gdk_input_in_proximity = TRUE;
-
-      _gdk_input_check_proximity ();
-
-      break;
-    }
-  return FALSE;
-}
-
-void
-_gdk_input_select_events (GdkWindow *impl_window)
-{
-  guint event_mask;
-  GdkWindowObject *w;
-  GdkInputWindow *iw;
-  GList *l, *dev_list;
-  
-
-  iw = ((GdkWindowObject *)impl_window)->input_window;
-
-  event_mask = 0;
-  for (dev_list = _gdk_input_devices; dev_list; dev_list = dev_list->next)
-    {
-      GdkDevicePrivate *gdkdev = dev_list->data;
-
-      if (!GDK_IS_CORE (gdkdev) &&
-	  gdkdev->info.mode != GDK_MODE_DISABLED &&
-	  iw != NULL)
-	{
-	  for (l = iw->windows; l != NULL; l = l->next)
-	    {
-	      w = l->data;
-	      if (gdkdev->info.has_cursor || (w->extension_events & GDK_ALL_DEVICES_MASK))
-		event_mask |= w->extension_events;
-	    }
-	}
-    }
-  
-  event_mask &= ~GDK_ALL_DEVICES_MASK;
-  if (event_mask)
-    event_mask |= 
-      GDK_PROXIMITY_OUT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK;
-
-  GDK_WINDOW_IMPL_WIN32 (((GdkWindowObject *)impl_window)->impl)->extension_events_mask = event_mask;
-}
-
-gint
-_gdk_input_grab_pointer (GdkWindow    *window,
-			 gint          owner_events,
-			 GdkEventMask  event_mask,
-			 GdkWindow    *confine_to,
-			 guint32       time)
-{
-  GDK_NOTE (INPUT, g_print ("_gdk_input_grab_pointer: %p %d %p\n",
-			   GDK_WINDOW_HWND (window),
-			   owner_events,
-			   (confine_to ? GDK_WINDOW_HWND (confine_to) : 0)));
-
-  return GDK_GRAB_SUCCESS;
-}
-
-void 
-_gdk_input_ungrab_pointer (guint32 time)
-{
-
-  GDK_NOTE (INPUT, g_print ("_gdk_input_ungrab_pointer\n"));
-
-}
-
-gboolean
-_gdk_device_get_history (GdkDevice         *device,
-			 GdkWindow         *window,
-			 guint32            start,
-			 guint32            stop,
-			 GdkTimeCoord    ***events,
-			 gint              *n_events)
-{
-  return FALSE;
-}
-
-void 
-gdk_device_get_state (GdkDevice       *device,
-		      GdkWindow       *window,
-		      gdouble         *axes,
-		      GdkModifierType *mask)
-{
-  g_return_if_fail (device != NULL);
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_IS_CORE (device))
-    {
-      gint x_int, y_int;
-      
-      gdk_window_get_pointer (window, &x_int, &y_int, mask);
-
-      if (axes)
-	{
-	  axes[0] = x_int;
-	  axes[1] = y_int;
-	}
-    }
-  else
-    {
-      GdkDevicePrivate *gdkdev;
-      
-      gdkdev = (GdkDevicePrivate *)device;
-      /* For now just use the last known button and axis state of the device.
-       * Since graphical tablets send an insane amount of motion events each
-       * second, the info should be fairly up to date */
-      if (mask)
-	{
-	  gdk_window_get_pointer (window, NULL, NULL, mask);
-	  *mask &= 0xFF; /* Mask away core pointer buttons */
-	  *mask |= ((gdkdev->button_state << 8)
-		    & (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK
-		       | GDK_BUTTON3_MASK | GDK_BUTTON4_MASK
-		       | GDK_BUTTON5_MASK));
-	}
-      /* For some reason, input_window is sometimes NULL when I use The GIMP 2
-       * (bug #141543?). Avoid crashing if debugging is disabled. */
-      if (axes && gdkdev->last_axis_data)
-	gdk_input_translate_coordinates (gdkdev, window,
-					 gdkdev->last_axis_data,
-					 axes, NULL, NULL);
-    }
-}
-
-void
-_gdk_input_set_tablet_active (void)
-{
-  GList *tmp_list;
-  HCTX *hctx;
-
-  /* Bring the contexts to the top of the overlap order when one of the
-   * application's windows is activated */
-  
-  if (!wintab_contexts)
-    return; /* No tablet devices found, or Wintab not initialized yet */
-  
-  GDK_NOTE (INPUT, g_print ("_gdk_input_set_tablet_active: "
-	"Bringing Wintab contexts to the top of the overlap order\n"));
-
-  tmp_list = wintab_contexts;
-  while (tmp_list)
-    {
-      hctx = (HCTX *) (tmp_list->data);
-      (*p_WTOverlap) (*hctx, TRUE);
-      tmp_list = tmp_list->next;
-    }
-}
-
-void 
-_gdk_input_init (GdkDisplay *display)
-{
-  _gdk_input_devices = NULL;
-
-  _gdk_init_input_core (display);
-#ifdef WINTAB_NO_LAZY_INIT
-  /* Normally, Wintab is only initialized when the application performs
-   * an action that requires it, such as enabling extended input events
-   * for a window or enumerating the devices.
-   */
-  _gdk_input_wintab_init_check ();
-#endif /* WINTAB_NO_LAZY_INIT */
-
-  _gdk_input_devices = g_list_append (_gdk_input_devices, display->core_pointer);
-}
-
diff --git a/gdk/win32/gdkinput-win32.h b/gdk/win32/gdkinput-win32.h
deleted file mode 100644
index 746bcaf..0000000
--- a/gdk/win32/gdkinput-win32.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#ifndef __GDK_INPUT_WIN32_H__
-#define __GDK_INPUT_WIN32_H__
-
-#include <windows.h>
-#include <wintab.h>
-
-typedef struct _GdkAxisInfo    GdkAxisInfo;
-typedef struct _GdkDevicePrivate GdkDevicePrivate;
-
-/* information about a device axis */
-struct _GdkAxisInfo
-{
-  /* calibrated resolution (for aspect ratio) - only relative values
-     between axes used */
-  gint resolution;
-  
-  /* calibrated minimum/maximum values */
-  gint min_value, max_value;
-};
-
-struct _GdkDeviceClass
-{
-  GObjectClass parent_class;
-};
-
-struct _GdkDevicePrivate
-{
-  GdkDevice info;
-
-  /* information about the axes */
-  GdkAxisInfo *axes;
-
-  gint button_state;
-
-  gint *last_axis_data;
-
-  /* WINTAB stuff: */
-  HCTX hctx;
-  /* Cursor number */
-  UINT cursor;
-  /* The cursor's CSR_PKTDATA */
-  WTPKT pktdata;
-  /* Azimuth and altitude axis */
-  AXIS orientation_axes[2];
-};
-
-/* Addition used for extension_events mask */
-#define GDK_ALL_DEVICES_MASK (1<<30)
-
-struct _GdkInputWindow
-{
-  /* gdk window */
-  GList *windows; /* GdkWindow:s with extension_events set */
-
-  GdkWindow *impl_window; /* an impl window */
-
-  /* position relative to root window */
-  gint root_x;
-  gint root_y;
-};
-
-/* Global data */
-
-#define GDK_IS_CORE(d) (((GdkDevice *)(d)) == gdk_display_get_default ()->core_pointer)
-
-extern GList *_gdk_input_devices;
-extern GList *_gdk_input_windows;
-
-extern gboolean _gdk_input_in_proximity;
-
-/* Function declarations */
-void             _gdk_init_input_core (GdkDisplay *display);
-
-GdkTimeCoord ** _gdk_device_allocate_history (GdkDevice *device,
-					      gint       n_events);
-
-/* The following functions are provided by each implementation
- * (just wintab for now)
- */
-void             _gdk_input_configure_event  (GdkWindow        *window);
-gboolean         _gdk_input_other_event      (GdkEvent         *event,
-					      MSG              *msg,
-					      GdkWindow        *window);
-
-void             _gdk_input_crossing_event   (GdkWindow        *window,
-					      gboolean          enter);
-
-
-/* These should be in gdkinternals.h */
-
-GdkInputWindow  *_gdk_input_window_find      (GdkWindow        *window);
-
-void             _gdk_input_window_destroy   (GdkWindow *window);
-
-void             _gdk_input_select_events    (GdkWindow        *impl_window);
-gint             _gdk_input_grab_pointer     (GdkWindow        *window,
-					      gint              owner_events,
-					      GdkEventMask      event_mask,
-					      GdkWindow        *confine_to,
-					      guint32           time);
-void             _gdk_input_ungrab_pointer   (guint32           time);
-gboolean         _gdk_device_get_history     (GdkDevice         *device,
-					      GdkWindow         *window,
-					      guint32            start,
-					      guint32            stop,
-					      GdkTimeCoord    ***events,
-					      gint              *n_events);
-
-void		_gdk_input_wintab_init_check (void);
-void		_gdk_input_set_tablet_active (void);
-void            _gdk_input_update_for_device_mode (GdkDevicePrivate *gdkdev);
-void            _gdk_input_check_proximity (void);
-
-#endif /* __GDK_INPUT_WIN32_H__ */
diff --git a/gdk/win32/gdkinput.c b/gdk/win32/gdkinput.c
deleted file mode 100644
index c386443..0000000
--- a/gdk/win32/gdkinput.c
+++ /dev/null
@@ -1,523 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-/* This file should really be one level up, in the backend-independent
- * GDK, and the x11/gdkinput.c could also be removed.
- * 
- * That stuff in x11/gdkinput.c which really *is* X11-dependent should
- * be in x11/gdkinput-x11.c.
- */
-
-#include "config.h"
-
-#include "gdkdisplay.h"
-#include "gdkinput.h"
-
-#include "gdkprivate-win32.h"
-#include "gdkinput-win32.h"
-
-static GdkDeviceAxis gdk_input_core_axes[] = {
-  { GDK_AXIS_X, 0, 0 },
-  { GDK_AXIS_Y, 0, 0 }
-};
-
-/* Global variables  */
-
-GList            *_gdk_input_devices;
-GList            *_gdk_input_windows;
-gboolean          _gdk_input_in_proximity = 0;
-gboolean          _gdk_input_inside_input_window = 0;
-
-void
-_gdk_init_input_core (GdkDisplay *display)
-{
-  display->core_pointer = g_object_new (GDK_TYPE_DEVICE, NULL);
-  
-  display->core_pointer->name = "Core Pointer";
-  display->core_pointer->source = GDK_SOURCE_MOUSE;
-  display->core_pointer->mode = GDK_MODE_SCREEN;
-  display->core_pointer->has_cursor = TRUE;
-  display->core_pointer->num_axes = 2;
-  display->core_pointer->axes = gdk_input_core_axes;
-  display->core_pointer->num_keys = 0;
-  display->core_pointer->keys = NULL;
-}
-
-GType
-gdk_device_get_type (void)
-{
-  static GType object_type = 0;
-
-  if (!object_type)
-    {
-      const GTypeInfo object_info =
-	{
-	  sizeof (GdkDeviceClass),
-	  (GBaseInitFunc) NULL,
-	  (GBaseFinalizeFunc) NULL,
-	  (GClassInitFunc) NULL,
-	  NULL,			/* class_finalize */
-	  NULL,			/* class_data */
-	  sizeof (GdkDevicePrivate),
-	  0,			/* n_preallocs */
-	  (GInstanceInitFunc) NULL,
-	};
-      
-      object_type = g_type_register_static (G_TYPE_OBJECT,
-                                            g_intern_static_string ("GdkDevice"),
-                                            &object_info, 0);
-    }
-  
-  return object_type;
-}
-
-GList *
-gdk_devices_list (void)
-{
-  return gdk_display_list_devices (_gdk_display);
-}
-
-GList *
-gdk_display_list_devices (GdkDisplay *dpy)
-{
-  g_return_val_if_fail (dpy == _gdk_display, NULL);
-
-  _gdk_input_wintab_init_check ();
-  return _gdk_input_devices;
-}
-
-const gchar *
-gdk_device_get_name (GdkDevice *device)
-{
-  g_return_val_if_fail (GDK_IS_DEVICE (device), NULL);
-
-  return device->name;
-}
-
-GdkInputSource
-gdk_device_get_source (GdkDevice *device)
-{
-  g_return_val_if_fail (GDK_IS_DEVICE (device), 0);
-
-  return device->source;
-}
-
-GdkInputMode
-gdk_device_get_mode (GdkDevice *device)
-{
-  g_return_val_if_fail (GDK_IS_DEVICE (device), 0);
-
-  return device->mode;
-}
-
-gboolean
-gdk_device_get_has_cursor (GdkDevice *device)
-{
-  g_return_val_if_fail (GDK_IS_DEVICE (device), FALSE);
-
-  return device->has_cursor;
-}
-
-void
-gdk_device_set_source (GdkDevice      *device,
-		       GdkInputSource  source)
-{
-  g_return_if_fail (device != NULL);
-
-  device->source = source;
-}
-
-void
-gdk_device_get_key (GdkDevice       *device,
-                    guint            index,
-                    guint           *keyval,
-                    GdkModifierType *modifiers)
-{
-  g_return_if_fail (GDK_IS_DEVICE (device));
-  g_return_if_fail (index < device->num_keys);
-
-  if (!device->keys[index].keyval &&
-      !device->keys[index].modifiers)
-    return;
-
-  if (keyval)
-    *keyval = device->keys[index].keyval;
-
-  if (modifiers)
-    *modifiers = device->keys[index].modifiers;
-}
-
-void
-gdk_device_set_key (GdkDevice      *device,
-		    guint           index,
-		    guint           keyval,
-		    GdkModifierType modifiers)
-{
-  g_return_if_fail (device != NULL);
-  g_return_if_fail (index < device->num_keys);
-
-  device->keys[index].keyval = keyval;
-  device->keys[index].modifiers = modifiers;
-}
-
-GdkAxisUse
-gdk_device_get_axis_use (GdkDevice *device,
-                         guint      index)
-{
-  g_return_val_if_fail (GDK_IS_DEVICE (device), GDK_AXIS_IGNORE);
-  g_return_val_if_fail (index < device->num_axes, GDK_AXIS_IGNORE);
-
-  return device->axes[index].use;
-}
-
-gint
-gdk_device_get_n_keys (GdkDevice *device)
-{
-  g_return_val_if_fail (GDK_IS_DEVICE (device), 0);
-
-  return device->num_keys;
-}
-
-gint
-gdk_device_get_n_axes (GdkDevice *device)
-{
-  g_return_val_if_fail (GDK_IS_DEVICE (device), 0);
-
-  return device->num_axes;
-}
-
-void
-gdk_device_set_axis_use (GdkDevice   *device,
-			 guint        index,
-			 GdkAxisUse   use)
-{
-  g_return_if_fail (device != NULL);
-  g_return_if_fail (index < device->num_axes);
-
-  device->axes[index].use = use;
-
-  switch (use)
-    {
-    case GDK_AXIS_X:
-    case GDK_AXIS_Y:
-      device->axes[index].min = 0.;
-      device->axes[index].max = 0.;
-      break;
-    case GDK_AXIS_XTILT:
-    case GDK_AXIS_YTILT:
-      device->axes[index].min = -1.;
-      device->axes[index].max = 1;
-      break;
-    default:
-      device->axes[index].min = 0.;
-      device->axes[index].max = 1;
-      break;
-    }
-}
-
-gboolean
-gdk_device_get_history  (GdkDevice         *device,
-			 GdkWindow         *window,
-			 guint32            start,
-			 guint32            stop,
-			 GdkTimeCoord    ***events,
-			 gint              *n_events)
-{
-  g_return_val_if_fail (window != NULL, FALSE);
-  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
-  g_return_val_if_fail (events != NULL, FALSE);
-  g_return_val_if_fail (n_events != NULL, FALSE);
-
-  if (n_events)
-    *n_events = 0;
-  if (events)
-    *events = NULL;
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return FALSE;
-    
-  if (GDK_IS_CORE (device))
-    return FALSE;
-  else
-    return _gdk_device_get_history (device, window, start, stop, events, n_events);
-}
-
-GdkTimeCoord ** 
-_gdk_device_allocate_history (GdkDevice *device,
-			      gint       n_events)
-{
-  GdkTimeCoord **result = g_new (GdkTimeCoord *, n_events);
-  gint i;
-
-  for (i=0; i<n_events; i++)
-    result[i] = g_malloc (sizeof (GdkTimeCoord) -
-			  sizeof (double) * (GDK_MAX_TIMECOORD_AXES - device->num_axes));
-
-  return result;
-}
-
-void 
-gdk_device_free_history (GdkTimeCoord **events,
-			 gint           n_events)
-{
-  gint i;
-  
-  for (i=0; i<n_events; i++)
-    g_free (events[i]);
-
-  g_free (events);
-}
-
-/* FIXME: this routine currently needs to be called between creation
-   and the corresponding configure event (because it doesn't get the
-   root_relative_geometry).  This should work with
-   gtk_window_set_extension_events, but will likely fail in other
-   cases */
-
-static void
-unset_extension_events (GdkWindow *window)
-{
-  GdkWindowObject *window_private;
-  GdkWindowObject *impl_window;
-  GdkInputWindow *iw;
-
-  window_private = (GdkWindowObject*) window;
-  impl_window = (GdkWindowObject *)_gdk_window_get_impl_window (window);
-  iw = impl_window->input_window;
-
-  if (window_private->extension_events != 0)
-    {
-      g_assert (iw != NULL);
-      g_assert (g_list_find (iw->windows, window) != NULL);
-
-      iw->windows = g_list_remove (iw->windows, window);
-      if (iw->windows == NULL)
-	{
-	  impl_window->input_window = NULL;
-	  _gdk_input_windows = g_list_remove(_gdk_input_windows,iw);
-	  g_free (iw);
-	}
-    }
-
-  window_private->extension_events = 0;
-}
-
-static void
-gdk_input_get_root_relative_geometry (HWND w,
-				      int  *x_ret,
-				      int  *y_ret)
-{
-  POINT pt;
-
-  pt.x = 0;
-  pt.y = 0;
-  ClientToScreen (w, &pt);
-
-  if (x_ret)
-    *x_ret = pt.x + _gdk_offset_x;
-  if (y_ret)
-    *y_ret = pt.y + _gdk_offset_y;
-}
-
-void
-gdk_input_set_extension_events (GdkWindow *window, gint mask,
-				GdkExtensionMode mode)
-{
-  GdkWindowObject *window_private;
-  GdkWindowObject *impl_window;
-  GdkInputWindow *iw;
-
-  g_return_if_fail (window != NULL);
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  window_private = (GdkWindowObject*) window;
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  impl_window = (GdkWindowObject *)_gdk_window_get_impl_window (window);
-
-  if (mode == GDK_EXTENSION_EVENTS_ALL && mask != 0)
-    mask |= GDK_ALL_DEVICES_MASK;
-
-  if (mode == GDK_EXTENSION_EVENTS_NONE)
-    mask = 0;
-
-  iw = impl_window->input_window;
-
-  if (mask != 0)
-    {
-      _gdk_input_wintab_init_check ();
-
-      if (!iw)
-	{
-	  iw = g_new0 (GdkInputWindow,1);
-
-	  iw->impl_window = (GdkWindow *)impl_window;
-
-	  iw->windows = NULL;
-
-	  _gdk_input_windows = g_list_append(_gdk_input_windows, iw);
-
-	  gdk_input_get_root_relative_geometry (GDK_WINDOW_HWND (window), &iw->root_x, &iw->root_y);
-
-	  impl_window->input_window = iw;
-	}
-
-      if (window_private->extension_events == 0)
-	iw->windows = g_list_append (iw->windows, window);
-      window_private->extension_events = mask;
-    }
-  else
-    {
-      unset_extension_events (window);
-    }
-
-  _gdk_input_select_events ((GdkWindow *)impl_window);
-}
-
-void
-_gdk_input_window_destroy (GdkWindow *window)
-{
-  unset_extension_events (window);
-}
-
-void
-_gdk_input_check_proximity (void)
-{
-  GList *l;
-  gboolean new_proximity = FALSE;
-
-  if (!_gdk_input_inside_input_window)
-    {
-      _gdk_display->ignore_core_events = FALSE;
-      return;
-    }
-
-  for (l = _gdk_input_devices; l != NULL; l = l->next)
-    {
-      GdkDevicePrivate *gdkdev = l->data;
-
-      if (gdkdev->info.mode != GDK_MODE_DISABLED &&
-	  !GDK_IS_CORE (gdkdev))
-	{
-	  if (_gdk_input_in_proximity)
-	    {
-	      new_proximity = TRUE;
-	      break;
-	    }
-	}
-    }
-
-  _gdk_display->ignore_core_events = new_proximity;
-}
-
-void
-_gdk_input_crossing_event (GdkWindow *window,
-			   gboolean enter)
-{
-  if (enter)
-    {
-      GdkWindowObject *priv = (GdkWindowObject *)window;
-      GdkInputWindow *input_window;
-      gint root_x, root_y;
-
-      _gdk_input_inside_input_window = TRUE;
-
-      input_window = priv->input_window;
-      if (input_window != NULL)
-	{
-	  gdk_input_get_root_relative_geometry (GDK_WINDOW_HWND (window), 
-						&root_x, &root_y);
-	  input_window->root_x = root_x;
-	  input_window->root_y = root_y;
-	}
-    }
-  else
-    {
-      _gdk_input_inside_input_window = FALSE;
-    }
-
-  _gdk_input_check_proximity ();
-}
-
-gboolean
-gdk_device_get_axis (GdkDevice  *device,
-		     gdouble    *axes,
-		     GdkAxisUse  use,
-		     gdouble    *value)
-{
-  gint i;
-  
-  g_return_val_if_fail (device != NULL, FALSE);
-
-  if (axes == NULL)
-    return FALSE;
-  
-  for (i=0; i<device->num_axes; i++)
-    if (device->axes[i].use == use)
-      {
-	if (value)
-	  *value = axes[i];
-	return TRUE;
-      }
-  
-  return FALSE;
-}
-
-gboolean
-gdk_device_set_mode (GdkDevice   *device,
-		     GdkInputMode mode)
-{
-  GList *tmp_list;
-  GdkDevicePrivate *gdkdev;
-  GdkInputWindow *input_window;
-
-  if (GDK_IS_CORE (device))
-    return FALSE;
-
-  gdkdev = (GdkDevicePrivate *)device;
-
-  if (device->mode == mode)
-    return TRUE;
-
-  device->mode = mode;
-
-  if (mode == GDK_MODE_WINDOW)
-    device->has_cursor = FALSE;
-  else if (mode == GDK_MODE_SCREEN)
-    device->has_cursor = TRUE;
-
-  for (tmp_list = _gdk_input_windows; tmp_list; tmp_list = tmp_list->next)
-    {
-      input_window = (GdkInputWindow *)tmp_list->data;
-      _gdk_input_select_events (input_window->impl_window);
-    }
-
-  if (!GDK_IS_CORE (gdkdev))
-    _gdk_input_update_for_device_mode (gdkdev);
-
-  return TRUE;
-}
diff --git a/gdk/win32/gdkkeys-win32.c b/gdk/win32/gdkkeys-win32.c
deleted file mode 100644
index 1dcc0f6..0000000
--- a/gdk/win32/gdkkeys-win32.c
+++ /dev/null
@@ -1,1675 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 2000 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/.
- */
-#include <ctype.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <limits.h>
-#include <errno.h>
-
-#include "gdk.h"
-
-#include "gdkprivate-win32.h"
-#include "gdkinternals.h"
-#include "gdkkeysyms.h"
-#include "gdkkeys.h"
-#include "gdkwin32keys.h"
-
-enum _GdkWin32KeyLevelState
-{
-  GDK_WIN32_LEVEL_NONE = 0,
-  GDK_WIN32_LEVEL_SHIFT,
-  GDK_WIN32_LEVEL_CAPSLOCK,
-  GDK_WIN32_LEVEL_SHIFT_CAPSLOCK,
-  GDK_WIN32_LEVEL_ALTGR,
-  GDK_WIN32_LEVEL_SHIFT_ALTGR,
-  GDK_WIN32_LEVEL_CAPSLOCK_ALTGR,
-  GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR,
-  GDK_WIN32_LEVEL_COUNT
-};
-
-typedef enum _GdkWin32KeyLevelState GdkWin32KeyLevelState;
-
-struct _GdkWin32KeyNode
-{
-  /* Non-spacing version of the dead key */
-  guint                  undead_gdk_keycode;
-
-  /* Virtual key code */
-  guint8                 vk;
-
-  /* Level for which this virtual key code produces this gdk_keycode */
-  GdkWin32KeyLevelState  level;
-
-  /* GDK (X11) code for this key */
-  guint                  gdk_keycode;
-
-  /* Array of GdkWin32KeyNode should be sorted by gdk_keycode, then by level */
-  GArray                *combinations;
-};
-
-typedef struct _GdkWin32KeyNode GdkWin32KeyNode;
-
-/*
-Example:
-  GdkWin32KeyNode
-  {
-    undead_gdk_keycode = 0x0b4 GDK_KEY_acute (')
-    vk = 0xde VK_OEM_7
-    level = GDK_WIN32_LEVEL_NONE
-    gdk_keycode = 0xfe51 GDK_KEY_dead_acute
-    combinations = 
-    {
-      GdkWin32KeyNode
-      {
-        undead_gdk_keycode = 0x061 GDK_KEY_a (a)
-        level = GDK_WIN32_LEVEL_NONE
-        vk = 0x41 VK_A
-        gdk_keycode = 0xe1 GDK_KEY_aacute 
-        combinations = NULL
-      },
-      GdkWin32KeyNode
-      {
-        unicode_char = 0x041 GDK_KEY_A (A)
-        level = GDK_WIN32_LEVEL_SHIFT
-        vk = 0x41 VK_A
-        gdk_keycode = 0x0c1 GDK_KEY_Aacute 
-        combinations = NULL
-      },
-      { ... }
-    }
-  }
-
-Thus:
-
-GDK_KEY_dead_acute + GDK_KEY_a
-= GDK_KEY_aacute
-
-GDK_KEY_dead_acute + GDK_KEY_A
-= GDK_KEY_Aacute
-
-GDK_KEY_dead_acute + GDK_KEY_s
-matches partially
-(GDK_KEY_dead_acute is a known dead key, but does not combine with GDK_KEY_s)
-and resolves into:
-GDK_KEY_acute + GDK_KEY_s
-
-GDK_KEY_dead_somethingelse + GDK_KEY_anything
-does not match at all
-(W32 API did not provide any deadkey info for GDK_KEY_dead_somethingelse)
-and the caller will try other matching mechanisms for compose_buffer
-*/
-
-struct _GdkWin32KeyGroupOptions
-{
-  /* character that should be used as the decimal separator */
-  wchar_t         decimal_mark;
-
-  /* Scancode for the VK_RSHIFT */
-  guint           scancode_rshift;
-
-  /* TRUE if Ctrl+Alt emulates AltGr */
-  gboolean        has_altgr;
-
-  GArray         *dead_keys;
-};
-
-typedef struct _GdkWin32KeyGroupOptions GdkWin32KeyGroupOptions;
-
-struct _GdkWin32KeymapClass
-{
-  GdkKeymapClass parent_class;
-};
-
-struct _GdkWin32Keymap
-{
-  GdkKeymap parent_instance;
-
-  /* length = what GetKeyboardLayoutList() returns, type = HKL.
-   * When it changes, recreate the keymap and repopulate the options.
-   */
-  GArray *layout_handles;
-
-  /* VirtualKeyCode -> gdk_keyval table
-   * length = 256 * length(layout_handles) * 2 * 4
-   * 256 is the number of virtual key codes,
-   * 2x4 is the number of Shift/AltGr/CapsLock combinations (level),
-   * length(layout_handles) is the number of layout handles (group).
-   */
-  guint  *keysym_tab;
-
-  /* length = length(layout_handles), type =  GdkWin32KeyGroupOptions
-   * Kept separate from layout_handles because layout_handles is
-   * populated by W32 API.
-   */
-  GArray *options;
-
-  /* Index of a handle in layout_handles,
-   * at any point it should be the same handle as GetKeyboardLayout(0) returns,
-   * but GDK caches it to avoid calling GetKeyboardLayout (0) every time.
-   */
-  guint8 active_layout;
-};
-
-G_DEFINE_TYPE (GdkWin32Keymap, gdk_win32_keymap, GDK_TYPE_KEYMAP)
-
-guint _gdk_keymap_serial = 0;
-
-static GdkKeymap *default_keymap = NULL;
-
-#define KEY_STATE_SIZE 256
-
-static void update_keymap (GdkKeymap *gdk_keymap);
-
-static void
-gdk_win32_key_group_options_clear (GdkWin32KeyGroupOptions *options)
-{
-  g_clear_pointer (&options->dead_keys, g_array_unref);
-}
-
-static void
-gdk_win32_key_node_clear (GdkWin32KeyNode *node)
-{
-  g_clear_pointer (&node->combinations, g_array_unref);
-}
-
-static void
-gdk_win32_keymap_init (GdkWin32Keymap *keymap)
-{
-  keymap->layout_handles = g_array_new (FALSE, FALSE, sizeof (HKL));
-  keymap->options = g_array_new (FALSE, FALSE, sizeof (GdkWin32KeyGroupOptions));
-  g_array_set_clear_func (keymap->options, (GDestroyNotify) gdk_win32_key_group_options_clear);
-  keymap->keysym_tab = NULL;
-  keymap->active_layout = 0;
-  update_keymap (GDK_KEYMAP (keymap));
-}
-
-static void
-gdk_win32_keymap_finalize (GObject *object)
-{
-  GdkWin32Keymap *keymap = GDK_WIN32_KEYMAP (object);
-
-  g_clear_pointer (&keymap->keysym_tab, g_free);
-  g_clear_pointer (&keymap->layout_handles, g_array_unref);
-  g_clear_pointer (&keymap->options, g_array_unref);
-
-  G_OBJECT_CLASS (gdk_win32_keymap_parent_class)->finalize (object);
-}
-
-#ifdef G_ENABLE_DEBUG
-static void
-print_keysym_tab (GdkWin32Keymap *keymap)
-{
-  gint                      li;
-  GdkWin32KeyGroupOptions  *options;
-  gint                      vk;
-  GdkWin32KeyLevelState     level;
-  gint                      group_size = keymap->layout_handles->len;
-
-  for (li = 0; li < group_size; li++)
-    {
-      options = &g_array_index (keymap->options, GdkWin32KeyGroupOptions, li);
-      g_print ("keymap %d (0x%p):%s\n",
-               li, g_array_index (keymap->layout_handles, HKL, li),
-               options->has_altgr ? " (uses AltGr)" : "");
-
-      for (vk = 0; vk < KEY_STATE_SIZE; vk++)
-        {
-          g_print ("%#.02x: ", vk);
-
-          for (level = 0; level < GDK_WIN32_LEVEL_COUNT; level++)
-            {
-              gchar *name = gdk_keyval_name (keymap->keysym_tab[vk * group_size * GDK_WIN32_LEVEL_COUNT + level]);
-
-              g_print ("%s ", name ? name : "(none)");
-            }
-
-          g_print ("\n");
-        }
-     }
-}
-#endif
-
-static void
-handle_special (guint  vk,
-		guint *ksymp,
-		gint   shift)
-
-{
-  switch (vk)
-    {
-    case VK_CANCEL:
-      *ksymp = GDK_KEY_Cancel; break;
-    case VK_BACK:
-      *ksymp = GDK_KEY_BackSpace; break;
-    case VK_TAB:
-      if (shift & 0x1)
-	*ksymp = GDK_KEY_ISO_Left_Tab;
-      else
-	*ksymp = GDK_KEY_Tab;
-      break;
-    case VK_CLEAR:
-      *ksymp = GDK_KEY_Clear; break;
-    case VK_RETURN:
-      *ksymp = GDK_KEY_Return; break;
-    case VK_SHIFT:
-    case VK_LSHIFT:
-      *ksymp = GDK_KEY_Shift_L; break;
-    case VK_CONTROL:
-    case VK_LCONTROL:
-      *ksymp = GDK_KEY_Control_L; break;
-    case VK_MENU:
-    case VK_LMENU:
-      *ksymp = GDK_KEY_Alt_L; break;
-    case VK_PAUSE:
-      *ksymp = GDK_KEY_Pause; break;
-    case VK_ESCAPE:
-      *ksymp = GDK_KEY_Escape; break;
-    case VK_PRIOR:
-      *ksymp = GDK_KEY_Prior; break;
-    case VK_NEXT:
-      *ksymp = GDK_KEY_Next; break;
-    case VK_END:
-      *ksymp = GDK_KEY_End; break;
-    case VK_HOME:
-      *ksymp = GDK_KEY_Home; break;
-    case VK_LEFT:
-      *ksymp = GDK_KEY_Left; break;
-    case VK_UP:
-      *ksymp = GDK_KEY_Up; break;
-    case VK_RIGHT:
-      *ksymp = GDK_KEY_Right; break;
-    case VK_DOWN:
-      *ksymp = GDK_KEY_Down; break;
-    case VK_SELECT:
-      *ksymp = GDK_KEY_Select; break;
-    case VK_PRINT:
-      *ksymp = GDK_KEY_Print; break;
-    case VK_SNAPSHOT:
-      *ksymp = GDK_KEY_Print; break;
-    case VK_EXECUTE:
-      *ksymp = GDK_KEY_Execute; break;
-    case VK_INSERT:
-      *ksymp = GDK_KEY_Insert; break;
-    case VK_DELETE:
-      *ksymp = GDK_KEY_Delete; break;
-    case VK_HELP:
-      *ksymp = GDK_KEY_Help; break;
-    case VK_LWIN:
-      *ksymp = GDK_KEY_Meta_L; break;
-    case VK_RWIN:
-      *ksymp = GDK_KEY_Meta_R; break;
-    case VK_APPS:
-      *ksymp = GDK_KEY_Menu; break;
-    case VK_DECIMAL:
-      *ksymp = GDK_KEY_KP_Decimal; break;
-    case VK_MULTIPLY:
-      *ksymp = GDK_KEY_KP_Multiply; break;
-    case VK_ADD:
-      *ksymp = GDK_KEY_KP_Add; break;
-    case VK_SEPARATOR:
-      *ksymp = GDK_KEY_KP_Separator; break;
-    case VK_SUBTRACT:
-      *ksymp = GDK_KEY_KP_Subtract; break;
-    case VK_DIVIDE:
-      *ksymp = GDK_KEY_KP_Divide; break;
-    case VK_NUMPAD0:
-      *ksymp = GDK_KEY_KP_0; break;
-    case VK_NUMPAD1:
-      *ksymp = GDK_KEY_KP_1; break;
-    case VK_NUMPAD2:
-      *ksymp = GDK_KEY_KP_2; break;
-    case VK_NUMPAD3:
-      *ksymp = GDK_KEY_KP_3; break;
-    case VK_NUMPAD4:
-      *ksymp = GDK_KEY_KP_4; break;
-    case VK_NUMPAD5:
-      *ksymp = GDK_KEY_KP_5; break;
-    case VK_NUMPAD6:
-      *ksymp = GDK_KEY_KP_6; break;
-    case VK_NUMPAD7:
-      *ksymp = GDK_KEY_KP_7; break;
-    case VK_NUMPAD8:
-      *ksymp = GDK_KEY_KP_8; break;
-    case VK_NUMPAD9:
-      *ksymp = GDK_KEY_KP_9; break;
-    case VK_F1:
-      *ksymp = GDK_KEY_F1; break;
-    case VK_F2:
-      *ksymp = GDK_KEY_F2; break;
-    case VK_F3:
-      *ksymp = GDK_KEY_F3; break;
-    case VK_F4:
-      *ksymp = GDK_KEY_F4; break;
-    case VK_F5:
-      *ksymp = GDK_KEY_F5; break;
-    case VK_F6:
-      *ksymp = GDK_KEY_F6; break;
-    case VK_F7:
-      *ksymp = GDK_KEY_F7; break;
-    case VK_F8:
-      *ksymp = GDK_KEY_F8; break;
-    case VK_F9:
-      *ksymp = GDK_KEY_F9; break;
-    case VK_F10:
-      *ksymp = GDK_KEY_F10; break;
-    case VK_F11:
-      *ksymp = GDK_KEY_F11; break;
-    case VK_F12:
-      *ksymp = GDK_KEY_F12; break;
-    case VK_F13:
-      *ksymp = GDK_KEY_F13; break;
-    case VK_F14:
-      *ksymp = GDK_KEY_F14; break;
-    case VK_F15:
-      *ksymp = GDK_KEY_F15; break;
-    case VK_F16:
-      *ksymp = GDK_KEY_F16; break;
-    case VK_F17:
-      *ksymp = GDK_KEY_F17; break;
-    case VK_F18:
-      *ksymp = GDK_KEY_F18; break;
-    case VK_F19:
-      *ksymp = GDK_KEY_F19; break;
-    case VK_F20:
-      *ksymp = GDK_KEY_F20; break;
-    case VK_F21:
-      *ksymp = GDK_KEY_F21; break;
-    case VK_F22:
-      *ksymp = GDK_KEY_F22; break;
-    case VK_F23:
-      *ksymp = GDK_KEY_F23; break;
-    case VK_F24:
-      *ksymp = GDK_KEY_F24; break;
-    case VK_NUMLOCK:
-      *ksymp = GDK_KEY_Num_Lock; break;
-    case VK_SCROLL:
-      *ksymp = GDK_KEY_Scroll_Lock; break;
-    case VK_RSHIFT:
-      *ksymp = GDK_KEY_Shift_R; break;
-    case VK_RCONTROL:
-      *ksymp = GDK_KEY_Control_R; break;
-    case VK_RMENU:
-      *ksymp = GDK_KEY_Alt_R; break;
-    }
-}
-
-static void
-set_level_vks (guchar               *key_state,
-	       GdkWin32KeyLevelState level)
-{
-  switch (level)
-    {
-    case GDK_WIN32_LEVEL_NONE:
-      key_state[VK_SHIFT] = 0;
-      key_state[VK_CAPITAL] = 0;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0;
-      break;
-    case GDK_WIN32_LEVEL_SHIFT:
-      key_state[VK_SHIFT] = 0x80;
-      key_state[VK_CAPITAL] = 0;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0;
-      break;
-    case GDK_WIN32_LEVEL_CAPSLOCK:
-      key_state[VK_SHIFT] = 0;
-      key_state[VK_CAPITAL] = 0x01;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0;
-      break;
-    case GDK_WIN32_LEVEL_SHIFT_CAPSLOCK:
-      key_state[VK_SHIFT] = 0x80;
-      key_state[VK_CAPITAL] = 0x01;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0;
-      break;
-    case GDK_WIN32_LEVEL_ALTGR:
-      key_state[VK_SHIFT] = 0;
-      key_state[VK_CAPITAL] = 0;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0x80;
-      break;
-    case GDK_WIN32_LEVEL_SHIFT_ALTGR:
-      key_state[VK_SHIFT] = 0x80;
-      key_state[VK_CAPITAL] = 0;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0x80;
-      break;
-    case GDK_WIN32_LEVEL_CAPSLOCK_ALTGR:
-      key_state[VK_SHIFT] = 0;
-      key_state[VK_CAPITAL] = 0x01;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0x80;
-      break;
-    case GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR:
-      key_state[VK_SHIFT] = 0x80;
-      key_state[VK_CAPITAL] = 0x01;
-      key_state[VK_CONTROL] = key_state[VK_MENU] = 0x80;
-      break;
-    case GDK_WIN32_LEVEL_COUNT:
-      g_assert_not_reached ();
-      break;
-    }
-}
-
-static void
-reset_after_dead (guchar key_state[KEY_STATE_SIZE],
-                  HKL    handle)
-{
-  guchar  temp_key_state[KEY_STATE_SIZE];
-  wchar_t wcs[2];
-
-  memmove (temp_key_state, key_state, KEY_STATE_SIZE);
-
-  temp_key_state[VK_SHIFT] =
-    temp_key_state[VK_CONTROL] =
-    temp_key_state[VK_CAPITAL] =
-    temp_key_state[VK_MENU] = 0;
-
-  ToUnicodeEx (VK_SPACE, MapVirtualKey (VK_SPACE, 0),
-	       temp_key_state, wcs, G_N_ELEMENTS (wcs),
-	       0, handle);
-}
-
-static void
-handle_dead (guint  keysym,
-	     guint *ksymp)
-{
-  switch (keysym)
-    {
-    case '"': /* 0x022 */
-      *ksymp = GDK_KEY_dead_diaeresis; break;
-    case '\'': /* 0x027 */
-      *ksymp = GDK_KEY_dead_acute; break;
-    case GDK_KEY_asciicircum: /* 0x05e */
-      *ksymp = GDK_KEY_dead_circumflex; break;
-    case GDK_KEY_grave:	/* 0x060 */
-      *ksymp = GDK_KEY_dead_grave; break;
-    case GDK_KEY_asciitilde: /* 0x07e */
-      *ksymp = GDK_KEY_dead_tilde; break;
-    case GDK_KEY_diaeresis: /* 0x0a8 */
-      *ksymp = GDK_KEY_dead_diaeresis; break;
-    case GDK_KEY_degree: /* 0x0b0 */
-      *ksymp = GDK_KEY_dead_abovering; break;
-    case GDK_KEY_acute:	/* 0x0b4 */
-      *ksymp = GDK_KEY_dead_acute; break;
-    case GDK_KEY_periodcentered: /* 0x0b7 */
-      *ksymp = GDK_KEY_dead_abovedot; break;
-    case GDK_KEY_cedilla: /* 0x0b8 */
-      *ksymp = GDK_KEY_dead_cedilla; break;
-    case GDK_KEY_breve:	/* 0x1a2 */
-      *ksymp = GDK_KEY_dead_breve; break;
-    case GDK_KEY_ogonek: /* 0x1b2 */
-      *ksymp = GDK_KEY_dead_ogonek; break;
-    case GDK_KEY_caron:	/* 0x1b7 */
-      *ksymp = GDK_KEY_dead_caron; break;
-    case GDK_KEY_doubleacute: /* 0x1bd */
-      *ksymp = GDK_KEY_dead_doubleacute; break;
-    case GDK_KEY_abovedot: /* 0x1ff */
-      *ksymp = GDK_KEY_dead_abovedot; break;
-    case 0x1000384: /* Greek tonos */
-      *ksymp = GDK_KEY_dead_acute; break;
-    case GDK_KEY_Greek_accentdieresis: /* 0x7ae */
-      *ksymp = GDK_KEY_Greek_accentdieresis; break;
-    default:
-      /* By default use the keysym as such. This takes care of for
-       * instance the dead U+09CD (BENGALI VIRAMA) on the ekushey
-       * Bengali layout.
-       */
-      *ksymp = keysym; break;
-    }
-}
-
-/* keypad decimal mark depends on active keyboard layout
-   return current decimal mark as unicode character
-   */
-guint32
-_gdk_win32_keymap_get_decimal_mark (GdkWin32Keymap *keymap)
-{
-  if (keymap != NULL &&
-      keymap->layout_handles->len > 0 &&
-      g_array_index (keymap->options, GdkWin32KeyGroupOptions, keymap->active_layout).decimal_mark)
-    return g_array_index (keymap->options, GdkWin32KeyGroupOptions, keymap->active_layout).decimal_mark;
-
-  return (guint32) '.';
-}
-
-static gboolean
-layouts_are_the_same (GArray *array, HKL *hkls, gint hkls_len)
-{
-  gint i;
-
-  if (hkls_len != array->len)
-    return FALSE;
-
-  for (i = 0; i < hkls_len; i++)
-    if (hkls[i] != g_array_index (array, HKL, i))
-      return FALSE;
-
-  return TRUE;
-}
-
-static void
-check_that_active_layout_is_in_sync (GdkWin32Keymap *keymap)
-{
-  HKL     hkl;
-  HKL     cached_hkl;
-  wchar_t hkl_name[KL_NAMELENGTH];
-
-  if (keymap->layout_handles->len <= 0)
-    return;
-
-  hkl = GetKeyboardLayout (0);
-  cached_hkl = g_array_index (keymap->layout_handles, HKL, keymap->active_layout);
-
-  if (hkl != cached_hkl)
-    {
-      if (!GetKeyboardLayoutNameW (hkl_name))
-        wcsncpy (hkl_name, L"(NULL)", KL_NAMELENGTH);
-
-      g_warning ("Cached active layout #%d (0x%p) does not match actual layout %S, 0x%p",
-                 keymap->active_layout, cached_hkl, hkl_name, hkl);
-    }
-}
-
-static gint
-sort_key_nodes_by_gdk_keyval (gconstpointer a,
-                              gconstpointer b)
-{
-  const GdkWin32KeyNode *one = a;
-  const GdkWin32KeyNode *two = b;
-
-  if (one->gdk_keycode < two->gdk_keycode)
-    return -1;
-  else if (one->gdk_keycode > two->gdk_keycode)
-    return 1;
-
-  if (one->level < two->level)
-    return -1;
-  else if (one->level > two->level)
-    return 1;
-
-  return 0;
-}
-
-static void
-update_keymap (GdkKeymap *gdk_keymap)
-{
-  int                      hkls_len;
-  static int               hkls_size = 0;
-  static HKL              *hkls = NULL;
-  gboolean                 no_list;
-  static guint             current_serial = 0;
-  gint                     i, group;
-  GdkWin32KeyLevelState    level;
-  GdkWin32KeyGroupOptions *options;
-  GdkWin32Keymap          *keymap = GDK_WIN32_KEYMAP (gdk_keymap);
-  gint                     keysym_tab_size;
-
-  guchar                   key_state[KEY_STATE_SIZE];
-  guint                    scancode;
-  guint                    vk;
-  guint                   *keygroup;
-
-  if (keymap->keysym_tab != NULL &&
-      current_serial == _gdk_keymap_serial)
-    return;
-
-  no_list = FALSE;
-  hkls_len = GetKeyboardLayoutList (0, NULL);
-
-  if (hkls_len <= 0)
-    {
-      hkls_len = 1;
-      no_list = TRUE;
-    }
-  else if (hkls_len > 255)
-    {
-      hkls_len = 255;
-    }
-
-  if (hkls_size < hkls_len)
-    {
-      hkls = g_renew (HKL, hkls, hkls_len);
-      hkls_size = hkls_len;
-    }
-
-  if (hkls_len != GetKeyboardLayoutList (hkls_len, hkls))
-    {
-      if (!no_list)
-        return;
-
-      hkls[0] = GetKeyboardLayout (0);
-      hkls_len = 1;
-    }
-
-  if (layouts_are_the_same (keymap->layout_handles, hkls, hkls_len))
-    {
-      check_that_active_layout_is_in_sync (keymap);
-      current_serial = _gdk_keymap_serial;
-
-      return;
-    }
-
-  GDK_NOTE (EVENTS, g_print ("\nHave %d keyboard layouts:", hkls_len));
-
-  for (i = 0; i < hkls_len; i++)
-    {
-      GDK_NOTE (EVENTS, g_print (" 0x%p", hkls[i]));
-
-      if (GetKeyboardLayout (0) == hkls[i])
-        {
-          wchar_t hkl_name[KL_NAMELENGTH];
-
-          if (!GetKeyboardLayoutNameW (hkl_name))
-            wcsncpy (hkl_name, L"(NULL)", KL_NAMELENGTH);
-
-          GDK_NOTE (EVENTS, g_print ("(active, %S)", hkl_name));
-        }
-    }
-
-  GDK_NOTE (EVENTS, g_print ("\n"));
-
-  keysym_tab_size = hkls_len * 256 * 2 * 4;
-
-  if (hkls_len != keymap->layout_handles->len)
-    keymap->keysym_tab = g_renew (guint, keymap->keysym_tab, keysym_tab_size);
-
-  memset (keymap->keysym_tab, 0, keysym_tab_size);
-  g_array_set_size (keymap->layout_handles, hkls_len);
-  g_array_set_size (keymap->options, hkls_len);
-
-  for (i = 0; i < hkls_len; i++)
-    {
-      options = &g_array_index (keymap->options, GdkWin32KeyGroupOptions, i);
-
-      options->decimal_mark = 0;
-      options->scancode_rshift = 0;
-      options->has_altgr = FALSE;
-      options->dead_keys = g_array_new (FALSE, FALSE, sizeof (GdkWin32KeyNode));
-      g_array_set_clear_func (options->dead_keys, (GDestroyNotify) gdk_win32_key_node_clear);
-
-      g_array_index (keymap->layout_handles, HKL, i) = hkls[i];
-
-      if (hkls[i] == _gdk_input_locale)
-        keymap->active_layout = i;
-    }
-
-  for (vk = 0; vk < KEY_STATE_SIZE; vk++)
-    {
-      for (group = 0; group < hkls_len; group++)
-        {
-          options = &g_array_index (keymap->options, GdkWin32KeyGroupOptions, group);
-          scancode = MapVirtualKeyEx (vk, 0, hkls[group]);
-          keygroup = &keymap->keysym_tab[(vk * hkls_len + group) * GDK_WIN32_LEVEL_COUNT];
-
-          /* MapVirtualKeyEx() fails to produce a scancode for VK_DIVIDE and VK_PAUSE.
-           * Ignore that, handle_special() will figure out a Gdk keyval for these
-           * without needing a scancode.
-           */
-          if (scancode == 0 &&
-              vk != VK_DIVIDE &&
-              vk != VK_PAUSE)
-            {
-              for (level = GDK_WIN32_LEVEL_NONE; level < GDK_WIN32_LEVEL_COUNT; level++)
-                keygroup[level] = GDK_KEY_VoidSymbol;
-
-              continue;
-            }
-
-          if (vk == VK_RSHIFT)
-            options->scancode_rshift = scancode;
-
-          key_state[vk] = 0x80;
-
-          for (level = GDK_WIN32_LEVEL_NONE; level < GDK_WIN32_LEVEL_COUNT; level++)
-            {
-              guint *ksymp = &keygroup[level];
-
-              set_level_vks (key_state, level);
-
-              *ksymp = 0;
-
-              /* First, handle those virtual keys that we always want
-               * as special GDK_* keysyms, even if ToAsciiEx might
-               * turn some them into a ASCII character (like TAB and
-               * ESC).
-               */
-              handle_special (vk, ksymp, level);
-
-              if ((*ksymp == 0) ||
-                  ((vk == VK_DECIMAL) && (level == GDK_WIN32_LEVEL_NONE)))
-                {
-                  wchar_t         wcs[10];
-                  gint            k;
-                  guint           keysym;
-                  GdkWin32KeyNode dead_key;
-
-                  wcs[0] = wcs[1] = 0;
-                  k = ToUnicodeEx (vk, scancode, key_state,
-                                   wcs, G_N_ELEMENTS (wcs),
-                                   0, hkls[group]);
-#if 0
-                  g_print ("ToUnicodeEx(%#02x, %d: %d): %d, %04x %04x\n",
-                           vk, scancode, level, k,
-                           wcs[0], wcs[1]);
-#endif
-                  switch (k)
-                    {
-                    case 1:
-                      if ((vk == VK_DECIMAL) && (level == GDK_WIN32_LEVEL_NONE))
-                        options->decimal_mark = wcs[0];
-                      else
-                        *ksymp = gdk_unicode_to_keyval (wcs[0]);
-                      break;
-                    case -1:
-                      keysym = gdk_unicode_to_keyval (wcs[0]);
-
-                      /* It is a dead key, and it has been stored in
-                       * the keyboard layout's state by
-                       * ToAsciiEx()/ToUnicodeEx(). Yes, this is an
-                       * incredibly silly API! Make the keyboard
-                       * layout forget it by calling
-                       * ToAsciiEx()/ToUnicodeEx() once more, with the
-                       * virtual key code and scancode for the
-                       * spacebar, without shift or AltGr. Otherwise
-                       * the next call to ToAsciiEx() with a different
-                       * key would try to combine with the dead key.
-                       */
-                      reset_after_dead (key_state, hkls[group]);
-
-                      /* Use dead keysyms instead of "undead" ones */
-                      handle_dead (keysym, ksymp);
-
-                      dead_key.undead_gdk_keycode = keysym;
-                      dead_key.vk = vk;
-                      dead_key.level = level;
-                      dead_key.gdk_keycode = *ksymp;
-                      dead_key.combinations = NULL;
-                      g_array_append_val (options->dead_keys, dead_key);
-                      break;
-                    case 0:
-                      /* Seems to be necessary to "reset" the keyboard layout
-                       * in this case, too. Otherwise problems on NT4.
-                       */
-                      reset_after_dead (key_state, hkls[group]);
-                      break;
-                    default:
-#if 0
-                      GDK_NOTE (EVENTS,
-                                g_print ("ToUnicodeEx returns %d "
-                                         "for vk:%02x, sc:%02x%s%s\n",
-                                         k, vk, scancode,
-                                         (shift&0x1 ? " shift" : ""),
-                                         (shift&0x2 ? " altgr" : "")));
-#endif
-                      break;
-                    }
-                }
-
-              if (*ksymp == 0)
-                *ksymp = GDK_KEY_VoidSymbol;
-            }
-
-          key_state[vk] = 0;
-
-          /* Check if keyboard has an AltGr key by checking if
-           * the mapping with Control+Alt is different.
-           * Don't test CapsLock here, as it does not seem to affect
-           * dead keys themselves, only the results of dead key combinations.
-           */
-          if (!options->has_altgr)
-            if ((keygroup[GDK_WIN32_LEVEL_ALTGR] != GDK_KEY_VoidSymbol &&
-                 keygroup[GDK_WIN32_LEVEL_NONE] != keygroup[GDK_WIN32_LEVEL_ALTGR]) ||
-                (keygroup[GDK_WIN32_LEVEL_SHIFT_ALTGR] != GDK_KEY_VoidSymbol &&
-                 keygroup[GDK_WIN32_LEVEL_SHIFT] != keygroup[GDK_WIN32_LEVEL_SHIFT_ALTGR]))
-              options->has_altgr = TRUE;
-        }
-    }
-
-  scancode = 0x0;
-
-  for (group = 0; group < hkls_len; group++)
-    {
-      options = &g_array_index (keymap->options, GdkWin32KeyGroupOptions, group);
-
-      for (i = 0; i < options->dead_keys->len; i++)
-        {
-          wchar_t          wcs[10];
-          gint             k;
-          GdkWin32KeyNode *dead_key;
-          GdkWin32KeyNode  combo;
-
-          dead_key = &g_array_index (options->dead_keys, GdkWin32KeyNode, i);
-
-          for (vk = 0; vk < KEY_STATE_SIZE; vk++)
-            {
-              for (level = GDK_WIN32_LEVEL_NONE; level < GDK_WIN32_LEVEL_COUNT; level++)
-                {
-                  /* Prime the ToUnicodeEx() internal state */
-                  wcs[0] = wcs[1] = 0;
-                  set_level_vks (key_state, dead_key->level);
-                  k = ToUnicodeEx (dead_key->vk, scancode, key_state,
-                                   wcs, G_N_ELEMENTS (wcs),
-                                   0, hkls[group]);
-                  switch (k)
-                    {
-                    case -1:
-                      /* Okay */
-                      break;
-                    default:
-                      /* Expected a dead key, got something else */
-                      reset_after_dead (key_state, hkls[group]);
-                      continue;
-                    }
-
-                  /* Check how it combines with vk */
-                  wcs[0] = wcs[1] = 0;
-                  set_level_vks (key_state, level);
-                  k = ToUnicodeEx (vk, scancode, key_state,
-                                   wcs, G_N_ELEMENTS (wcs),
-                                   0, hkls[group]);
-
-                  if (k == 0)
-                    {
-                      reset_after_dead (key_state, hkls[group]);
-                    }
-                  else if (k == -1)
-                    {
-                      /* Dead key chaining? TODO: support this (deeper tree?) */
-                      reset_after_dead (key_state, hkls[group]);
-                    }
-                  else if (k == 1)
-                    {
-                      combo.vk = vk;
-                      combo.level = level;
-                      combo.gdk_keycode = gdk_unicode_to_keyval (wcs[0]);
-                      combo.undead_gdk_keycode = combo.gdk_keycode;
-                      combo.combinations = NULL;
-
-                      if (dead_key->combinations == NULL)
-                        {
-                          dead_key->combinations = g_array_new (FALSE, FALSE, sizeof (GdkWin32KeyNode));
-                          g_array_set_clear_func (dead_key->combinations, (GDestroyNotify) gdk_win32_key_node_clear);
-                        }
-
-#if 0
-                      {
-                        char *dead_key_undead_u8, *wcs_u8;
-                        wchar_t t = gdk_keyval_to_unicode (dead_key->undead_gdk_keycode);
-                        dead_key_undead_u8 = g_utf16_to_utf8 (&t, 1, NULL, NULL, NULL);
-                        wcs_u8 = g_utf16_to_utf8 (wcs, 1, NULL, NULL, NULL);
-                        g_fprintf (stdout, "%d %s%s%s0x%02x (%s) + %s%s%s0x%02x = 0x%04x (%s)\n", group,
-                                 (dead_key->level == GDK_WIN32_LEVEL_SHIFT ||
-                                  dead_key->level == GDK_WIN32_LEVEL_SHIFT_ALTGR ||
-                                  dead_key->level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK ||
-                                  dead_key->level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR) ? "SHIFT-" : "      ",
-                                 (dead_key->level == GDK_WIN32_LEVEL_CAPSLOCK ||
-                                  dead_key->level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK ||
-                                  dead_key->level == GDK_WIN32_LEVEL_CAPSLOCK_ALTGR ||
-                                  dead_key->level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR) ? "CAPSLOCK-" : "         ",
-                                 (dead_key->level == GDK_WIN32_LEVEL_ALTGR ||
-                                  dead_key->level == GDK_WIN32_LEVEL_SHIFT_ALTGR ||
-                                  dead_key->level == GDK_WIN32_LEVEL_CAPSLOCK_ALTGR ||
-                                  dead_key->level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR) ? "ALTGR-" : "      ",
-                                 dead_key->vk,
-                                 dead_key_undead_u8,
-                                 (combo.level == GDK_WIN32_LEVEL_SHIFT ||
-                                  combo.level == GDK_WIN32_LEVEL_SHIFT_ALTGR ||
-                                  combo.level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK ||
-                                  combo.level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR) ? "SHIFT-" : "      ",
-                                 (combo.level == GDK_WIN32_LEVEL_CAPSLOCK ||
-                                  combo.level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK ||
-                                  combo.level == GDK_WIN32_LEVEL_CAPSLOCK_ALTGR ||
-                                  combo.level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR) ? "CAPSLOCK-" : "         ",
-                                 (combo.level == GDK_WIN32_LEVEL_ALTGR ||
-                                  combo.level == GDK_WIN32_LEVEL_SHIFT_ALTGR ||
-                                  combo.level == GDK_WIN32_LEVEL_CAPSLOCK_ALTGR ||
-                                  combo.level == GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR) ? "ALTGR-" : "      ",
-                                 vk,
-                                 wcs[0],
-                                 wcs_u8);
-                        g_free (dead_key_undead_u8);
-                        g_free (wcs_u8);
-                      }
-#endif
-
-                      g_array_append_val (dead_key->combinations, combo);
-                    }
-                }
-            }
-        }
-
-       g_array_sort (options->dead_keys, (GCompareFunc) sort_key_nodes_by_gdk_keyval);
-    }
-
-  GDK_NOTE (EVENTS, print_keysym_tab (keymap));
-
-  check_that_active_layout_is_in_sync (keymap);
-  current_serial = _gdk_keymap_serial;
-}
-
-static gboolean
-find_deadkey_by_keyval (GArray  *dead_keys,
-                        guint16  keyval,
-                        gsize   *index)
-{
-  gsize deadkey_i;
-  gsize deadkey_i_max;
-
-  if (dead_keys->len == 0)
-    return FALSE;
-
-  deadkey_i = 0;
-  deadkey_i_max = dead_keys->len - 1;
-
-  while (deadkey_i != deadkey_i_max)
-    {
-      GdkWin32KeyNode *dead_key;
-      gsize middle;
-
-      if (g_array_index (dead_keys, GdkWin32KeyNode, deadkey_i).gdk_keycode == keyval)
-        {
-          break;
-        }
-      else if (g_array_index (dead_keys, GdkWin32KeyNode, deadkey_i_max).gdk_keycode == keyval)
-        {
-          deadkey_i = deadkey_i_max;
-          break;
-        }
-      else if (deadkey_i + 1 == deadkey_i_max)
-        {
-          break;
-        }
-
-      middle = deadkey_i + (deadkey_i_max - deadkey_i) / 2;
-      dead_key = &g_array_index (dead_keys, GdkWin32KeyNode, middle);
-
-      if (dead_key->gdk_keycode < keyval)
-        deadkey_i = middle;
-      else if (dead_key->gdk_keycode > keyval)
-        deadkey_i_max = middle;
-      else
-        deadkey_i = deadkey_i_max = middle;
-    }
-
-  if (g_array_index (dead_keys, GdkWin32KeyNode, deadkey_i).gdk_keycode == keyval)
-    {
-      *index = deadkey_i;
-
-      return TRUE;
-    }
-
-  return FALSE;
-}
-
-GdkWin32KeymapMatch
-gdk_win32_keymap_check_compose (GdkWin32Keymap *keymap,
-                                guint          *compose_buffer,
-                                gsize           compose_buffer_len,
-                                guint16        *output,
-                                gsize          *output_len)
-{
-  gint partial_match;
-  guint8 active_group;
-  gsize deadkey_i, node_i;
-  GdkWin32KeyNode *dead_key;
-  GdkWin32KeyGroupOptions *options;
-  GdkWin32KeymapMatch match;
-  gsize output_size;
-
-  g_return_val_if_fail (output != NULL && output_len != NULL, GDK_WIN32_KEYMAP_MATCH_NONE);
-
-  if (compose_buffer_len < 1)
-    return GDK_WIN32_KEYMAP_MATCH_NONE;
-
-  output_size = *output_len;
-
-  active_group = _gdk_win32_keymap_get_active_group (keymap);
-  options = &g_array_index (keymap->options, GdkWin32KeyGroupOptions, active_group);
-
-  partial_match = -1;
-  match = GDK_WIN32_KEYMAP_MATCH_NONE;
-
-  if (find_deadkey_by_keyval (options->dead_keys, compose_buffer[0], &deadkey_i))
-    {
-      while (deadkey_i > 0 &&
-             g_array_index (options->dead_keys, GdkWin32KeyNode, deadkey_i - 1).gdk_keycode == compose_buffer[0])
-        deadkey_i--;
-
-      /* Hardcoded 2-tier tree here (dead key + non dead key = character).
-       * TODO: support trees with arbitrary depth for dead key chaining.
-       */
-      dead_key = &g_array_index (options->dead_keys, GdkWin32KeyNode, deadkey_i);
-
-      /* "Partial match" means "matched the whole sequence except the last key"
-       * (right now the sequence only has 2 keys, so this turns into "matched
-       * at least the first key").
-       * "last key" should be identified by having NULL further combinations.
-       * As a heuristic, convert the buffer contents into keyvals and use
-       * them as-is (normally there should be a separate unichar buffer for
-       * each combination, but we do not store these).
-       */
-      partial_match = deadkey_i;
-
-      if (compose_buffer_len < 2)
-        match = GDK_WIN32_KEYMAP_MATCH_INCOMPLETE;
-
-      for (node_i = 0;
-           match != GDK_WIN32_KEYMAP_MATCH_INCOMPLETE &&
-           node_i < dead_key->combinations->len;
-           node_i++)
-        {
-          GdkWin32KeyNode *node;
-
-          node = &g_array_index (dead_key->combinations, GdkWin32KeyNode, node_i);
-
-          if (keymap->keysym_tab[(node->vk * keymap->layout_handles->len + active_group) * GDK_WIN32_LEVEL_COUNT + node->level] == compose_buffer[1])
-            {
-              match = GDK_WIN32_KEYMAP_MATCH_EXACT;
-              *output_len = 0;
-
-              if (*output_len < output_size && node->gdk_keycode != 0)
-                output[(*output_len)++] = node->gdk_keycode;
-
-              break;
-            }
-        }
-    }
-
-  if (match == GDK_WIN32_KEYMAP_MATCH_EXACT ||
-      match == GDK_WIN32_KEYMAP_MATCH_INCOMPLETE)
-    {
-      return match;
-    }
-
-  if (partial_match >= 0)
-    {
-      if (compose_buffer_len == 2)
-        {
-          dead_key = &g_array_index (options->dead_keys, GdkWin32KeyNode, partial_match);
-          *output_len = 0;
-
-          if (output_size >= 1)
-            output[(*output_len)++] = dead_key->undead_gdk_keycode;
-
-          if (output_size >= 2)
-            {
-              gsize second_deadkey_i;
-
-              /* Special case for "deadkey + deadkey = space-version-of-deadkey, space-version-of-deadkey" combinations.
-               * Normally the result is a sequence of 2 unichars, but we do not store this.
-               * For "deadkey + nondeadkey = space-version-of-deadkey, nondeadkey", we can use compose_buffer
-               * contents as-is, but space version of a dead key need to be looked up separately.
-               */
-              if (find_deadkey_by_keyval (options->dead_keys, compose_buffer[1], &second_deadkey_i))
-                output[(*output_len)++] = g_array_index (options->dead_keys, GdkWin32KeyNode, second_deadkey_i).undead_gdk_keycode;
-              else
-                output[(*output_len)++] = compose_buffer[1];
-            }
-        }
-
-      return GDK_WIN32_KEYMAP_MATCH_PARTIAL;
-    }
-
-  return GDK_WIN32_KEYMAP_MATCH_NONE;
-}
-
-guint8
-_gdk_win32_keymap_get_rshift_scancode (GdkWin32Keymap *keymap)
-{
-  if (keymap != NULL &&
-      keymap->layout_handles->len > 0)
-    return g_array_index (keymap->options, GdkWin32KeyGroupOptions, keymap->active_layout).scancode_rshift;
-
-  return 0;
-}
-
-void
-_gdk_win32_keymap_set_active_layout (GdkWin32Keymap *keymap,
-                                     HKL             hkl)
-{
-  if (keymap != NULL &&
-      keymap->layout_handles->len > 0)
-    {
-      gint group;
-
-      for (group = 0; group < keymap->layout_handles->len; group++)
-        if (g_array_index (keymap->layout_handles, HKL, group) == hkl)
-          keymap->active_layout = group;
-    }
-}
-
-gboolean
-_gdk_win32_keymap_has_altgr (GdkWin32Keymap *keymap)
-{
-  if (keymap != NULL &&
-      keymap->layout_handles->len > 0)
-    return g_array_index (keymap->options, GdkWin32KeyGroupOptions, keymap->active_layout).has_altgr;
-
-  return FALSE;
-}
-
-guint8
-_gdk_win32_keymap_get_active_group (GdkWin32Keymap *keymap)
-{
-  if (keymap != NULL &&
-      keymap->layout_handles->len > 0)
-    return keymap->active_layout;
-
-  return 0;
-}
-
-GdkKeymap*
-gdk_keymap_get_for_display (GdkDisplay *display)
-{
-  g_return_val_if_fail (display == gdk_display_get_default (), NULL);
-
-  if (default_keymap == NULL)
-    default_keymap = g_object_new (gdk_win32_keymap_get_type (), NULL);
-
-  return default_keymap;
-}
-
-static PangoDirection
-get_hkl_direction (HKL hkl)
-{
-  switch (PRIMARYLANGID (LOWORD ((DWORD) (gintptr) hkl)))
-    {
-    case LANG_HEBREW:
-    case LANG_ARABIC:
-#ifdef LANG_URDU
-    case LANG_URDU:
-#endif
-    case LANG_FARSI:
-      /* Others? */
-      return PANGO_DIRECTION_RTL;
-
-    default:
-      return PANGO_DIRECTION_LTR;
-    }
-}
-
-PangoDirection
-gdk_keymap_get_direction (GdkKeymap *gdk_keymap)
-{
-  HKL active_hkl;
-  GdkWin32Keymap *keymap;
-
-  if (gdk_keymap == NULL || gdk_keymap != gdk_keymap_get_default ())
-    keymap = GDK_WIN32_KEYMAP (gdk_keymap_get_default ());
-  else
-    keymap = GDK_WIN32_KEYMAP (gdk_keymap);
-
-  update_keymap (GDK_KEYMAP (keymap));
-
-  if (keymap->layout_handles->len <= 0)
-    active_hkl = GetKeyboardLayout (0);
-  else
-    active_hkl = g_array_index (keymap->layout_handles, HKL, keymap->active_layout);
-
-  return get_hkl_direction (active_hkl);
-}
-
-gboolean
-gdk_keymap_have_bidi_layouts (GdkKeymap *gdk_keymap)
-{
-  GdkWin32Keymap *keymap;
-  gboolean        have_rtl = FALSE;
-  gboolean        have_ltr = FALSE;
-  gint            group;
-
-  if (gdk_keymap == NULL || gdk_keymap != gdk_keymap_get_default ())
-    keymap = GDK_WIN32_KEYMAP (gdk_keymap_get_default ());
-  else
-    keymap = GDK_WIN32_KEYMAP (gdk_keymap);
-
-  update_keymap (GDK_KEYMAP (keymap));
-
-  for (group = 0; group < keymap->layout_handles->len; group++)
-    {
-      if (get_hkl_direction (g_array_index (keymap->layout_handles, HKL, group)) == PANGO_DIRECTION_RTL)
-        have_rtl = TRUE;
-      else
-        have_ltr = TRUE;
-    }
-
-  return have_ltr && have_rtl;
-}
-
-gboolean
-gdk_keymap_get_caps_lock_state (GdkKeymap *keymap)
-{
-  (void) keymap;
-
-  return ((GetKeyState (VK_CAPITAL) & 1) != 0);
-}
-
-gboolean
-gdk_keymap_get_entries_for_keyval (GdkKeymap     *gdk_keymap,
-                                   guint          keyval,
-                                   GdkKeymapKey **keys,
-                                   gint          *n_keys)
-{
-  GArray *retval;
-
-  g_return_val_if_fail (gdk_keymap == NULL || GDK_IS_KEYMAP (gdk_keymap), FALSE);
-  g_return_val_if_fail (keys != NULL, FALSE);
-  g_return_val_if_fail (n_keys != NULL, FALSE);
-  g_return_val_if_fail (keyval != 0, FALSE);
-
-  retval = g_array_new (FALSE, FALSE, sizeof (GdkKeymapKey));
-
-  /* Accept only the default keymap */
-  if (gdk_keymap == NULL || gdk_keymap == gdk_keymap_get_default ())
-    {
-      gint vk;
-      GdkWin32Keymap *keymap;
-
-      if (gdk_keymap == NULL)
-        keymap = GDK_WIN32_KEYMAP (gdk_keymap_get_default ());
-      else
-        keymap = GDK_WIN32_KEYMAP (gdk_keymap);
-
-      update_keymap (gdk_keymap);
-
-      for (vk = 0; vk < KEY_STATE_SIZE; vk++)
-        {
-          gint group;
-
-          for (group = 0; group < keymap->layout_handles->len; group++)
-            {
-              GdkWin32KeyLevelState    level;
-
-              for (level = GDK_WIN32_LEVEL_NONE; level < GDK_WIN32_LEVEL_COUNT; level++)
-                {
-                  guint *keygroup;
-
-                  keygroup = &keymap->keysym_tab[(vk * keymap->layout_handles->len + group) * GDK_WIN32_LEVEL_COUNT];
-
-                  if (keygroup[level] == keyval)
-                    {
-                      GdkKeymapKey key;
-
-                      key.keycode = vk;
-                      key.group = group;
-                      key.level = level;
-                      g_array_append_val (retval, key);
-                    }
-                }
-            }
-        }
-    }
-
-#ifdef G_ENABLE_DEBUG
-  if (_gdk_debug_flags & GDK_DEBUG_EVENTS)
-    {
-      guint i;
-
-      g_print ("gdk_keymap_get_entries_for_keyval: %#.04x (%s):",
-               keyval, gdk_keyval_name (keyval));
-      for (i = 0; i < retval->len; i++)
-        {
-          GdkKeymapKey *entry = (GdkKeymapKey *) retval->data + i;
-          g_print ("  %#.02x %d %d", entry->keycode, entry->group, entry->level);
-        }
-      g_print ("\n");
-    }
-#endif
-
-  if (retval->len > 0)
-    {
-      *keys = (GdkKeymapKey*) retval->data;
-      *n_keys = retval->len;
-    }
-  else
-    {
-      *keys = NULL;
-      *n_keys = 0;
-    }
-
-  g_array_free (retval, retval->len > 0 ? FALSE : TRUE);
-
-  return *n_keys > 0;
-}
-
-gboolean
-gdk_keymap_get_entries_for_keycode (GdkKeymap     *gdk_keymap,
-                                    guint          hardware_keycode,
-                                    GdkKeymapKey **keys,
-                                    guint        **keyvals,
-                                    gint          *n_entries)
-{
-  GArray         *key_array;
-  GArray         *keyval_array;
-  gint            group;
-  GdkWin32Keymap *keymap;
-
-  g_return_val_if_fail (gdk_keymap == NULL || GDK_IS_KEYMAP (gdk_keymap), FALSE);
-  g_return_val_if_fail (n_entries != NULL, FALSE);
-
-  if (hardware_keycode <= 0 ||
-      hardware_keycode >= KEY_STATE_SIZE ||
-      (keys == NULL && keyvals == NULL) ||
-      (gdk_keymap != NULL && gdk_keymap != gdk_keymap_get_default ()))
-    {
-      /* Wrong keycode or NULL output arrays or wrong keymap */
-      if (keys)
-        *keys = NULL;
-      if (keyvals)
-        *keyvals = NULL;
-
-      *n_entries = 0;
-      return FALSE;
-    }
-
-  if (keys)
-    key_array = g_array_new (FALSE, FALSE, sizeof (GdkKeymapKey));
-  else
-    key_array = NULL;
-
-  if (keyvals)
-    keyval_array = g_array_new (FALSE, FALSE, sizeof (guint));
-  else
-    keyval_array = NULL;
-
-  keymap = GDK_WIN32_KEYMAP (gdk_keymap_get_default ());
-  update_keymap (GDK_KEYMAP (keymap));
-
-  for (group = 0; group < keymap->layout_handles->len; group++)
-    {
-      GdkWin32KeyLevelState    level;
-
-      for (level = GDK_WIN32_LEVEL_NONE; level < GDK_WIN32_LEVEL_COUNT; level++)
-        {
-          if (key_array)
-            {
-              GdkKeymapKey key;
-
-              key.keycode = hardware_keycode;
-              key.group = group;
-              key.level = level;
-              g_array_append_val (key_array, key);
-            }
-
-          if (keyval_array)
-            {
-              guint keyval = keymap->keysym_tab[(hardware_keycode * keymap->layout_handles->len + group) * GDK_WIN32_LEVEL_COUNT + level];
-
-              g_array_append_val (keyval_array, keyval);
-            }
-        }
-    }
-
-  *n_entries = group * GDK_WIN32_LEVEL_COUNT;
-
-  if ((key_array && key_array->len > 0) ||
-      (keyval_array && keyval_array->len > 0))
-    {
-      if (keys)
-        *keys = (GdkKeymapKey*) key_array->data;
-
-      if (keyvals)
-        *keyvals = (guint*) keyval_array->data;
-    }
-  else
-    {
-      if (keys)
-        *keys = NULL;
-
-      if (keyvals)
-        *keyvals = NULL;
-    }
-
-  if (key_array)
-    g_array_free (key_array, key_array->len > 0 ? FALSE : TRUE);
-  if (keyval_array)
-    g_array_free (keyval_array, keyval_array->len > 0 ? FALSE : TRUE);
-
-  return *n_entries > 0;
-}
-
-guint
-gdk_keymap_lookup_key (GdkKeymap          *gdk_keymap,
-                       const GdkKeymapKey *key)
-{
-  guint sym;
-  GdkWin32Keymap *keymap;
-
-  g_return_val_if_fail (gdk_keymap == NULL || GDK_IS_KEYMAP (gdk_keymap), 0);
-  g_return_val_if_fail (key != NULL, 0);
-
-  /* Accept only the default keymap */
-  if (gdk_keymap != NULL && gdk_keymap != gdk_keymap_get_default ())
-    return 0;
-
-  keymap = GDK_WIN32_KEYMAP (gdk_keymap_get_default ());
-  update_keymap (GDK_KEYMAP (keymap));
-
-  if (key->keycode >= KEY_STATE_SIZE ||
-      key->group < 0 || key->group >= keymap->layout_handles->len ||
-      key->level < 0 || key->level >= GDK_WIN32_LEVEL_COUNT)
-    return 0;
-
-  sym = keymap->keysym_tab[(key->keycode * keymap->layout_handles->len + key->group) * GDK_WIN32_LEVEL_COUNT + key->level];
-
-  if (sym == GDK_KEY_VoidSymbol)
-    return 0;
-  else
-    return sym;
-}
-
-gboolean
-gdk_keymap_translate_keyboard_state (GdkKeymap       *gdk_keymap,
-                                     guint            hardware_keycode,
-                                     GdkModifierType  state,
-                                     gint             group,
-                                     guint           *keyval,
-                                     gint            *effective_group,
-                                     gint            *level,
-                                     GdkModifierType *consumed_modifiers)
-{
-  GdkWin32Keymap *keymap;
-  guint tmp_keyval;
-  guint *keygroup;
-  GdkWin32KeyLevelState shift_level;
-  GdkModifierType modifiers = GDK_SHIFT_MASK | GDK_LOCK_MASK | GDK_MOD2_MASK;
-
-  g_return_val_if_fail (gdk_keymap == NULL || GDK_IS_KEYMAP (gdk_keymap), FALSE);
-
-#if 0
-  GDK_NOTE (EVENTS, g_print ("gdk_keymap_translate_keyboard_state: keycode=%#x state=%#x group=%d\n",
-			     hardware_keycode, state, group));
-#endif
-  if (keyval)
-    *keyval = 0;
-  if (effective_group)
-    *effective_group = 0;
-  if (level)
-    *level = 0;
-  if (consumed_modifiers)
-    *consumed_modifiers = 0;
-
-  /* Accept only the default keymap */
-  if (gdk_keymap != NULL && gdk_keymap != gdk_keymap_get_default ())
-    return FALSE;
-
-  if (hardware_keycode >= KEY_STATE_SIZE)
-    return FALSE;
-
-  keymap = GDK_WIN32_KEYMAP (gdk_keymap_get_default ());
-  update_keymap (GDK_KEYMAP (keymap));
-
-  if (group < 0 || group >= keymap->layout_handles->len)
-    return FALSE;
-
-  keygroup = &keymap->keysym_tab[(hardware_keycode * keymap->layout_handles->len + group) * GDK_WIN32_LEVEL_COUNT];
-
-  if ((state & (GDK_SHIFT_MASK | GDK_LOCK_MASK)) == (GDK_SHIFT_MASK | GDK_LOCK_MASK))
-    shift_level = GDK_WIN32_LEVEL_SHIFT_CAPSLOCK;
-  else if (state & GDK_SHIFT_MASK)
-    shift_level = GDK_WIN32_LEVEL_SHIFT;
-  else if (state & GDK_LOCK_MASK)
-    shift_level = GDK_WIN32_LEVEL_CAPSLOCK;
-  else
-    shift_level = GDK_WIN32_LEVEL_NONE;
-
-  if (state & GDK_MOD2_MASK)
-    {
-      if (shift_level == GDK_WIN32_LEVEL_NONE)
-        shift_level = GDK_WIN32_LEVEL_ALTGR;
-      else if (shift_level == GDK_WIN32_LEVEL_SHIFT)
-        shift_level = GDK_WIN32_LEVEL_SHIFT_ALTGR;
-      else if (shift_level == GDK_WIN32_LEVEL_CAPSLOCK)
-        shift_level = GDK_WIN32_LEVEL_CAPSLOCK_ALTGR;
-      else
-        shift_level = GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR;
-     }
-
-  /* Drop altgr, capslock and shift if there are no keysymbols on
-   * the key for those.
-   */
-  if (keygroup[shift_level] == GDK_KEY_VoidSymbol)
-    {
-      switch (shift_level)
-        {
-         case GDK_WIN32_LEVEL_NONE:
-         case GDK_WIN32_LEVEL_ALTGR:
-         case GDK_WIN32_LEVEL_SHIFT:
-         case GDK_WIN32_LEVEL_CAPSLOCK:
-           if (keygroup[GDK_WIN32_LEVEL_NONE] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_NONE;
-           break;
-         case GDK_WIN32_LEVEL_SHIFT_CAPSLOCK:
-           if (keygroup[GDK_WIN32_LEVEL_CAPSLOCK] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_CAPSLOCK;
-           else if (keygroup[GDK_WIN32_LEVEL_SHIFT] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_SHIFT;
-           else if (keygroup[GDK_WIN32_LEVEL_NONE] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_NONE;
-           break;
-         case GDK_WIN32_LEVEL_CAPSLOCK_ALTGR:
-           if (keygroup[GDK_WIN32_LEVEL_ALTGR] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_ALTGR;
-           else if (keygroup[GDK_WIN32_LEVEL_CAPSLOCK] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_CAPSLOCK;
-           else if (keygroup[GDK_WIN32_LEVEL_NONE] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_NONE;
-           break;
-         case GDK_WIN32_LEVEL_SHIFT_ALTGR:
-           if (keygroup[GDK_WIN32_LEVEL_ALTGR] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_ALTGR;
-           else if (keygroup[GDK_WIN32_LEVEL_SHIFT] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_SHIFT;
-           else if (keygroup[GDK_WIN32_LEVEL_NONE] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_NONE;
-           break;
-         case GDK_WIN32_LEVEL_SHIFT_CAPSLOCK_ALTGR:
-           if (keygroup[GDK_WIN32_LEVEL_CAPSLOCK_ALTGR] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_CAPSLOCK_ALTGR;
-           else if (keygroup[GDK_WIN32_LEVEL_SHIFT_ALTGR] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_SHIFT_ALTGR;
-           else if (keygroup[GDK_WIN32_LEVEL_ALTGR] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_ALTGR;
-           else if (keygroup[GDK_WIN32_LEVEL_SHIFT_CAPSLOCK] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_SHIFT_CAPSLOCK;
-           else if (keygroup[GDK_WIN32_LEVEL_CAPSLOCK] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_CAPSLOCK;
-           else if (keygroup[GDK_WIN32_LEVEL_SHIFT] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_SHIFT;
-           else if (keygroup[GDK_WIN32_LEVEL_NONE] != GDK_KEY_VoidSymbol)
-             shift_level = GDK_WIN32_LEVEL_NONE;
-           break;
-         case GDK_WIN32_LEVEL_COUNT:
-           g_assert_not_reached ();
-        }
-    }
-
-  /* See whether the shift level actually mattered
-   * to know what to put in consumed_modifiers
-   */
-  if ((keygroup[GDK_WIN32_LEVEL_SHIFT] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_NONE] == keygroup[GDK_WIN32_LEVEL_SHIFT]) &&
-      (keygroup[GDK_WIN32_LEVEL_SHIFT_ALTGR] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_ALTGR] == keygroup[GDK_WIN32_LEVEL_SHIFT_ALTGR]) &&
-      (keygroup[GDK_WIN32_LEVEL_SHIFT_CAPSLOCK] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_CAPSLOCK] == keygroup[GDK_WIN32_LEVEL_SHIFT_CAPSLOCK]))
-      modifiers &= ~GDK_SHIFT_MASK;
-
-  if ((keygroup[GDK_WIN32_LEVEL_CAPSLOCK] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_NONE] == keygroup[GDK_WIN32_LEVEL_CAPSLOCK]) &&
-      (keygroup[GDK_WIN32_LEVEL_CAPSLOCK_ALTGR] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_ALTGR] == keygroup[GDK_WIN32_LEVEL_CAPSLOCK_ALTGR]) &&
-      (keygroup[GDK_WIN32_LEVEL_SHIFT_CAPSLOCK] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_SHIFT] == keygroup[GDK_WIN32_LEVEL_SHIFT_CAPSLOCK]))
-      modifiers &= ~GDK_LOCK_MASK;
-
-  if ((keygroup[GDK_WIN32_LEVEL_ALTGR] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_NONE] == keygroup[GDK_WIN32_LEVEL_ALTGR]) &&
-      (keygroup[GDK_WIN32_LEVEL_SHIFT_ALTGR] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_SHIFT] == keygroup[GDK_WIN32_LEVEL_SHIFT_ALTGR]) &&
-      (keygroup[GDK_WIN32_LEVEL_CAPSLOCK_ALTGR] == GDK_KEY_VoidSymbol ||
-       keygroup[GDK_WIN32_LEVEL_CAPSLOCK] == keygroup[GDK_WIN32_LEVEL_CAPSLOCK_ALTGR]))
-      modifiers &= ~GDK_MOD2_MASK;
-
-  tmp_keyval = keygroup[shift_level];
-
-  if (keyval)
-    *keyval = tmp_keyval;
-
-  if (effective_group)
-    *effective_group = group;
-
-  if (level)
-    *level = shift_level;
-
-  if (consumed_modifiers)
-    *consumed_modifiers = modifiers;
-
-#if 0
-  GDK_NOTE (EVENTS, g_print ("... group=%d level=%d cmods=%#x keyval=%s\n",
-			     group, shift_level, modifiers, gdk_keyval_name (tmp_keyval)));
-#endif
-
-  return tmp_keyval != GDK_KEY_VoidSymbol;
-}
-
-void
-gdk_keymap_add_virtual_modifiers (GdkKeymap       *keymap,
-                                  GdkModifierType *state)
-{
-}
-
-gboolean
-gdk_keymap_map_virtual_modifiers (GdkKeymap       *keymap,
-                                  GdkModifierType *state)
-{
-  /* FIXME: Is this the right thing to do? */
-  return TRUE;
-}
-
-static void
-gdk_win32_keymap_class_init (GdkWin32KeymapClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = gdk_win32_keymap_finalize;
-
-}
diff --git a/gdk/win32/gdkmain-win32.c b/gdk/win32/gdkmain-win32.c
deleted file mode 100644
index 820b0fc..0000000
--- a/gdk/win32/gdkmain-win32.c
+++ /dev/null
@@ -1,1200 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-
-#include <glib/gprintf.h>
-#include <stdlib.h>
-#include <string.h>
-#include <limits.h>
-#include <io.h>
-
-#include "gdk.h"
-#include "gdkregion-generic.h"
-#include "gdkkeysyms.h"
-#include "gdkinternals.h"
-#include "gdkintl.h"
-#include "gdkprivate-win32.h"
-#include "gdkinput-win32.h"
-
-#include <objbase.h>
-
-#include <imm.h>
-
-static gboolean gdk_synchronize = FALSE;
-
-static gboolean dummy;
-
-const GOptionEntry _gdk_windowing_args[] = {
-  { "sync", 0, 0, G_OPTION_ARG_NONE, &gdk_synchronize, 
-    /* Description of --sync in --help output */              N_("Don't batch GDI requests"), NULL },
-  { "no-wintab", 0, 0, G_OPTION_ARG_NONE, &_gdk_input_ignore_wintab, 
-    /* Description of --no-wintab in --help output */         N_("Don't use the Wintab API for tablet support"), NULL },
-  { "ignore-wintab", 0, 0, G_OPTION_ARG_NONE, &_gdk_input_ignore_wintab, 
-    /* Description of --ignore-wintab in --help output */     N_("Same as --no-wintab"), NULL },
-  { "use-wintab", 0, 0, G_OPTION_ARG_NONE, &dummy,
-    /* Description of --use-wintab in --help output */     N_("Do use the Wintab API [default]"), NULL },
-  { "max-colors", 0, 0, G_OPTION_ARG_INT, &_gdk_max_colors, 
-    /* Description of --max-colors=COLORS in --help output */ N_("Size of the palette in 8 bit mode"), 
-    /* Placeholder in --max-colors=COLORS in --help output */ N_("COLORS") },
-  { NULL }
-};
-
-int __stdcall
-DllMain (HINSTANCE hinstDLL,
-	 DWORD     dwReason,
-	 LPVOID    reserved)
-{
-  _gdk_dll_hinstance = hinstDLL;
-
-  return TRUE;
-}
-
-void
-_gdk_windowing_init (void)
-{
-  gchar buf[10];
-
-  if (getenv ("GDK_IGNORE_WINTAB") != NULL)
-    _gdk_input_ignore_wintab = TRUE;
-  else if (getenv ("GDK_USE_WINTAB") != NULL)
-    _gdk_input_ignore_wintab = FALSE;
-
-  if (gdk_synchronize)
-    GdiSetBatchLimit (1);
-
-  _gdk_app_hmodule = GetModuleHandle (NULL);
-  _gdk_display_hdc = CreateDC ("DISPLAY", NULL, NULL, NULL);
-  _gdk_input_locale = GetKeyboardLayout (0);
-  _gdk_win32_keymap_set_active_layout (GDK_WIN32_KEYMAP (gdk_keymap_get_default ()), _gdk_input_locale);
-  _gdk_input_locale_is_ime = ImmIsIME (_gdk_input_locale);
-  GetLocaleInfo (MAKELCID (LOWORD (_gdk_input_locale), SORT_DEFAULT),
-		 LOCALE_IDEFAULTANSICODEPAGE,
-		 buf, sizeof (buf));
-  _gdk_input_codepage = atoi (buf);
-  GDK_NOTE (EVENTS, g_print ("input_locale:%p, codepage:%d\n",
-			     _gdk_input_locale, _gdk_input_codepage));
-
-  CoInitialize (NULL);
-
-  _gdk_selection = gdk_atom_intern_static_string ("GDK_SELECTION");
-  _wm_transient_for = gdk_atom_intern_static_string ("WM_TRANSIENT_FOR");
-  _targets = gdk_atom_intern_static_string ("TARGETS");
-  _delete = gdk_atom_intern_static_string ("DELETE");
-  _save_targets = gdk_atom_intern_static_string ("SAVE_TARGETS");
-  _utf8_string = gdk_atom_intern_static_string ("UTF8_STRING");
-  _text = gdk_atom_intern_static_string ("TEXT");
-  _compound_text = gdk_atom_intern_static_string ("COMPOUND_TEXT");
-  _text_uri_list = gdk_atom_intern_static_string ("text/uri-list");
-  _text_html = gdk_atom_intern_static_string ("text/html");
-  _image_png = gdk_atom_intern_static_string ("image/png");
-  _image_jpeg = gdk_atom_intern_static_string ("image/jpeg");
-  _image_bmp = gdk_atom_intern_static_string ("image/bmp");
-  _image_gif = gdk_atom_intern_static_string ("image/gif");
-
-  _local_dnd = gdk_atom_intern_static_string ("LocalDndSelection");
-  _gdk_win32_dropfiles = gdk_atom_intern_static_string ("DROPFILES_DND");
-  _gdk_ole2_dnd = gdk_atom_intern_static_string ("OLE2_DND");
-
-  /* MS Office 2007, at least, offers images in common file formats
-   * using clipboard format names like "PNG" and "JFIF". So we follow
-   * the lead and map the GDK target name "image/png" to the clipboard
-   * format name "PNG" etc.
-   */
-  _cf_png = RegisterClipboardFormat ("PNG");
-  _cf_jfif = RegisterClipboardFormat ("JFIF");
-  _cf_gif = RegisterClipboardFormat ("GIF");
-
-  _cf_url = RegisterClipboardFormat ("UniformResourceLocatorW");
-  _cf_html_format = RegisterClipboardFormat ("HTML Format");
-  _cf_text_html = RegisterClipboardFormat ("text/html");
-
-  _gdk_win32_selection_init ();
-}
-
-void
-_gdk_win32_api_failed (const gchar *where,
-		      const gchar *api)
-{
-  gchar *msg = g_win32_error_message (GetLastError ());
-  g_warning ("%s: %s failed: %s", where, api, msg);
-  g_free (msg);
-}
-
-void
-_gdk_other_api_failed (const gchar *where,
-		      const gchar *api)
-{
-  g_warning ("%s: %s failed", where, api);
-}
-
-void
-gdk_set_use_xshm (gboolean use_xshm)
-{
-  /* Always on */
-}
-
-gboolean
-gdk_get_use_xshm (void)
-{
-  return TRUE;
-}
-
-gint
-gdk_screen_get_width (GdkScreen *screen)
-{
-  return GDK_WINDOW_OBJECT (_gdk_root)->width;
-}
-
-gint
-gdk_screen_get_height (GdkScreen *screen)
-{
-  return GDK_WINDOW_OBJECT (_gdk_root)->height;
-}
-gint
-gdk_screen_get_width_mm (GdkScreen *screen)
-{
-  return (double) gdk_screen_get_width (screen) / GetDeviceCaps (_gdk_display_hdc, LOGPIXELSX) * 25.4;
-}
-
-gint
-gdk_screen_get_height_mm (GdkScreen *screen)
-{
-  return (double) gdk_screen_get_height (screen) / GetDeviceCaps (_gdk_display_hdc, LOGPIXELSY) * 25.4;
-}
-
-void
-_gdk_windowing_display_set_sm_client_id (GdkDisplay  *display,
-					 const gchar *sm_client_id)
-{
-  g_warning("gdk_set_sm_client_id %s", sm_client_id ? sm_client_id : "NULL");
-}
-
-void
-gdk_display_beep (GdkDisplay *display)
-{
-  g_return_if_fail (display == gdk_display_get_default());
-  if (!MessageBeep (-1))
-    Beep (1000, 50);
-}
-
-void
-_gdk_windowing_exit (void)
-{
-  _gdk_win32_dnd_exit ();
-  CoUninitialize ();
-  DeleteDC (_gdk_display_hdc);
-  _gdk_display_hdc = NULL;
-}
-
-gchar *
-gdk_get_display (void)
-{
-  return g_strdup (gdk_display_get_name (gdk_display_get_default ()));
-}
-
-void
-gdk_error_trap_push (void)
-{
-}
-
-gint
-gdk_error_trap_pop (void)
-{
-  return 0;
-}
-
-void
-gdk_notify_startup_complete (void)
-{
-}
-
-void
-gdk_notify_startup_complete_with_id (const gchar* startup_id)
-{
-}
-
-void          
-gdk_window_set_startup_id (GdkWindow   *window,
-			   const gchar *startup_id)
-{
-}
-
-#ifdef G_ENABLE_DEBUG
-
-/*
- * Like g_strdup_printf, but to a static buffer. Return value does not
- * have to be g_free()d. The buffer is of bounded size and reused
- * cyclically. Thus the return value is valid only until that part of
- * the buffer happens to get reused. This doesn't matter as this
- * function's return value is used in debugging output right after the call,
- * and the return value isn't used after that.
- */
-static gchar *
-static_printf (const gchar *format,
-	       ...)
-{
-  static gchar buf[10000];
-  gchar *msg;
-  static gchar *bufp = buf;
-  gchar *retval;
-  va_list args;
-
-  va_start (args, format);
-  msg = g_strdup_vprintf (format, args);
-  va_end (args);
-
-  g_assert (strlen (msg) < sizeof (buf));
-
-  if (bufp + strlen (msg) + 1 > buf + sizeof (buf))
-    bufp = buf;
-  retval = bufp;
-
-  strcpy (bufp, msg);
-  bufp += strlen (msg) + 1;
-  g_free (msg);
-
-  return retval;
-}
-
-gchar *
-_gdk_win32_color_to_string (const GdkColor *color)
-{
-  return static_printf ("(%.04x,%.04x,%.04x):%.06x",
-			color->red, color->green,
-			color->blue, color->pixel);
-}
-
-void
-_gdk_win32_print_paletteentries (const PALETTEENTRY *pep,
-				const int           nentries)
-{
-  char buf[20];
-  int i;
-
-  for (i = 0; i < nentries; i++)
-    g_print ("  %3d %02x:  %02x %02x %02x%s\n",
-	     i, i,
-	     pep[i].peRed, pep[i].peGreen, pep[i].peBlue,
-	     (pep[i].peFlags == 0 ? "" :
-	      (pep[i].peFlags == PC_EXPLICIT ? " PC_EXPLICIT" :
-	       (pep[i].peFlags == PC_NOCOLLAPSE ? " PC_NOCOLLAPSE" :
-		(pep[i].peFlags == PC_RESERVED ? " PC_RESERVED" :
-		 (g_sprintf (buf, " %d", pep[i].peFlags), buf))))));
-}
-
-void
-_gdk_win32_print_system_palette (void)
-{
-  PALETTEENTRY *pe;
-  int k;
-
-  k = GetSystemPaletteEntries (_gdk_display_hdc, 0, 0, NULL);
-  pe = g_new (PALETTEENTRY, k);
-  k = GetSystemPaletteEntries (_gdk_display_hdc, 0, k, pe);
-
-  if (!k)
-    g_print ("GetSystemPaletteEntries failed: %s\n",
-	     g_win32_error_message (GetLastError ()));
-  else
-    {
-      g_print ("System palette: %d entries\n", k);
-      _gdk_win32_print_paletteentries (pe, k);
-    }
-  g_free (pe);
-}
-
-static gint
-palette_size (HPALETTE hpal)
-{
-  WORD npal = 0;
-
-  if (!GetObject (hpal, sizeof (npal), &npal))
-    WIN32_GDI_FAILED ("GetObject (HPALETTE)");
-
-  return npal;
-}
-
-void
-_gdk_win32_print_hpalette (HPALETTE hpal)
-{
-  PALETTEENTRY *pe;
-  gint n, npal;
-
-  npal = palette_size (hpal);
-  pe = g_new (PALETTEENTRY, npal);
-  n = GetPaletteEntries (hpal, 0, npal, pe);
-
-  if (!n)
-    g_print ("HPALETTE %p: GetPaletteEntries failed: %s\n",
-	     hpal, g_win32_error_message (GetLastError ()));
-  else
-    {
-      g_print ("HPALETTE %p: %d (%d) entries\n", hpal, n, npal);
-      _gdk_win32_print_paletteentries (pe, n);
-    }
-  g_free (pe);
-}
-
-void
-_gdk_win32_print_dc (HDC hdc)
-{
-  HGDIOBJ obj;
-  LOGBRUSH logbrush;
-  EXTLOGPEN extlogpen;
-  HRGN hrgn;
-  RECT rect;
-  int flag;
-
-  g_print ("%p:\n", hdc);
-  obj = GetCurrentObject (hdc, OBJ_BRUSH);
-  GetObject (obj, sizeof (LOGBRUSH), &logbrush);
-  g_print ("brush: %s color=%06lx hatch=%p\n",
-	   _gdk_win32_lbstyle_to_string (logbrush.lbStyle),
-	   logbrush.lbColor, (gpointer) logbrush.lbHatch);
-  obj = GetCurrentObject (hdc, OBJ_PEN);
-  GetObject (obj, sizeof (EXTLOGPEN), &extlogpen);
-  g_print ("pen: %s %s %s %s w=%d %s\n",
-	   _gdk_win32_pstype_to_string (extlogpen.elpPenStyle),
-	   _gdk_win32_psstyle_to_string (extlogpen.elpPenStyle),
-	   _gdk_win32_psendcap_to_string (extlogpen.elpPenStyle),
-	   _gdk_win32_psjoin_to_string (extlogpen.elpPenStyle),
-	   (int) extlogpen.elpWidth,
-	   _gdk_win32_lbstyle_to_string (extlogpen.elpBrushStyle));
-  g_print ("rop2: %s textcolor=%06lx\n",
-	   _gdk_win32_rop2_to_string (GetROP2 (hdc)),
-	   GetTextColor (hdc));
-  hrgn = CreateRectRgn (0, 0, 0, 0);
-  if ((flag = GetClipRgn (hdc, hrgn)) == -1)
-    WIN32_API_FAILED ("GetClipRgn");
-  else if (flag == 0)
-    g_print ("no clip region\n");
-  else if (flag == 1)
-    {
-      GetRgnBox (hrgn, &rect);
-      g_print ("clip region: %p bbox: %s\n",
-	       hrgn, _gdk_win32_rect_to_string (&rect));
-    }
-  DeleteObject (hrgn);
-}
-
-gchar *
-_gdk_win32_cap_style_to_string (GdkCapStyle cap_style)
-{
-  switch (cap_style)
-    {
-#define CASE(x) case GDK_CAP_##x: return #x
-    CASE (NOT_LAST);
-    CASE (BUTT);
-    CASE (ROUND);
-    CASE (PROJECTING);
-#undef CASE
-    default: return static_printf ("illegal_%d", cap_style);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_fill_style_to_string (GdkFill fill)
-{
-  switch (fill)
-    {
-#define CASE(x) case GDK_##x: return #x
-    CASE (SOLID);
-    CASE (TILED);
-    CASE (STIPPLED);
-    CASE (OPAQUE_STIPPLED);
-#undef CASE
-    default: return static_printf ("illegal_%d", fill);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_function_to_string (GdkFunction function)
-{
-  switch (function)
-    {
-#define CASE(x) case GDK_##x: return #x
-    CASE (COPY);
-    CASE (INVERT);
-    CASE (XOR);
-    CASE (CLEAR);
-    CASE (AND);
-    CASE (AND_REVERSE);
-    CASE (AND_INVERT);
-    CASE (NOOP);
-    CASE (OR);
-    CASE (EQUIV);
-    CASE (OR_REVERSE);
-    CASE (COPY_INVERT);
-    CASE (OR_INVERT);
-    CASE (NAND);
-    CASE (SET);
-#undef CASE
-    default: return static_printf ("illegal_%d", function);
-    }
-  /* NOTREACHED */
-  return NULL; 
-}
-
-gchar *
-_gdk_win32_join_style_to_string (GdkJoinStyle join_style)
-{
-  switch (join_style)
-    {
-#define CASE(x) case GDK_JOIN_##x: return #x
-    CASE (MITER);
-    CASE (ROUND);
-    CASE (BEVEL);
-#undef CASE
-    default: return static_printf ("illegal_%d", join_style);
-    }
-  /* NOTREACHED */
-  return NULL; 
-}
-
-gchar *
-_gdk_win32_line_style_to_string (GdkLineStyle line_style)
-{
-  switch (line_style)
-    {
-#define CASE(x) case GDK_LINE_##x: return #x
-    CASE(SOLID);
-    CASE(ON_OFF_DASH);  
-    CASE(DOUBLE_DASH);  
-#undef CASE
-    default: return static_printf ("illegal_%d", line_style);
-    }
-  /* NOTREACHED */
-  return NULL; 
-}
-
-gchar *
-_gdk_win32_drag_protocol_to_string (GdkDragProtocol protocol)
-{
-  switch (protocol)
-    {
-#define CASE(x) case GDK_DRAG_PROTO_##x: return #x
-      CASE (MOTIF);
-      CASE (XDND);
-      CASE (ROOTWIN);
-      CASE (NONE);
-      CASE (WIN32_DROPFILES);
-      CASE (OLE2);
-      CASE (LOCAL);
-#undef CASE
-    default: return static_printf ("illegal_%d", protocol);
-    }
-  /* NOTREACHED */
-  return NULL; 
-}
-
-gchar *
-_gdk_win32_gcvalues_mask_to_string (GdkGCValuesMask mask)
-{
-  gchar buf[400];
-  gchar *bufp = buf;
-  gchar *s = "";
-
-  buf[0] = '\0';
-
-#define BIT(x) 						\
-  if (mask & GDK_GC_##x) 				\
-    (bufp += g_sprintf (bufp, "%s" #x, s), s = "|")
-
-  BIT (FOREGROUND);
-  BIT (BACKGROUND);
-  BIT (FONT);
-  BIT (FUNCTION);
-  BIT (FILL);
-  BIT (TILE);
-  BIT (STIPPLE);
-  BIT (CLIP_MASK);
-  BIT (SUBWINDOW);
-  BIT (TS_X_ORIGIN);
-  BIT (TS_Y_ORIGIN);
-  BIT (CLIP_X_ORIGIN);
-  BIT (CLIP_Y_ORIGIN);
-  BIT (EXPOSURES);
-  BIT (LINE_WIDTH);
-  BIT (LINE_STYLE);
-  BIT (CAP_STYLE);
-  BIT (JOIN_STYLE);
-#undef BIT
-
-  return static_printf ("%s", buf);  
-}
-
-gchar *
-_gdk_win32_window_state_to_string (GdkWindowState state)
-{
-  gchar buf[100];
-  gchar *bufp = buf;
-  gchar *s = "";
-
-  buf[0] = '\0';
-
-#define BIT(x)						\
-  if (state & GDK_WINDOW_STATE_ ## x)			\
-    (bufp += sprintf (bufp, "%s" #x, s), s = "|")
-
-  /* For clarity, also show the complement of WITHDRAWN, i.e. "MAPPED" */
-  if (!(state & GDK_WINDOW_STATE_WITHDRAWN))
-    (bufp += sprintf (bufp, "MAPPED"), s = "|");
-
-  BIT (WITHDRAWN);
-  BIT (ICONIFIED);
-  BIT (MAXIMIZED);
-  BIT (STICKY);
-#undef BIT
-
-  return static_printf ("%s", buf);  
-}
-
-gchar *
-_gdk_win32_window_style_to_string (LONG style)
-{
-  gchar buf[1000];
-  gchar *bufp = buf;
-  gchar *s = "";
-
-  buf[0] = '\0';
-
-#define BIT(x)						\
-  if (style & WS_ ## x)					\
-    (bufp += sprintf (bufp, "%s" #x, s), s = "|")
-
-  /* Note that many of the WS_* macros are in face several bits.
-   * Handle just the individual bits here. Sort as in w32api's
-   * winuser.h.
-   */
-  BIT (BORDER);
-  BIT (CHILD);
-  BIT (CLIPCHILDREN);
-  BIT (CLIPSIBLINGS);
-  BIT (DISABLED);
-  BIT (DLGFRAME);
-  BIT (GROUP);
-  BIT (HSCROLL);
-  BIT (ICONIC);
-  BIT (MAXIMIZE);
-  BIT (MAXIMIZEBOX);
-  BIT (MINIMIZE);
-  BIT (MINIMIZEBOX);
-  BIT (POPUP);
-  BIT (SIZEBOX);
-  BIT (SYSMENU);
-  BIT (TABSTOP);
-  BIT (THICKFRAME);
-  BIT (VISIBLE);
-  BIT (VSCROLL);
-#undef BIT
-
-  return static_printf ("%s", buf);  
-}
-
-gchar *
-_gdk_win32_window_exstyle_to_string (LONG style)
-{
-  gchar buf[1000];
-  gchar *bufp = buf;
-  gchar *s = "";
-
-  buf[0] = '\0';
-
-#define BIT(x)						\
-  if (style & WS_EX_ ## x)				\
-    (bufp += sprintf (bufp, "%s" #x, s), s = "|")
-
-  /* Note that many of the WS_EX_* macros are in face several bits.
-   * Handle just the individual bits here. Sort as in w32api's
-   * winuser.h.
-   */
-  BIT (ACCEPTFILES);
-  BIT (APPWINDOW);
-  BIT (CLIENTEDGE);
-#ifndef WS_EX_COMPOSITED
-#  define WS_EX_COMPOSITED 0x02000000L
-#endif
-  BIT (COMPOSITED);
-  BIT (CONTEXTHELP);
-  BIT (CONTROLPARENT);
-  BIT (DLGMODALFRAME);
-  BIT (LAYERED);
-  BIT (LAYOUTRTL);
-  BIT (LEFTSCROLLBAR);
-  BIT (MDICHILD);
-  BIT (NOACTIVATE);
-  BIT (NOINHERITLAYOUT);
-  BIT (NOPARENTNOTIFY);
-  BIT (RIGHT);
-  BIT (RTLREADING);
-  BIT (STATICEDGE);
-  BIT (TOOLWINDOW);
-  BIT (TOPMOST);
-  BIT (TRANSPARENT);
-  BIT (WINDOWEDGE);
-#undef BIT
-
-  return static_printf ("%s", buf);  
-}
-
-gchar *
-_gdk_win32_window_pos_bits_to_string (UINT flags)
-{
-  gchar buf[1000];
-  gchar *bufp = buf;
-  gchar *s = "";
-
-  buf[0] = '\0';
-
-#define BIT(x)						\
-  if (flags & SWP_ ## x)				\
-    (bufp += sprintf (bufp, "%s" #x, s), s = "|")
-
-  BIT (DRAWFRAME);
-  BIT (FRAMECHANGED);
-  BIT (HIDEWINDOW);
-  BIT (NOACTIVATE);
-  BIT (NOCOPYBITS);
-  BIT (NOMOVE);
-  BIT (NOSIZE);
-  BIT (NOREDRAW);
-  BIT (NOZORDER);
-  BIT (SHOWWINDOW);
-  BIT (NOOWNERZORDER);
-  BIT (NOSENDCHANGING);
-  BIT (DEFERERASE);
-  BIT (ASYNCWINDOWPOS);
-#undef BIT
-
-  return static_printf ("%s", buf);  
-}
-
-gchar *
-_gdk_win32_drag_action_to_string (GdkDragAction actions)
-{
-  gchar buf[100];
-  gchar *bufp = buf;
-  gchar *s = "";
-
-  buf[0] = '\0';
-
-#define BIT(x)						\
-  if (actions & GDK_ACTION_ ## x)				\
-    (bufp += sprintf (bufp, "%s" #x, s), s = "|")
-
-  BIT (DEFAULT);
-  BIT (COPY);
-  BIT (MOVE);
-  BIT (LINK);
-  BIT (PRIVATE);
-  BIT (ASK);
-#undef BIT
-
-  return static_printf ("%s", buf);  
-}
-
-gchar *
-_gdk_win32_rop2_to_string (int rop2)
-{
-  switch (rop2)
-    {
-#define CASE(x) case R2_##x: return #x
-      CASE (BLACK);
-      CASE (COPYPEN);
-      CASE (MASKNOTPEN);
-      CASE (MASKPEN);
-      CASE (MASKPENNOT);
-      CASE (MERGENOTPEN);
-      CASE (MERGEPEN);
-      CASE (MERGEPENNOT);
-      CASE (NOP);
-      CASE (NOT);
-      CASE (NOTCOPYPEN);
-      CASE (NOTMASKPEN);
-      CASE (NOTMERGEPEN);
-      CASE (NOTXORPEN);
-      CASE (WHITE);
-      CASE (XORPEN);
-#undef CASE
-    default: return static_printf ("illegal_%x", rop2);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_lbstyle_to_string (UINT brush_style)
-{
-  switch (brush_style)
-    {
-#define CASE(x) case BS_##x: return #x
-      CASE (DIBPATTERN);
-      CASE (DIBPATTERNPT);
-      CASE (HATCHED);
-      CASE (HOLLOW);
-      CASE (PATTERN);
-      CASE (SOLID);
-#undef CASE
-    default: return static_printf ("illegal_%d", brush_style);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_pstype_to_string (DWORD pen_style)
-{
-  switch (pen_style & PS_TYPE_MASK)
-    {
-    case PS_GEOMETRIC: return "GEOMETRIC";
-    case PS_COSMETIC: return "COSMETIC";
-    default: return static_printf ("illegal_%d", pen_style & PS_TYPE_MASK);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_psstyle_to_string (DWORD pen_style)
-{
-  switch (pen_style & PS_STYLE_MASK)
-    {
-#define CASE(x) case PS_##x: return #x
-      CASE (ALTERNATE);
-      CASE (SOLID);
-      CASE (DASH);
-      CASE (DOT);
-      CASE (DASHDOT);
-      CASE (DASHDOTDOT);
-      CASE (NULL);
-      CASE (USERSTYLE);
-      CASE (INSIDEFRAME);
-#undef CASE
-    default: return static_printf ("illegal_%d", pen_style & PS_STYLE_MASK);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_psendcap_to_string (DWORD pen_style)
-{
-  switch (pen_style & PS_ENDCAP_MASK)
-    {
-#define CASE(x) case PS_ENDCAP_##x: return #x
-      CASE (ROUND);
-      CASE (SQUARE);
-      CASE (FLAT);
-#undef CASE
-    default: return static_printf ("illegal_%d", pen_style & PS_ENDCAP_MASK);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_psjoin_to_string (DWORD pen_style)
-{
-  switch (pen_style & PS_JOIN_MASK)
-    {
-#define CASE(x) case PS_JOIN_##x: return #x
-      CASE (ROUND);
-      CASE (BEVEL);
-      CASE (MITER);
-#undef CASE
-    default: return static_printf ("illegal_%d", pen_style & PS_JOIN_MASK);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_message_to_string (UINT msg)
-{
-  switch (msg)
-    {
-#define CASE(x) case x: return #x
-      CASE (WM_NULL);
-      CASE (WM_CREATE);
-      CASE (WM_DESTROY);
-      CASE (WM_MOVE);
-      CASE (WM_SIZE);
-      CASE (WM_ACTIVATE);
-      CASE (WM_SETFOCUS);
-      CASE (WM_KILLFOCUS);
-      CASE (WM_ENABLE);
-      CASE (WM_SETREDRAW);
-      CASE (WM_SETTEXT);
-      CASE (WM_GETTEXT);
-      CASE (WM_GETTEXTLENGTH);
-      CASE (WM_PAINT);
-      CASE (WM_CLOSE);
-      CASE (WM_QUERYENDSESSION);
-      CASE (WM_QUERYOPEN);
-      CASE (WM_ENDSESSION);
-      CASE (WM_QUIT);
-      CASE (WM_ERASEBKGND);
-      CASE (WM_SYSCOLORCHANGE);
-      CASE (WM_SHOWWINDOW);
-      CASE (WM_WININICHANGE);
-      CASE (WM_DEVMODECHANGE);
-      CASE (WM_ACTIVATEAPP);
-      CASE (WM_FONTCHANGE);
-      CASE (WM_TIMECHANGE);
-      CASE (WM_CANCELMODE);
-      CASE (WM_SETCURSOR);
-      CASE (WM_MOUSEACTIVATE);
-      CASE (WM_CHILDACTIVATE);
-      CASE (WM_QUEUESYNC);
-      CASE (WM_GETMINMAXINFO);
-      CASE (WM_PAINTICON);
-      CASE (WM_ICONERASEBKGND);
-      CASE (WM_NEXTDLGCTL);
-      CASE (WM_SPOOLERSTATUS);
-      CASE (WM_DRAWITEM);
-      CASE (WM_MEASUREITEM);
-      CASE (WM_DELETEITEM);
-      CASE (WM_VKEYTOITEM);
-      CASE (WM_CHARTOITEM);
-      CASE (WM_SETFONT);
-      CASE (WM_GETFONT);
-      CASE (WM_SETHOTKEY);
-      CASE (WM_GETHOTKEY);
-      CASE (WM_QUERYDRAGICON);
-      CASE (WM_COMPAREITEM);
-      CASE (WM_GETOBJECT);
-      CASE (WM_COMPACTING);
-      CASE (WM_WINDOWPOSCHANGING);
-      CASE (WM_WINDOWPOSCHANGED);
-      CASE (WM_POWER);
-      CASE (WM_COPYDATA);
-      CASE (WM_CANCELJOURNAL);
-      CASE (WM_NOTIFY);
-      CASE (WM_INPUTLANGCHANGEREQUEST);
-      CASE (WM_INPUTLANGCHANGE);
-      CASE (WM_TCARD);
-      CASE (WM_HELP);
-      CASE (WM_USERCHANGED);
-      CASE (WM_NOTIFYFORMAT);
-      CASE (WM_CONTEXTMENU);
-      CASE (WM_STYLECHANGING);
-      CASE (WM_STYLECHANGED);
-      CASE (WM_DISPLAYCHANGE);
-      CASE (WM_GETICON);
-      CASE (WM_SETICON);
-      CASE (WM_NCCREATE);
-      CASE (WM_NCDESTROY);
-      CASE (WM_NCCALCSIZE);
-      CASE (WM_NCHITTEST);
-      CASE (WM_NCPAINT);
-      CASE (WM_NCACTIVATE);
-      CASE (WM_GETDLGCODE);
-      CASE (WM_SYNCPAINT);
-      CASE (WM_NCMOUSEMOVE);
-      CASE (WM_NCLBUTTONDOWN);
-      CASE (WM_NCLBUTTONUP);
-      CASE (WM_NCLBUTTONDBLCLK);
-      CASE (WM_NCRBUTTONDOWN);
-      CASE (WM_NCRBUTTONUP);
-      CASE (WM_NCRBUTTONDBLCLK);
-      CASE (WM_NCMBUTTONDOWN);
-      CASE (WM_NCMBUTTONUP);
-      CASE (WM_NCMBUTTONDBLCLK);
-      CASE (WM_NCXBUTTONDOWN);
-      CASE (WM_NCXBUTTONUP);
-      CASE (WM_NCXBUTTONDBLCLK);
-      CASE (WM_KEYDOWN);
-      CASE (WM_KEYUP);
-      CASE (WM_CHAR);
-      CASE (WM_DEADCHAR);
-      CASE (WM_SYSKEYDOWN);
-      CASE (WM_SYSKEYUP);
-      CASE (WM_SYSCHAR);
-      CASE (WM_SYSDEADCHAR);
-      CASE (WM_KEYLAST);
-      CASE (WM_IME_STARTCOMPOSITION);
-      CASE (WM_IME_ENDCOMPOSITION);
-      CASE (WM_IME_COMPOSITION);
-      CASE (WM_INITDIALOG);
-      CASE (WM_COMMAND);
-      CASE (WM_SYSCOMMAND);
-      CASE (WM_TIMER);
-      CASE (WM_HSCROLL);
-      CASE (WM_VSCROLL);
-      CASE (WM_INITMENU);
-      CASE (WM_INITMENUPOPUP);
-      CASE (WM_MENUSELECT);
-      CASE (WM_MENUCHAR);
-      CASE (WM_ENTERIDLE);
-      CASE (WM_MENURBUTTONUP);
-      CASE (WM_MENUDRAG);
-      CASE (WM_MENUGETOBJECT);
-      CASE (WM_UNINITMENUPOPUP);
-      CASE (WM_MENUCOMMAND);
-      CASE (WM_CHANGEUISTATE);
-      CASE (WM_UPDATEUISTATE);
-      CASE (WM_QUERYUISTATE);
-      CASE (WM_CTLCOLORMSGBOX);
-      CASE (WM_CTLCOLOREDIT);
-      CASE (WM_CTLCOLORLISTBOX);
-      CASE (WM_CTLCOLORBTN);
-      CASE (WM_CTLCOLORDLG);
-      CASE (WM_CTLCOLORSCROLLBAR);
-      CASE (WM_CTLCOLORSTATIC);
-      CASE (WM_MOUSEMOVE);
-      CASE (WM_LBUTTONDOWN);
-      CASE (WM_LBUTTONUP);
-      CASE (WM_LBUTTONDBLCLK);
-      CASE (WM_RBUTTONDOWN);
-      CASE (WM_RBUTTONUP);
-      CASE (WM_RBUTTONDBLCLK);
-      CASE (WM_MBUTTONDOWN);
-      CASE (WM_MBUTTONUP);
-      CASE (WM_MBUTTONDBLCLK);
-      CASE (WM_MOUSEWHEEL);
-      CASE (WM_MOUSEHWHEEL);
-      CASE (WM_XBUTTONDOWN);
-      CASE (WM_XBUTTONUP);
-      CASE (WM_XBUTTONDBLCLK);
-      CASE (WM_PARENTNOTIFY);
-      CASE (WM_ENTERMENULOOP);
-      CASE (WM_EXITMENULOOP);
-      CASE (WM_NEXTMENU);
-      CASE (WM_SIZING);
-      CASE (WM_CAPTURECHANGED);
-      CASE (WM_MOVING);
-      CASE (WM_POWERBROADCAST);
-      CASE (WM_DEVICECHANGE);
-      CASE (WM_MDICREATE);
-      CASE (WM_MDIDESTROY);
-      CASE (WM_MDIACTIVATE);
-      CASE (WM_MDIRESTORE);
-      CASE (WM_MDINEXT);
-      CASE (WM_MDIMAXIMIZE);
-      CASE (WM_MDITILE);
-      CASE (WM_MDICASCADE);
-      CASE (WM_MDIICONARRANGE);
-      CASE (WM_MDIGETACTIVE);
-      CASE (WM_MDISETMENU);
-      CASE (WM_ENTERSIZEMOVE);
-      CASE (WM_EXITSIZEMOVE);
-      CASE (WM_DROPFILES);
-      CASE (WM_MDIREFRESHMENU);
-      CASE (WM_IME_SETCONTEXT);
-      CASE (WM_IME_NOTIFY);
-      CASE (WM_IME_CONTROL);
-      CASE (WM_IME_COMPOSITIONFULL);
-      CASE (WM_IME_SELECT);
-      CASE (WM_IME_CHAR);
-      CASE (WM_IME_REQUEST);
-      CASE (WM_IME_KEYDOWN);
-      CASE (WM_IME_KEYUP);
-      CASE (WM_MOUSEHOVER);
-      CASE (WM_MOUSELEAVE);
-      CASE (WM_NCMOUSEHOVER);
-      CASE (WM_NCMOUSELEAVE);
-      CASE (WM_CUT);
-      CASE (WM_COPY);
-      CASE (WM_PASTE);
-      CASE (WM_CLEAR);
-      CASE (WM_UNDO);
-      CASE (WM_RENDERFORMAT);
-      CASE (WM_RENDERALLFORMATS);
-      CASE (WM_DESTROYCLIPBOARD);
-      CASE (WM_DRAWCLIPBOARD);
-      CASE (WM_PAINTCLIPBOARD);
-      CASE (WM_VSCROLLCLIPBOARD);
-      CASE (WM_SIZECLIPBOARD);
-      CASE (WM_ASKCBFORMATNAME);
-      CASE (WM_CHANGECBCHAIN);
-      CASE (WM_HSCROLLCLIPBOARD);
-      CASE (WM_QUERYNEWPALETTE);
-      CASE (WM_PALETTEISCHANGING);
-      CASE (WM_PALETTECHANGED);
-      CASE (WM_HOTKEY);
-      CASE (WM_PRINT);
-      CASE (WM_PRINTCLIENT);
-      CASE (WM_APPCOMMAND);
-      CASE (WM_HANDHELDFIRST);
-      CASE (WM_HANDHELDLAST);
-      CASE (WM_AFXFIRST);
-      CASE (WM_AFXLAST);
-      CASE (WM_PENWINFIRST);
-      CASE (WM_PENWINLAST);
-      CASE (WM_APP);
-      CASE (WT_PACKET);
-      CASE (WT_CSRCHANGE);
-      CASE (WT_PROXIMITY);
-#undef CASE
-    default:
-      if (msg >= WM_HANDHELDFIRST && msg <= WM_HANDHELDLAST)
-	return static_printf ("WM_HANDHELDFIRST+%d", msg - WM_HANDHELDFIRST);
-      else if (msg >= WM_AFXFIRST && msg <= WM_AFXLAST)
-	return static_printf ("WM_AFXFIRST+%d", msg - WM_AFXFIRST);
-      else if (msg >= WM_PENWINFIRST && msg <= WM_PENWINLAST)
-	return static_printf ("WM_PENWINFIRST+%d", msg - WM_PENWINFIRST);
-      else if (msg >= WM_USER && msg <= 0x7FFF)
-	return static_printf ("WM_USER+%d", msg - WM_USER);
-      else if (msg >= 0xC000 && msg <= 0xFFFF)
-	return static_printf ("reg-%#x", msg);
-      else
-	return static_printf ("unk-%#x", msg);
-    }
-  /* NOTREACHED */
-  return NULL;
-}
-
-gchar *
-_gdk_win32_key_to_string (LONG lParam)
-{
-  char buf[100];
-  gchar *keyname_utf8;
-
-  if (GetKeyNameText (lParam, buf, sizeof (buf)) &&
-      (keyname_utf8 = g_locale_to_utf8 (buf, -1, NULL, NULL, NULL)) != NULL)
-    {
-      gchar *retval = static_printf ("%s", keyname_utf8);
-
-      g_free (keyname_utf8);
-
-      return retval;
-    }
-
-  return static_printf ("unk-%#lx", lParam);
-}
-      
-gchar *
-_gdk_win32_cf_to_string (UINT format)
-{
-  char buf[100];
-
-  switch (format)
-    {
-#define CASE(x) case CF_##x: return "CF_" #x
-      CASE (BITMAP);
-      CASE (DIB);
-      CASE (DIBV5);
-      CASE (DIF);
-      CASE (DSPBITMAP);
-      CASE (DSPENHMETAFILE);
-      CASE (DSPMETAFILEPICT);
-      CASE (DSPTEXT);
-      CASE (ENHMETAFILE);
-      CASE (HDROP);
-      CASE (LOCALE);
-      CASE (METAFILEPICT);
-      CASE (OEMTEXT);
-      CASE (OWNERDISPLAY);
-      CASE (PALETTE);
-      CASE (PENDATA);
-      CASE (RIFF);
-      CASE (SYLK);
-      CASE (TEXT);
-      CASE (WAVE);
-      CASE (TIFF);
-      CASE (UNICODETEXT);
-    default:
-      if (format >= CF_GDIOBJFIRST &&
-	  format <= CF_GDIOBJLAST)
-	return static_printf ("CF_GDIOBJ%d", format - CF_GDIOBJFIRST);
-      if (format >= CF_PRIVATEFIRST &&
-	  format <= CF_PRIVATELAST)
-	return static_printf ("CF_PRIVATE%d", format - CF_PRIVATEFIRST);
-      if (GetClipboardFormatName (format, buf, sizeof (buf)))
-	return static_printf ("'%s'", buf);
-      else
-	return static_printf ("unk-%#lx", format);
-    }
-}
-      
-gchar *
-_gdk_win32_data_to_string (const guchar *data,
-			   int           nbytes)
-{
-  GString *s = g_string_new ("");
-  int i;
-  gchar *retval;
-
-  for (i = 0; i < nbytes; i++)
-    if (data[i] >=' ' && data[i] <= '~')
-      g_string_append_printf (s, "%c  ", data[i]);
-    else
-      g_string_append_printf (s, "%02X ", data[i]);
-
-  retval = static_printf ("%s", s->str);
-  g_string_free (s, TRUE);
-
-  return retval;
-}
-
-gchar *
-_gdk_win32_rect_to_string (const RECT *rect)
-{
-  return static_printf ("%ldx%ld@%+ld%+ld",
-			(rect->right - rect->left), (rect->bottom - rect->top),
-			rect->left, rect->top);
-}
-
-gchar *
-_gdk_win32_gdkrectangle_to_string (const GdkRectangle *rect)
-{
-  return static_printf ("%dx%d@%+d%+d",
-			rect->width, rect->height,
-			rect->x, rect->y);
-}
-
-gchar *
-_gdk_win32_gdkregion_to_string (const GdkRegion *rgn)
-{
-  return static_printf ("%dx%d@%+d%+d",
-			(rgn->extents.x2 - rgn->extents.x1),
-			(rgn->extents.y2 - rgn->extents.y1),
-			rgn->extents.x1, rgn->extents.y1);
-}
-
-gchar *
-_gdk_win32_drawable_description (GdkDrawable *d)
-{
-  gint width, height, depth;
-
-  g_return_val_if_fail (GDK_IS_DRAWABLE (d), NULL);
-
-  gdk_drawable_get_size (d, &width, &height);
-  depth = gdk_drawable_get_depth (d);
-
-  return static_printf ("%s:%p:%dx%dx%d",
-			G_OBJECT_TYPE_NAME (d),
-			GDK_DRAWABLE_HANDLE (d),
-			width, height, depth);
-}
-
-#endif /* G_ENABLE_DEBUG */
diff --git a/gdk/win32/gdkpixmap-win32.c b/gdk/win32/gdkpixmap-win32.c
deleted file mode 100644
index 0c5251a..0000000
--- a/gdk/win32/gdkpixmap-win32.c
+++ /dev/null
@@ -1,544 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "gdkpixmap.h"
-#include "gdkdisplay.h"
-#include "gdkscreen.h"
-
-#include "gdkprivate-win32.h"
-#include <cairo-win32.h>
-
-static void gdk_pixmap_impl_win32_get_size   (GdkDrawable        *drawable,
-					      gint               *width,
-					      gint               *height);
-
-static void gdk_pixmap_impl_win32_init       (GdkPixmapImplWin32      *pixmap);
-static void gdk_pixmap_impl_win32_class_init (GdkPixmapImplWin32Class *klass);
-static void gdk_pixmap_impl_win32_finalize   (GObject                 *object);
-
-static gpointer parent_class = NULL;
-
-GType
-_gdk_pixmap_impl_win32_get_type (void)
-{
-  static GType object_type = 0;
-
-  if (!object_type)
-    {
-      const GTypeInfo object_info =
-      {
-        sizeof (GdkPixmapImplWin32Class),
-        (GBaseInitFunc) NULL,
-        (GBaseFinalizeFunc) NULL,
-        (GClassInitFunc) gdk_pixmap_impl_win32_class_init,
-        NULL,           /* class_finalize */
-        NULL,           /* class_data */
-        sizeof (GdkPixmapImplWin32),
-        0,              /* n_preallocs */
-        (GInstanceInitFunc) gdk_pixmap_impl_win32_init,
-      };
-      
-      object_type = g_type_register_static (GDK_TYPE_DRAWABLE_IMPL_WIN32,
-                                            "GdkPixmapImplWin32",
-                                            &object_info, 0);
-    }
-  
-  return object_type;
-}
-
-GType
-_gdk_pixmap_impl_get_type (void)
-{
-  return _gdk_pixmap_impl_win32_get_type ();
-}
-
-static void
-gdk_pixmap_impl_win32_init (GdkPixmapImplWin32 *impl)
-{
-  impl->width = 1;
-  impl->height = 1;
-}
-
-static void
-gdk_pixmap_impl_win32_class_init (GdkPixmapImplWin32Class *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GdkDrawableClass *drawable_class = GDK_DRAWABLE_CLASS (klass);
-  
-  parent_class = g_type_class_peek_parent (klass);
-
-  object_class->finalize = gdk_pixmap_impl_win32_finalize;
-
-  drawable_class->get_size = gdk_pixmap_impl_win32_get_size;
-}
-
-static void
-gdk_pixmap_impl_win32_finalize (GObject *object)
-{
-  GdkPixmapImplWin32 *impl = GDK_PIXMAP_IMPL_WIN32 (object);
-  GdkDrawableImplWin32 *drawable_impl = GDK_DRAWABLE_IMPL_WIN32 (impl);
-  GdkPixmap *wrapper = GDK_PIXMAP (drawable_impl->wrapper);
-
-  GDK_NOTE (PIXMAP, g_print ("gdk_pixmap_impl_win32_finalize: %p\n",
-			     GDK_PIXMAP_HBITMAP (wrapper)));
-
-  if (!impl->is_foreign)
-    {
-      /* Only decrement count if we did set the hdc */
-      if (drawable_impl->hdc)
-	drawable_impl->hdc_count--;
-
-      if (drawable_impl->cairo_surface)
-	{
-	  /* Tell outstanding owners that the surface is useless */
-	  cairo_surface_finish (drawable_impl->cairo_surface);
-
-	  /* Drop our reference */
-	  cairo_surface_destroy (drawable_impl->cairo_surface);
-	  drawable_impl->cairo_surface = NULL;
-	  if (impl->is_allocated)
-	    {
-	      GDI_CALL (DeleteDC, (drawable_impl->hdc));
-	      GDI_CALL (DeleteObject, (GDK_PIXMAP_HBITMAP (wrapper)));
-	    }
-	}
-    }
-
-  _gdk_win32_drawable_finish (GDK_DRAWABLE (object));
-
-  gdk_win32_handle_table_remove (GDK_PIXMAP_HBITMAP (wrapper));
-
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-static void
-gdk_pixmap_impl_win32_get_size (GdkDrawable *drawable,
-				gint        *width,
-				gint        *height)
-{
-  if (width)
-    *width = GDK_PIXMAP_IMPL_WIN32 (drawable)->width;
-  if (height)
-    *height = GDK_PIXMAP_IMPL_WIN32 (drawable)->height;
-}
-
-GdkPixmap*
-_gdk_pixmap_new (GdkDrawable *drawable,
-		gint         width,
-		gint         height,
-		gint         depth)
-{
-  HDC hdc;
-  HBITMAP hbitmap;
-  GdkPixmap *pixmap;
-  GdkDrawableImplWin32 *drawable_impl;
-  GdkPixmapImplWin32 *pixmap_impl;
-  GdkColormap *cmap;
-  gint window_depth;
-  cairo_surface_t *dib_surface, *image_surface;
-  cairo_format_t format;
-  guchar *bits;
-
-  g_return_val_if_fail (drawable == NULL || GDK_IS_DRAWABLE (drawable), NULL);
-  g_return_val_if_fail ((drawable != NULL) || (depth != -1), NULL);
-  g_return_val_if_fail ((width != 0) && (height != 0), NULL);
-
-  if (!drawable)
-    drawable = _gdk_root;
-
-  if (GDK_IS_WINDOW (drawable) && GDK_WINDOW_DESTROYED (drawable))
-    return NULL;
-
-  window_depth = gdk_drawable_get_depth (GDK_DRAWABLE (drawable));
-  if (depth == -1)
-    depth = window_depth;
-
-  GDK_NOTE (PIXMAP, g_print ("gdk_pixmap_new: %dx%dx%d drawable=%p\n",
-			     width, height, depth, drawable));
-
-  switch (depth)
-    {
-    case 1:
-      format = CAIRO_FORMAT_A1;
-      break;
-
-    case 8:
-      format = CAIRO_FORMAT_A8;
-      break;
-
-    case 15:
-    case 16:
-      format = CAIRO_FORMAT_RGB16_565;
-      break;
-
-    case 24:
-    case 32:
-      format = CAIRO_FORMAT_RGB24;
-      break;
-
-    default:
-      g_warning ("gdk_win32_pixmap_new: depth = %d not supported", depth);
-      return NULL;
-      break;
-    }
-
-  pixmap = g_object_new (gdk_pixmap_get_type (), NULL);
-  drawable_impl = GDK_DRAWABLE_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl);
-  pixmap_impl = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl);
-  drawable_impl->wrapper = GDK_DRAWABLE (pixmap);
-  
-  pixmap_impl->is_foreign = FALSE;
-  pixmap_impl->width = width;
-  pixmap_impl->height = height;
-  GDK_PIXMAP_OBJECT (pixmap)->depth = depth;
-
-  if (depth == window_depth)
-    {
-      cmap = gdk_drawable_get_colormap (drawable);
-      if (cmap)
-        gdk_drawable_set_colormap (pixmap, cmap);
-    }
-
-  if (depth != 15 && depth != 16)
-    {
-      dib_surface = cairo_win32_surface_create_with_dib (format, width, height);
-      if (dib_surface == NULL ||
-	  cairo_surface_status (dib_surface) != CAIRO_STATUS_SUCCESS)
-	{
-	  g_object_unref ((GObject *) pixmap);
-	  return NULL;
-	}
-
-      /* We need to have cairo create the dibsection for us, because
-	 creating a cairo surface from a hdc only works for rgb24 format */
-      hdc = cairo_win32_surface_get_dc (dib_surface);
-
-      /* Get the bitmap from the cairo hdc */
-      hbitmap = GetCurrentObject (hdc, OBJ_BITMAP);
-
-      /* Cairo_win32_surface_get_image() returns NULL on failure, but
-	 this is likely an oversight and future versions will return a
-	 "nil" surface.
-       */
-      image_surface = cairo_win32_surface_get_image (dib_surface);
-      if (image_surface == NULL ||
-	  cairo_surface_status (image_surface) != CAIRO_STATUS_SUCCESS)
-      {
-	cairo_surface_destroy (dib_surface);
-	g_object_unref ((GObject*) pixmap);
-	return NULL;
-      }
-      bits = cairo_image_surface_get_data (image_surface);
-    }
-  else
-    {
-      /* 16 bpp not supported by win32 cairo surface */
-      struct {
-	BITMAPINFOHEADER bmiHeader;
-	union {
-	  WORD bmiIndices[256];
-	  DWORD bmiMasks[3];
-	  RGBQUAD bmiColors[256];
-	} u;
-      } bmi;
-      UINT iUsage;
-      HWND hwnd;
-      GdkVisual *visual;
-
-      if (GDK_IS_WINDOW (drawable))
-	hwnd = GDK_WINDOW_HWND (drawable);
-      else
-	hwnd = GetDesktopWindow ();
-      if ((hdc = GetDC (hwnd)) == NULL)
-	{
-	  WIN32_GDI_FAILED ("GetDC");
-	  g_object_unref ((GObject *) pixmap);
-	  return NULL;
-	}
-
-      bmi.bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
-      bmi.bmiHeader.biWidth = width;
-      bmi.bmiHeader.biHeight = -height;
-      bmi.bmiHeader.biPlanes = 1;
-      bmi.bmiHeader.biBitCount = 16;
-      bmi.bmiHeader.biCompression = BI_BITFIELDS;
-      bmi.bmiHeader.biSizeImage = 0;
-      bmi.bmiHeader.biXPelsPerMeter =
-	bmi.bmiHeader.biYPelsPerMeter = 0;
-      bmi.bmiHeader.biClrUsed = 0;
-      bmi.bmiHeader.biClrImportant = 0;
-
-      iUsage = DIB_RGB_COLORS;
-      visual = gdk_visual_get_system ();
-      bmi.u.bmiMasks[0] = visual->red_mask;
-      bmi.u.bmiMasks[1] = visual->green_mask;
-      bmi.u.bmiMasks[2] = visual->blue_mask;
-
-      if ((hbitmap = CreateDIBSection (hdc, (BITMAPINFO *) &bmi,
-				       iUsage, (PVOID *) &bits, NULL, 0)) == NULL)
-	{
-	  WIN32_GDI_FAILED ("CreateDIBSection");
-	  GDI_CALL (ReleaseDC, (hwnd, hdc));
-	  g_object_unref ((GObject *) pixmap);
-	  return NULL;
-	}
-      GDI_CALL (ReleaseDC, (hwnd, hdc));
-
-      dib_surface = cairo_image_surface_create_for_data (bits,
-							 format, width, height,
-							 (width * 2 + 3) & ~3);
-
-      hdc = CreateCompatibleDC (NULL);
-      if (!hdc)
-	{
-	  WIN32_GDI_FAILED ("CreateCompatibleDC");
-	  g_object_unref ((GObject *) pixmap);
-	  return NULL;
-	}
-
-      SelectObject (hdc, hbitmap);
-      pixmap_impl->is_allocated = TRUE;
-    }
-
-  /* We need to use the same hdc, because only one hdc
-     can render to the same bitmap */
-  drawable_impl->hdc = hdc;
-  drawable_impl->hdc_count = 1; /* Ensure we never free the cairo surface HDC */
-
-  /* No need to create a new surface when needed, as we have one already */
-  drawable_impl->cairo_surface = dib_surface;
-  drawable_impl->handle = hbitmap;
-  pixmap_impl->bits = bits;
-
-  gdk_win32_handle_table_insert (&GDK_PIXMAP_HBITMAP (pixmap), pixmap);
-
-  return pixmap;
-}
-
-static const unsigned char mirror[256] = {
-  0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
-  0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
-  0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
-  0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
-  0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
-  0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
-  0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
-  0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
-  0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
-  0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
-  0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
-  0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
-  0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
-  0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
-  0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
-  0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
-  0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
-  0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
-  0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
-  0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
-  0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
-  0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
-  0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
-  0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
-  0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
-  0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
-  0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
-  0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
-  0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
-  0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
-  0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
-  0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
-};
-
-GdkPixmap *
-_gdk_bitmap_create_from_data (GdkDrawable *drawable,
-			     const gchar *data,
-			     gint         width,
-			     gint         height)
-{
-  GdkPixmap *pixmap;
-  GdkPixmapImplWin32 *pixmap_impl;
-  gint i, j, data_bpl, pixmap_bpl;
-  guchar *bits;
-
-  g_return_val_if_fail (data != NULL, NULL);
-  g_return_val_if_fail ((width != 0) && (height != 0), NULL);
-  g_return_val_if_fail (drawable == NULL || GDK_IS_DRAWABLE (drawable), NULL);
-
-  if (!drawable)
-    drawable = _gdk_root;
-  else if (GDK_IS_WINDOW (drawable) && GDK_WINDOW_DESTROYED (drawable))
-    return NULL;
-
-  pixmap = gdk_pixmap_new (drawable, width, height, 1);
-
-  if (pixmap == NULL)
-    return NULL;
-
-  pixmap_impl = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl);
-  bits = pixmap_impl->bits;
-  data_bpl = ((width - 1) / 8 + 1);
-  pixmap_bpl = ((width - 1)/32 + 1)*4;
-
-  for (i = 0; i < height; i++)
-    for (j = 0; j < data_bpl; j++)
-      bits[i*pixmap_bpl + j] = mirror[(guchar) data[i*data_bpl + j]];
-
-  GDK_NOTE (PIXMAP, g_print ("gdk_bitmap_create_from_data: %dx%d=%p\n",
-			     width, height, GDK_PIXMAP_HBITMAP (pixmap)));
-
-  return pixmap;
-}
-
-GdkPixmap*
-_gdk_pixmap_create_from_data (GdkDrawable    *drawable,
-			     const gchar    *data,
-			     gint            width,
-			     gint            height,
-			     gint            depth,
-			     const GdkColor *fg,
-			     const GdkColor *bg)
-{
-  /* Oh wow. I struggled with dozens of lines of code trying to get
-   * this right using a monochrome Win32 bitmap created from data, and
-   * a colour DIB section as the result, trying setting pens,
-   * background colors, whatnot and BitBlt:ing.  Nope. Then finally I
-   * realized it's much easier to do it using gdk...:
-   */
-
-  GdkPixmap *result;
-  GdkPixmap *source;
-  GdkGC *gc;
-
-  g_return_val_if_fail (drawable == NULL || GDK_IS_DRAWABLE (drawable), NULL);
-  g_return_val_if_fail (data != NULL, NULL);
-  g_return_val_if_fail (fg != NULL, NULL);
-  g_return_val_if_fail (bg != NULL, NULL);
-  g_return_val_if_fail ((drawable != NULL) || (depth != -1), NULL);
-  g_return_val_if_fail ((width != 0) && (height != 0), NULL);
-
-  if (GDK_IS_WINDOW (drawable) && GDK_WINDOW_DESTROYED (drawable))
-    return NULL;
-
-  result = gdk_pixmap_new (drawable, width, height, depth);
-  source = gdk_bitmap_create_from_data (drawable, data, width, height);
-  gc = gdk_gc_new (result);
-
-  gdk_gc_set_foreground (gc, fg);
-  gdk_gc_set_background (gc, bg);
-  _gdk_win32_blit
-    (TRUE,
-     GDK_DRAWABLE_IMPL_WIN32 (GDK_PIXMAP_OBJECT (result)->impl),
-     gc, source, 0, 0, 0, 0, width, height);
-  g_object_unref (source);
-  g_object_unref (gc);
-
-  GDK_NOTE (PIXMAP, g_print ("gdk_pixmap_create_from_data: %dx%dx%d=%p\n",
-			     width, height, depth,
-			     GDK_PIXMAP_HBITMAP (result)));
-
-  return result;
-}
-
-GdkPixmap *
-gdk_pixmap_foreign_new_for_display (GdkDisplay      *display,
-				    GdkNativeWindow  anid)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-  g_return_val_if_fail (display == _gdk_display, NULL);
-
-  return gdk_pixmap_foreign_new (anid);
-}
-
-GdkPixmap *
-gdk_pixmap_foreign_new_for_screen (GdkScreen       *screen,
-				   GdkNativeWindow  anid,
-				   gint             width,
-				   gint             height,
-				   gint             depth)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
-
-  return gdk_pixmap_foreign_new (anid);
-}
-
-GdkPixmap*
-gdk_pixmap_foreign_new (GdkNativeWindow anid)
-{
-  GdkPixmap *pixmap;
-  GdkDrawableImplWin32 *draw_impl;
-  GdkPixmapImplWin32 *pix_impl;
-  HBITMAP hbitmap;
-  SIZE size;
-
-  /* Check to make sure we were passed a HBITMAP */
-  g_return_val_if_fail (GetObjectType ((HGDIOBJ) anid) == OBJ_BITMAP, NULL);
-
-  hbitmap = (HBITMAP) anid;
-
-  /* Get information about the bitmap to fill in the structure for the
-   * GDK window.
-   */
-  GetBitmapDimensionEx (hbitmap, &size);
-
-  /* Allocate a new GDK pixmap */
-  pixmap = g_object_new (gdk_pixmap_get_type (), NULL);
-  draw_impl = GDK_DRAWABLE_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl);
-  pix_impl = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl);
-  draw_impl->wrapper = GDK_DRAWABLE (pixmap);
-  
-  draw_impl->handle = hbitmap;
-  draw_impl->colormap = NULL;
-  pix_impl->is_foreign = TRUE;
-  pix_impl->width = size.cx;
-  pix_impl->height = size.cy;
-  pix_impl->bits = NULL;
-
-  gdk_win32_handle_table_insert (&GDK_PIXMAP_HBITMAP (pixmap), pixmap);
-
-  return pixmap;
-}
-
-GdkPixmap*
-gdk_pixmap_lookup (GdkNativeWindow anid)
-{
-  return (GdkPixmap*) gdk_win32_handle_table_lookup (anid);
-}
-
-GdkPixmap*
-gdk_pixmap_lookup_for_display (GdkDisplay *display, GdkNativeWindow anid)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-  g_return_val_if_fail (display == _gdk_display, NULL);
-
-  return gdk_pixmap_lookup (anid);
-}
diff --git a/gdk/win32/gdkpixmap-win32.h b/gdk/win32/gdkpixmap-win32.h
deleted file mode 100644
index e9d965d..0000000
--- a/gdk/win32/gdkpixmap-win32.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#ifndef __GDK_PIXMAP_WIN32_H__
-#define __GDK_PIXMAP_WIN32_H__
-
-#include <gdk/win32/gdkdrawable-win32.h>
-#include <gdk/gdkpixmap.h>
-
-G_BEGIN_DECLS
-
-/* Pixmap implementation for Win32
- */
-
-typedef struct _GdkPixmapImplWin32 GdkPixmapImplWin32;
-typedef struct _GdkPixmapImplWin32Class GdkPixmapImplWin32Class;
-
-#define GDK_TYPE_PIXMAP_IMPL_WIN32              (_gdk_pixmap_impl_win32_get_type ())
-#define GDK_PIXMAP_IMPL_WIN32(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_PIXMAP_IMPL_WIN32, GdkPixmapImplWin32))
-#define GDK_PIXMAP_IMPL_WIN32_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_PIXMAP_IMPL_WIN32, GdkPixmapImplWin32Class))
-#define GDK_IS_PIXMAP_IMPL_WIN32(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_PIXMAP_IMPL_WIN32))
-#define GDK_IS_PIXMAP_IMPL_WIN32_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_PIXMAP_IMPL_WIN32))
-#define GDK_PIXMAP_IMPL_WIN32_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GDK_TYPE_PIXMAP_IMPL_WIN32, GdkPixmapImplWin32Class))
-
-struct _GdkPixmapImplWin32
-{
-  GdkDrawableImplWin32 parent_instance;
-
-  gint width;
-  gint height;
-  guchar *bits;
-  guint is_foreign : 1;
-  guint is_allocated : 1;
-};
- 
-struct _GdkPixmapImplWin32Class 
-{
-  GdkDrawableImplWin32Class parent_class;
-};
-
-GType _gdk_pixmap_impl_win32_get_type (void);
-
-G_END_DECLS
-
-#endif /* __GDK_PIXMAP_WIN32_H__ */
diff --git a/gdk/win32/gdkprivate-win32.h b/gdk/win32/gdkprivate-win32.h
deleted file mode 100644
index ef4fa56..0000000
--- a/gdk/win32/gdkprivate-win32.h
+++ /dev/null
@@ -1,519 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#ifndef __GDK_PRIVATE_WIN32_H__
-#define __GDK_PRIVATE_WIN32_H__
-
-#ifndef WINVER
-#define WINVER 0x0500
-#endif
-
-#ifndef _WIN32_WINNT
-#define _WIN32_WINNT WINVER
-#endif
-
-#include <gdk/gdkprivate.h>
-#include <gdk/win32/gdkwindow-win32.h>
-#include <gdk/win32/gdkpixmap-win32.h>
-#include <gdk/win32/gdkwin32keys.h>
-
-#include "gdkinternals.h"
-
-#include "config.h"
-
-/* Make up for some minor w32api or MSVC6 header lossage */
-
-#ifndef PS_JOIN_MASK
-#define PS_JOIN_MASK (PS_JOIN_BEVEL|PS_JOIN_MITER|PS_JOIN_ROUND)
-#endif
-
-#ifndef FS_VIETNAMESE
-#define FS_VIETNAMESE 0x100
-#endif
-
-#ifndef WM_GETOBJECT
-#define WM_GETOBJECT 0x3D
-#endif
-#ifndef WM_NCXBUTTONDOWN
-#define WM_NCXBUTTONDOWN 0xAB
-#endif
-#ifndef WM_NCXBUTTONUP
-#define WM_NCXBUTTONUP 0xAC
-#endif
-#ifndef WM_NCXBUTTONDBLCLK
-#define WM_NCXBUTTONDBLCLK 0xAD
-#endif
-#ifndef WM_CHANGEUISTATE
-#define WM_CHANGEUISTATE 0x127
-#endif
-#ifndef WM_UPDATEUISTATE
-#define WM_UPDATEUISTATE 0x128
-#endif
-#ifndef WM_QUERYUISTATE
-#define WM_QUERYUISTATE 0x129
-#endif
-#ifndef WM_XBUTTONDOWN
-#define WM_XBUTTONDOWN 0x20B
-#endif
-#ifndef WM_XBUTTONUP
-#define WM_XBUTTONUP 0x20C
-#endif
-#ifndef WM_XBUTTONDBLCLK
-#define WM_XBUTTONDBLCLK 0x20D
-#endif
-#ifndef WM_NCMOUSEHOVER
-#define WM_NCMOUSEHOVER 0x2A0
-#endif
-#ifndef WM_NCMOUSELEAVE
-#define WM_NCMOUSELEAVE 0x2A2
-#endif
-#ifndef WM_APPCOMMAND
-#define WM_APPCOMMAND 0x319
-#endif
-#ifndef WM_MOUSEHWHEEL
-#define WM_MOUSEHWHEEL 0x20E
-#endif
-
-#ifndef CF_DIBV5
-#define CF_DIBV5 17
-#endif
-
-
-/* Define some combinations of GdkDebugFlags */
-#define GDK_DEBUG_EVENTS_OR_COLORMAP (GDK_DEBUG_EVENTS|GDK_DEBUG_COLORMAP)
-#define GDK_DEBUG_EVENTS_OR_INPUT (GDK_DEBUG_EVENTS|GDK_DEBUG_INPUT)
-#define GDK_DEBUG_PIXMAP_OR_COLORMAP (GDK_DEBUG_PIXMAP|GDK_DEBUG_COLORMAP)
-#define GDK_DEBUG_MISC_OR_COLORMAP (GDK_DEBUG_MISC|GDK_DEBUG_COLORMAP)
-#define GDK_DEBUG_MISC_OR_EVENTS (GDK_DEBUG_MISC|GDK_DEBUG_EVENTS)
-
-#define GDK_TYPE_GC_WIN32              (_gdk_gc_win32_get_type ())
-#define GDK_GC_WIN32(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_GC_WIN32, GdkGCWin32))
-#define GDK_GC_WIN32_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_GC_WIN32, GdkGCWin32Class))
-#define GDK_IS_GC_WIN32(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_GC_WIN32))
-#define GDK_IS_GC_WIN32_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_GC_WIN32))
-#define GDK_GC_WIN32_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GDK_TYPE_GC_WIN32, GdkGCWin32Class))
-
-//#define GDK_WINDOW_SCREEN(win)         (_gdk_screen)
-GdkScreen *GDK_WINDOW_SCREEN(GObject *win);
-
-#define GDK_WINDOW_IS_WIN32(win)        (GDK_IS_WINDOW_IMPL_WIN32 (((GdkWindowObject *)win)->impl))
-
-typedef struct _GdkColormapPrivateWin32 GdkColormapPrivateWin32;
-typedef struct _GdkCursorPrivate        GdkCursorPrivate;
-typedef struct _GdkWin32SingleFont      GdkWin32SingleFont;
-typedef struct _GdkFontPrivateWin32     GdkFontPrivateWin32;
-typedef struct _GdkGCWin32		GdkGCWin32;
-typedef struct _GdkGCWin32Class		GdkGCWin32Class;
-
-struct _GdkCursorPrivate
-{
-  GdkCursor cursor;
-  HCURSOR hcursor;
-};
-
-struct _GdkWin32SingleFont
-{
-  HFONT hfont;
-  UINT charset;
-  UINT codepage;
-  FONTSIGNATURE fs;
-};
-
-#ifndef GDK_DISABLE_DEPRECATED
-
-struct _GdkFontPrivateWin32
-{
-  GdkFontPrivate base;
-  GSList *fonts;		/* List of GdkWin32SingleFonts */
-  GSList *names;
-};
-
-#endif /* GDK_DISABLE_DEPRECATED */
-
-struct _GdkVisualClass
-{
-  GObjectClass parent_class;
-};
-
-typedef enum {
-  GDK_WIN32_PE_STATIC,
-  GDK_WIN32_PE_AVAILABLE,
-  GDK_WIN32_PE_INUSE
-} GdkWin32PalEntryState;
-
-struct _GdkColormapPrivateWin32
-{
-  HPALETTE hpal;
-  gint current_size;		/* Current size of hpal */
-  GdkWin32PalEntryState *use;
-  gint private_val;
-
-  GHashTable *hash;
-  GdkColorInfo *info;
-};
-
-struct _GdkGCWin32
-{
-  GdkGC parent_instance;
-
-  /* A Windows Device Context (DC) is not equivalent to an X11
-   * GC. We can use a DC only in the window for which it was
-   * allocated, or (in the case of a memory DC) with the bitmap that
-   * has been selected into it. Thus, we have to release and
-   * reallocate a DC each time the GdkGC is used to paint into a new
-   * window or pixmap. We thus keep all the necessary values in the
-   * GdkGCWin32 object.
-   */
-
-  HRGN hcliprgn;
-
-  GdkGCValuesMask values_mask;
-
-  GdkFont *font;
-  gint rop2;
-  GdkSubwindowMode subwindow_mode;
-  gint graphics_exposures;
-  gint pen_width;
-  DWORD pen_style;
-  GdkLineStyle line_style;
-  GdkCapStyle cap_style;
-  GdkJoinStyle join_style;
-  DWORD *pen_dashes;		/* use for PS_USERSTYLE or step-by-step rendering */
-  gint pen_num_dashes;
-  gint pen_dash_offset;
-  HBRUSH pen_hbrbg;
-
-  /* Following fields are valid while the GC exists as a Windows DC */
-  HDC hdc;
-  int saved_dc;
-
-  HPALETTE holdpal;
-};
-
-struct _GdkGCWin32Class
-{
-  GdkGCClass parent_class;
-};
-
-GType _gdk_gc_win32_get_type (void);
-
-gulong _gdk_win32_get_next_tick (gulong suggested_tick);
-
-void _gdk_window_init_position     (GdkWindow *window);
-void _gdk_window_move_resize_child (GdkWindow *window,
-				    gint       x,
-				    gint       y,
-				    gint       width,
-				    gint       height);
-
-/* GdkWindowImpl methods */
-void _gdk_win32_window_scroll (GdkWindow *window,
-			       gint       dx,
-			       gint       dy);
-void _gdk_win32_window_move_region (GdkWindow       *window,
-				    const GdkRegion *region,
-				    gint             dx,
-				    gint             dy);
-void _gdk_win32_windowing_window_get_offsets (GdkWindow *window,
-					      gint      *x_offset,
-					      gint      *y_offset);
-
-
-void _gdk_win32_selection_init (void);
-void _gdk_win32_dnd_exit (void);
-
-void	 gdk_win32_handle_table_insert  (HANDLE   *handle,
-					 gpointer data);
-void	 gdk_win32_handle_table_remove  (HANDLE handle);
-
-GdkGC    *_gdk_win32_gc_new             (GdkDrawable        *drawable,
-					 GdkGCValues        *values,
-					 GdkGCValuesMask     values_mask);
-
-GdkImage *_gdk_win32_get_image 		(GdkDrawable *drawable,
-					 gint         x,
-					 gint         y,
-					 gint         width,
-					 gint         height);
-
-GdkImage *_gdk_win32_copy_to_image      (GdkDrawable *drawable,
-					 GdkImage    *image,
-					 gint         src_x,
-					 gint         src_y,
-					 gint         dest_x,
-					 gint         dest_y,
-					 gint         width,
-					 gint         height);
-
-void      _gdk_win32_blit               (gboolean              use_fg_bg,
-					 GdkDrawableImplWin32 *drawable,
-					 GdkGC       	       *gc,
-					 GdkDrawable   	       *src,
-					 gint        	    	xsrc,
-					 gint        	    	ysrc,
-					 gint        	    	xdest,
-					 gint        	    	ydest,
-					 gint        	    	width,
-					 gint        	    	height);
-
-COLORREF  _gdk_win32_colormap_color     (GdkColormap *colormap,
-				         gulong       pixel);
-
-HRGN	  _gdk_win32_bitmap_to_hrgn     (GdkPixmap   *bitmap);
-
-HRGN	  _gdk_win32_gdkregion_to_hrgn  (const GdkRegion *region,
-					 gint             x_origin,
-					 gint             y_origin);
-
-GdkRegion *_gdk_win32_hrgn_to_region    (HRGN hrgn);
-
-void	_gdk_win32_adjust_client_rect   (GdkWindow *window,
-					 RECT      *RECT);
-
-void    _gdk_selection_property_delete (GdkWindow *);
-
-void    _gdk_dropfiles_store (gchar *data);
-
-void    _gdk_wchar_text_handle    (GdkFont       *font,
-				   const wchar_t *wcstr,
-				   int            wclen,
-				   void         (*handler)(GdkWin32SingleFont *,
-							   const wchar_t *,
-							   int,
-							   void *),
-				   void          *arg);
-
-void       _gdk_push_modal_window   (GdkWindow *window);
-void       _gdk_remove_modal_window (GdkWindow *window);
-GdkWindow *_gdk_modal_current       (void);
-gboolean   _gdk_modal_blocked       (GdkWindow *window);
-
-#ifdef G_ENABLE_DEBUG
-gchar *_gdk_win32_color_to_string      (const GdkColor *color);
-void   _gdk_win32_print_paletteentries (const PALETTEENTRY *pep,
-					const int           nentries);
-void   _gdk_win32_print_system_palette (void);
-void   _gdk_win32_print_hpalette       (HPALETTE     hpal);
-void   _gdk_win32_print_dc             (HDC          hdc);
-
-gchar *_gdk_win32_cap_style_to_string  (GdkCapStyle  cap_style);
-gchar *_gdk_win32_fill_style_to_string (GdkFill      fill);
-gchar *_gdk_win32_function_to_string   (GdkFunction  function);
-gchar *_gdk_win32_join_style_to_string (GdkJoinStyle join_style);
-gchar *_gdk_win32_line_style_to_string (GdkLineStyle line_style);
-gchar *_gdk_win32_drag_protocol_to_string (GdkDragProtocol protocol);
-gchar *_gdk_win32_gcvalues_mask_to_string (GdkGCValuesMask mask);
-gchar *_gdk_win32_window_state_to_string (GdkWindowState state);
-gchar *_gdk_win32_window_style_to_string (LONG style);
-gchar *_gdk_win32_window_exstyle_to_string (LONG style);
-gchar *_gdk_win32_window_pos_bits_to_string (UINT flags);
-gchar *_gdk_win32_drag_action_to_string (GdkDragAction actions);
-gchar *_gdk_win32_drawable_description (GdkDrawable *d);
-
-gchar *_gdk_win32_rop2_to_string       (int          rop2);
-gchar *_gdk_win32_lbstyle_to_string    (UINT         brush_style);
-gchar *_gdk_win32_pstype_to_string     (DWORD        pen_style);
-gchar *_gdk_win32_psstyle_to_string    (DWORD        pen_style);
-gchar *_gdk_win32_psendcap_to_string   (DWORD        pen_style);
-gchar *_gdk_win32_psjoin_to_string     (DWORD        pen_style);
-gchar *_gdk_win32_message_to_string    (UINT         msg);
-gchar *_gdk_win32_key_to_string        (LONG         lParam);
-gchar *_gdk_win32_cf_to_string         (UINT         format);
-gchar *_gdk_win32_data_to_string       (const guchar*data,
-					int          nbytes);
-gchar *_gdk_win32_rect_to_string       (const RECT  *rect);
-
-gchar *_gdk_win32_gdkrectangle_to_string (const GdkRectangle *rect);
-gchar *_gdk_win32_gdkregion_to_string    (const GdkRegion    *box);
-
-void   _gdk_win32_print_event            (const GdkEvent     *event);
-
-#endif
-
-gchar  *_gdk_win32_last_error_string (void);
-void    _gdk_win32_api_failed        (const gchar *where,
-				     const gchar *api);
-void    _gdk_other_api_failed        (const gchar *where,
-				     const gchar *api);
-
-#define WIN32_API_FAILED(api) _gdk_win32_api_failed (G_STRLOC , api)
-#define WIN32_GDI_FAILED(api) WIN32_API_FAILED (api)
-#define OTHER_API_FAILED(api) _gdk_other_api_failed (G_STRLOC, api)
- 
-/* These two macros call a GDI or other Win32 API and if the return
- * value is zero or NULL, print a warning message. The majority of GDI
- * calls return zero or NULL on failure. The value of the macros is nonzero
- * if the call succeeded, zero otherwise.
- */
-
-#define GDI_CALL(api, arglist) (api arglist ? 1 : (WIN32_GDI_FAILED (#api), 0))
-#define API_CALL(api, arglist) (api arglist ? 1 : (WIN32_API_FAILED (#api), 0))
- 
-extern LRESULT CALLBACK _gdk_win32_window_procedure (HWND, UINT, WPARAM, LPARAM);
-
-extern GdkWindow        *_gdk_root;
-
-extern GdkDisplay       *_gdk_display;
-extern GdkScreen        *_gdk_screen;
-
-extern gint		 _gdk_num_monitors;
-typedef struct _GdkWin32Monitor GdkWin32Monitor;
-struct _GdkWin32Monitor
-{
-  gchar *name;
-  gint width_mm, height_mm;
-  GdkRectangle rect;
-};
-extern GdkWin32Monitor  *_gdk_monitors;
-
-/* Offsets to add to Windows coordinates (which are relative to the
- * primary monitor's origin, and thus might be negative for monitors
- * to the left and/or above the primary monitor) to get GDK
- * coordinates, which should be non-negative on the whole screen.
- */
-extern gint		 _gdk_offset_x, _gdk_offset_y;
-
-extern HDC		 _gdk_display_hdc;
-extern HINSTANCE	 _gdk_dll_hinstance;
-extern HINSTANCE	 _gdk_app_hmodule;
-
-/* These are thread specific, but GDK/win32 works OK only when invoked
- * from a single thread anyway.
- */
-extern HKL		 _gdk_input_locale;
-extern gboolean		 _gdk_input_locale_is_ime;
-extern UINT		 _gdk_input_codepage;
-
-extern guint		 _gdk_keymap_serial;
-
-/* GdkAtoms: properties, targets and types */
-extern GdkAtom		 _gdk_selection;
-extern GdkAtom		 _wm_transient_for;
-extern GdkAtom		 _targets;
-extern GdkAtom		 _delete;
-extern GdkAtom		 _save_targets;
-extern GdkAtom           _utf8_string;
-extern GdkAtom		 _text;
-extern GdkAtom		 _compound_text;
-extern GdkAtom		 _text_uri_list;
-extern GdkAtom		 _text_html;
-extern GdkAtom		 _image_png;
-extern GdkAtom		 _image_jpeg;
-extern GdkAtom		 _image_bmp;
-extern GdkAtom		 _image_gif;
-
-/* DND selections */
-extern GdkAtom           _local_dnd;
-extern GdkAtom		 _gdk_win32_dropfiles;
-extern GdkAtom		 _gdk_ole2_dnd;
-
-/* Clipboard formats */
-extern UINT		 _cf_png;
-extern UINT		 _cf_jfif;
-extern UINT		 _cf_gif;
-extern UINT		 _cf_url;
-extern UINT		 _cf_html_format;
-extern UINT		 _cf_text_html;
-
-/* OLE-based DND state */
-typedef enum {
-  GDK_WIN32_DND_NONE,
-  GDK_WIN32_DND_PENDING,
-  GDK_WIN32_DND_DROPPED,
-  GDK_WIN32_DND_FAILED,
-  GDK_WIN32_DND_DRAGGING,
-} GdkWin32DndState;
-
-extern GdkWin32DndState  _dnd_target_state;
-extern GdkWin32DndState  _dnd_source_state;
-
-void _gdk_win32_dnd_do_dragdrop (void);
-void _gdk_win32_ole2_dnd_property_change (GdkAtom       type,
-					  gint          format,
-					  const guchar *data,
-					  gint          nelements);
-
-void  _gdk_win32_begin_modal_call (void);
-void  _gdk_win32_end_modal_call (void);
-
-
-/* Options */
-extern gboolean		 _gdk_input_ignore_wintab;
-extern gint		 _gdk_max_colors;
-
-#define GDK_WIN32_COLORMAP_DATA(cmap) ((GdkColormapPrivateWin32 *) GDK_COLORMAP (cmap)->windowing_data)
-
-/* TRUE while a modal sizing, moving, or dnd operation is in progress */
-extern gboolean		_modal_operation_in_progress;
-
-extern HWND		_modal_move_resize_window;
-
-/* TRUE when we are emptying the clipboard ourselves */
-extern gboolean		_ignore_destroy_clipboard;
-
-/* Mapping from registered clipboard format id (native) to
- * corresponding GdkAtom
- */
-extern GHashTable	*_format_atom_table;
-
-/* Hold the result of a delayed rendering */
-extern HGLOBAL		_delayed_rendering_data;
-
-HGLOBAL _gdk_win32_selection_convert_to_dib (HGLOBAL  hdata,
-					     GdkAtom  target);
-
-/* Convert a pixbuf to an HICON (or HCURSOR).  Supports alpha under
- * Windows XP, thresholds alpha otherwise.
- */
-HICON _gdk_win32_pixbuf_to_hicon   (GdkPixbuf *pixbuf);
-HICON _gdk_win32_pixbuf_to_hcursor (GdkPixbuf *pixbuf,
-				    gint       x_hotspot,
-				    gint       y_hotspot);
-gboolean _gdk_win32_pixbuf_to_hicon_supports_alpha (void);
-
-void _gdk_win32_append_event (GdkEvent *event);
-void _gdk_win32_emit_configure_event (GdkWindow *window);
-GdkWindow *_gdk_win32_find_window_for_mouse_event (GdkWindow* reported_window,
-						   MSG*       msg);
-
-guint32    _gdk_win32_keymap_get_decimal_mark    (GdkWin32Keymap *keymap);
-gboolean   _gdk_win32_keymap_has_altgr           (GdkWin32Keymap *keymap);
-guint8     _gdk_win32_keymap_get_active_group    (GdkWin32Keymap *keymap);
-guint8     _gdk_win32_keymap_get_rshift_scancode (GdkWin32Keymap *keymap);
-void       _gdk_win32_keymap_set_active_layout   (GdkWin32Keymap *keymap,
-                                                  HKL             hkl);
-
-/* Initialization */
-void _gdk_windowing_window_init (GdkScreen *screen);
-void _gdk_root_window_size_init (void);
-void _gdk_monitor_init(void);
-void _gdk_visual_init (void);
-void _gdk_dnd_init    (void);
-void _gdk_windowing_image_init  (void);
-void _gdk_events_init (void);
-void _gdk_input_init  (GdkDisplay *display);
-
-#endif /* __GDK_PRIVATE_WIN32_H__ */
diff --git a/gdk/win32/gdkproperty-win32.c b/gdk/win32/gdkproperty-win32.c
deleted file mode 100644
index 88c8c1b..0000000
--- a/gdk/win32/gdkproperty-win32.c
+++ /dev/null
@@ -1,460 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <string.h>
-#include <stdlib.h>
-#include <glib/gprintf.h>
-
-#include "gdkscreen.h"
-#include "gdkproperty.h"
-#include "gdkselection.h"
-#include "gdkprivate-win32.h"
-
-GdkAtom
-gdk_atom_intern (const gchar *atom_name,
-		 gint         only_if_exists)
-{
-  ATOM win32_atom;
-  GdkAtom retval;
-  static GHashTable *atom_hash = NULL;
-  
-  if (!atom_hash)
-    atom_hash = g_hash_table_new (g_str_hash, g_str_equal);
-
-  retval = g_hash_table_lookup (atom_hash, atom_name);
-  if (!retval)
-    {
-      if (strcmp (atom_name, "PRIMARY") == 0)
-	retval = GDK_SELECTION_PRIMARY;
-      else if (strcmp (atom_name, "SECONDARY") == 0)
-	retval = GDK_SELECTION_SECONDARY;
-      else if (strcmp (atom_name, "CLIPBOARD") == 0)
-	retval = GDK_SELECTION_CLIPBOARD;
-      else if (strcmp (atom_name, "ATOM") == 0)
-	retval = GDK_SELECTION_TYPE_ATOM;
-      else if (strcmp (atom_name, "BITMAP") == 0)
-	retval = GDK_SELECTION_TYPE_BITMAP;
-      else if (strcmp (atom_name, "COLORMAP") == 0)
-	retval = GDK_SELECTION_TYPE_COLORMAP;
-      else if (strcmp (atom_name, "DRAWABLE") == 0)
-	retval = GDK_SELECTION_TYPE_DRAWABLE;
-      else if (strcmp (atom_name, "INTEGER") == 0)
-	retval = GDK_SELECTION_TYPE_INTEGER;
-      else if (strcmp (atom_name, "PIXMAP") == 0)
-	retval = GDK_SELECTION_TYPE_PIXMAP;
-      else if (strcmp (atom_name, "WINDOW") == 0)
-	retval = GDK_SELECTION_TYPE_WINDOW;
-      else if (strcmp (atom_name, "STRING") == 0)
-	retval = GDK_SELECTION_TYPE_STRING;
-      else
-	{
-	  win32_atom = GlobalAddAtom (atom_name);
-	  retval = GUINT_TO_POINTER ((guint) win32_atom);
-	}
-      g_hash_table_insert (atom_hash, 
-			   g_strdup (atom_name), 
-			   retval);
-    }
-
-  return retval;
-}
-
-GdkAtom
-gdk_atom_intern_static_string (const gchar *atom_name)
-{
-  /* on X11 this is supposed to save memory. On win32 there seems to be
-   * no way to make a difference ?
-   */
-  return gdk_atom_intern (atom_name, FALSE);
-}
-
-gchar *
-gdk_atom_name (GdkAtom atom)
-{
-  ATOM win32_atom;
-  gchar name[256];
-
-  if (GDK_NONE == atom) return g_strdup ("<none>");
-  else if (GDK_SELECTION_PRIMARY == atom) return g_strdup ("PRIMARY");
-  else if (GDK_SELECTION_SECONDARY == atom) return g_strdup ("SECONDARY");
-  else if (GDK_SELECTION_CLIPBOARD == atom) return g_strdup ("CLIPBOARD");
-  else if (GDK_SELECTION_TYPE_ATOM == atom) return g_strdup ("ATOM");
-  else if (GDK_SELECTION_TYPE_BITMAP == atom) return g_strdup ("BITMAP");
-  else if (GDK_SELECTION_TYPE_COLORMAP == atom) return g_strdup ("COLORMAP");
-  else if (GDK_SELECTION_TYPE_DRAWABLE == atom) return g_strdup ("DRAWABLE");
-  else if (GDK_SELECTION_TYPE_INTEGER == atom) return g_strdup ("INTEGER");
-  else if (GDK_SELECTION_TYPE_PIXMAP == atom) return g_strdup ("PIXMAP");
-  else if (GDK_SELECTION_TYPE_WINDOW == atom) return g_strdup ("WINDOW");
-  else if (GDK_SELECTION_TYPE_STRING == atom) return g_strdup ("STRING");
-  
-  win32_atom = GPOINTER_TO_UINT (atom);
-  
-  if (win32_atom < 0xC000)
-    return g_strdup_printf ("#%p", atom);
-  else if (GlobalGetAtomName (win32_atom, name, sizeof (name)) == 0)
-    return NULL;
-  return g_strdup (name);
-}
-
-gint
-gdk_property_get (GdkWindow   *window,
-		  GdkAtom      property,
-		  GdkAtom      type,
-		  gulong       offset,
-		  gulong       length,
-		  gint         pdelete,
-		  GdkAtom     *actual_property_type,
-		  gint        *actual_format_type,
-		  gint        *actual_length,
-		  guchar     **data)
-{
-  g_return_val_if_fail (window != NULL, FALSE);
-  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return FALSE;
-
-  g_warning ("gdk_property_get: Not implemented");
-
-  return FALSE;
-}
-
-void
-gdk_property_change (GdkWindow    *window,
-		     GdkAtom       property,
-		     GdkAtom       type,
-		     gint          format,
-		     GdkPropMode   mode,
-		     const guchar *data,
-		     gint          nelements)
-{
-  HGLOBAL hdata;
-  gint i, size;
-  guchar *ucptr;
-  wchar_t *wcptr, *p;
-  glong wclen;
-  GError *err = NULL;
-
-  g_return_if_fail (window != NULL);
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (DND, {
-      gchar *prop_name = gdk_atom_name (property);
-      gchar *type_name = gdk_atom_name (type);
-      
-      g_print ("gdk_property_change: %p %s %s %s %d*%d bits: %s\n",
-	       GDK_WINDOW_HWND (window),
-	       prop_name,
-	       type_name,
-	       (mode == GDK_PROP_MODE_REPLACE ? "REPLACE" :
-		(mode == GDK_PROP_MODE_PREPEND ? "PREPEND" :
-		 (mode == GDK_PROP_MODE_APPEND ? "APPEND" :
-		  "???"))),
-	       format, nelements,
-	       _gdk_win32_data_to_string (data, MIN (10, format*nelements/8)));
-      g_free (prop_name);
-      g_free (type_name);
-    });
-
-  /* We should never come here for these types */
-  g_return_if_fail (type != GDK_TARGET_STRING);
-  g_return_if_fail (type != _text);
-  g_return_if_fail (type != _compound_text);
-  g_return_if_fail (type != _save_targets);
-
-  if (property == _gdk_selection &&
-      format == 8 &&
-      mode == GDK_PROP_MODE_REPLACE)
-    {
-      if (type == _image_bmp && nelements < sizeof (BITMAPFILEHEADER))
-        {
-           g_warning ("Clipboard contains invalid bitmap data");
-           return;
-        }
-
-      if (type == _utf8_string)
-	{
-	  if (!OpenClipboard (GDK_WINDOW_HWND (window)))
-	    {
-	      WIN32_API_FAILED ("OpenClipboard");
-	      return;
-	    }
-
-	  wcptr = g_utf8_to_utf16 ((char *) data, nelements, NULL, &wclen, &err);
-          if (err != NULL)
-            {
-              g_warning ("Failed to convert utf8: %s", err->message);
-              g_clear_error (&err);
-              return;
-            }
-
-	  wclen++;		/* Terminating 0 */
-	  size = wclen * 2;
-	  for (i = 0; i < wclen; i++)
-	    if (wcptr[i] == '\n' && (i == 0 || wcptr[i - 1] != '\r'))
-	      size += 2;
-	  
-	  if (!(hdata = GlobalAlloc (GMEM_MOVEABLE, size)))
-	    {
-	      WIN32_API_FAILED ("GlobalAlloc");
-	      if (!CloseClipboard ())
-		WIN32_API_FAILED ("CloseClipboard");
-	      g_free (wcptr);
-	      return;
-	    }
-
-	  ucptr = GlobalLock (hdata);
-
-	  p = (wchar_t *) ucptr;
-	  for (i = 0; i < wclen; i++)
-	    {
-	      if (wcptr[i] == '\n' && (i == 0 || wcptr[i - 1] != '\r'))
-		*p++ = '\r';
-	      *p++ = wcptr[i];
-	    }
-	  g_free (wcptr);
-
-	  GlobalUnlock (hdata);
-	  GDK_NOTE (DND, g_print ("... SetClipboardData(CF_UNICODETEXT,%p)\n",
-				  hdata));
-	  if (!SetClipboardData (CF_UNICODETEXT, hdata))
-	    WIN32_API_FAILED ("SetClipboardData");
-      
-	  if (!CloseClipboard ())
-	    WIN32_API_FAILED ("CloseClipboard");
-	}
-      else
-        {
-	  /* We use delayed rendering for everything else than
-	   * text. We can't assign hdata to the clipboard here as type
-	   * may be "image/png", "image/jpg", etc. In this case
-	   * there's a further conversion afterwards.
-	   */
-	  GDK_NOTE (DND, g_print ("... delayed rendering\n"));
-	  _delayed_rendering_data = NULL;
-	  if (!(hdata = GlobalAlloc (GMEM_MOVEABLE, nelements > 0 ? nelements : 1)))
-	    {
-	      WIN32_API_FAILED ("GlobalAlloc");
-	      return;
-	    }
-	  ucptr = GlobalLock (hdata);
-	  memcpy (ucptr, data, nelements);
-	  GlobalUnlock (hdata);
-	  _delayed_rendering_data = hdata;
-	}
-    }
-  else if (property == _gdk_ole2_dnd)
-    {
-      /* Will happen only if gdkdnd-win32.c has OLE2 dnd support compiled in */
-      _gdk_win32_ole2_dnd_property_change (type, format, data, nelements);
-    }
-  else
-    g_warning ("gdk_property_change: General case not implemented");
-}
-
-void
-gdk_property_delete (GdkWindow *window,
-		     GdkAtom    property)
-{
-  gchar *prop_name;
-
-  g_return_if_fail (window != NULL);
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  GDK_NOTE (DND, {
-      prop_name = gdk_atom_name (property);
-
-      g_print ("gdk_property_delete: %p %s\n",
-	       GDK_WINDOW_HWND (window),
-	       prop_name);
-      g_free (prop_name);
-    });
-
-  if (property == _gdk_selection)
-    _gdk_selection_property_delete (window);
-  else if (property == _wm_transient_for)
-    gdk_window_set_transient_for (window, _gdk_root);
-  else
-    {
-      prop_name = gdk_atom_name (property);
-      g_warning ("gdk_property_delete: General case (%s) not implemented",
-		 prop_name);
-      g_free (prop_name);
-    }
-}
-
-/*
-  For reference, from gdk/x11/gdksettings.c:
-
-  "Net/DoubleClickTime\0"     "gtk-double-click-time\0"
-  "Net/DoubleClickDistance\0" "gtk-double-click-distance\0"
-  "Net/DndDragThreshold\0"    "gtk-dnd-drag-threshold\0"
-  "Net/CursorBlink\0"         "gtk-cursor-blink\0"
-  "Net/CursorBlinkTime\0"     "gtk-cursor-blink-time\0"
-  "Net/ThemeName\0"           "gtk-theme-name\0"
-  "Net/IconThemeName\0"       "gtk-icon-theme-name\0"
-  "Gtk/CanChangeAccels\0"     "gtk-can-change-accels\0"
-  "Gtk/ColorPalette\0"        "gtk-color-palette\0"
-  "Gtk/FontName\0"            "gtk-font-name\0"
-  "Gtk/IconSizes\0"           "gtk-icon-sizes\0"
-  "Gtk/KeyThemeName\0"        "gtk-key-theme-name\0"
-  "Gtk/ToolbarStyle\0"        "gtk-toolbar-style\0"
-  "Gtk/ToolbarIconSize\0"     "gtk-toolbar-icon-size\0"
-  "Gtk/IMPreeditStyle\0"      "gtk-im-preedit-style\0"
-  "Gtk/IMStatusStyle\0"       "gtk-im-status-style\0"
-  "Gtk/Modules\0"             "gtk-modules\0"
-  "Gtk/FileChooserBackend\0"  "gtk-file-chooser-backend\0"
-  "Gtk/ButtonImages\0"        "gtk-button-images\0"
-  "Gtk/MenuImages\0"          "gtk-menu-images\0"
-  "Gtk/MenuBarAccel\0"        "gtk-menu-bar-accel\0"
-  "Gtk/CursorBlinkTimeout\0"  "gtk-cursor-blink-timeout\0"
-  "Gtk/CursorThemeName\0"     "gtk-cursor-theme-name\0"
-  "Gtk/CursorThemeSize\0"     "gtk-cursor-theme-size\0"
-  "Gtk/ShowInputMethodMenu\0" "gtk-show-input-method-menu\0"
-  "Gtk/ShowUnicodeMenu\0"     "gtk-show-unicode-menu\0"
-  "Gtk/TimeoutInitial\0"      "gtk-timeout-initial\0"
-  "Gtk/TimeoutRepeat\0"       "gtk-timeout-repeat\0"
-  "Gtk/ColorScheme\0"         "gtk-color-scheme\0"
-  "Gtk/EnableAnimations\0"    "gtk-enable-animations\0"
-  "Xft/Antialias\0"           "gtk-xft-antialias\0"
-  "Xft/Hinting\0"             "gtk-xft-hinting\0"
-  "Xft/HintStyle\0"           "gtk-xft-hintstyle\0"
-  "Xft/RGBA\0"                "gtk-xft-rgba\0"
-  "Xft/DPI\0"                 "gtk-xft-dpi\0"
-  "Net/FallbackIconTheme\0"   "gtk-fallback-icon-theme\0"
-  "Gtk/TouchscreenMode\0"     "gtk-touchscreen-mode\0"
-  "Gtk/EnableAccels\0"        "gtk-enable-accels\0"
-  "Gtk/EnableMnemonics\0"     "gtk-enable-mnemonics\0"
-  "Gtk/ScrolledWindowPlacement\0" "gtk-scrolled-window-placement\0"
-  "Gtk/IMModule\0"            "gtk-im-module\0"
-  "Fontconfig/Timestamp\0"    "gtk-fontconfig-timestamp\0"
-  "Net/SoundThemeName\0"      "gtk-sound-theme-name\0"
-  "Net/EnableInputFeedbackSounds\0" "gtk-enable-input-feedback-sounds\0"
-  "Net/EnableEventSounds\0"  "gtk-enable-event-sounds\0";
-
-  More, from various places in gtk sources:
-
-  gtk-entry-select-on-focus
-  gtk-split-cursor
-
-*/
-gboolean
-gdk_screen_get_setting (GdkScreen   *screen,
-                        const gchar *name,
-                        GValue      *value)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
-
-  /*
-   * XXX : if these values get changed through the Windoze UI the
-   *       respective gdk_events are not generated yet.
-   */
-  if (strcmp ("gtk-theme-name", name) == 0) 
-    {
-      g_value_set_string (value, "ms-windows");
-    }
-  else if (strcmp ("gtk-double-click-time", name) == 0)
-    {
-      gint i = GetDoubleClickTime ();
-      GDK_NOTE(MISC, g_print("gdk_screen_get_setting(\"%s\") : %d\n", name, i));
-      g_value_set_int (value, i);
-      return TRUE;
-    }
-  else if (strcmp ("gtk-double-click-distance", name) == 0)
-    {
-      gint i = MAX(GetSystemMetrics (SM_CXDOUBLECLK), GetSystemMetrics (SM_CYDOUBLECLK));
-      GDK_NOTE(MISC, g_print("gdk_screen_get_setting(\"%s\") : %d\n", name, i));
-      g_value_set_int (value, i);
-      return TRUE;
-    }
-  else if (strcmp ("gtk-dnd-drag-threshold", name) == 0)
-    {
-      gint i = MAX(GetSystemMetrics (SM_CXDRAG), GetSystemMetrics (SM_CYDRAG));
-      GDK_NOTE(MISC, g_print("gdk_screen_get_setting(\"%s\") : %d\n", name, i));
-      g_value_set_int (value, i);
-      return TRUE;
-    }
-  else if (strcmp ("gtk-split-cursor", name) == 0)
-    {
-      GDK_NOTE(MISC, g_print("gdk_screen_get_setting(\"%s\") : FALSE\n", name));
-      g_value_set_boolean (value, FALSE);
-      return TRUE;
-    }
-  else if (strcmp ("gtk-alternative-button-order", name) == 0)
-    {
-      GDK_NOTE(MISC, g_print("gdk_screen_get_setting(\"%s\") : TRUE\n", name));
-      g_value_set_boolean (value, TRUE);
-      return TRUE;
-    }
-  else if (strcmp ("gtk-alternative-sort-arrows", name) == 0)
-    {
-      GDK_NOTE(MISC, g_print("gdk_screen_get_setting(\"%s\") : TRUE\n", name));
-      g_value_set_boolean (value, TRUE);
-      return TRUE;
-    }
-#if 0
-  /*
-   * With 'MS Sans Serif' as windows menu font (default on win98se) you'll get a 
-   * bunch of :
-   *   WARNING **: Couldn't load font "MS Sans Serif 8" falling back to "Sans 8"
-   * at least with testfilechooser (regardless of the bitmap check below)
-   * so just disabling this code seems to be the best we can do --hb
-   */
-  else if (strcmp ("gtk-font-name", name) == 0)
-    {
-      NONCLIENTMETRICS ncm;
-      ncm.cbSize = sizeof(NONCLIENTMETRICS);
-      if (SystemParametersInfo (SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, FALSE))
-        {
-          /* Pango finally uses GetDeviceCaps to scale, we use simple
-	   * approximation here.
-	   */
-          int nHeight = (0 > ncm.lfMenuFont.lfHeight ? -3*ncm.lfMenuFont.lfHeight/4 : 10);
-          if (OUT_STRING_PRECIS == ncm.lfMenuFont.lfOutPrecision)
-            GDK_NOTE(MISC, g_print("gdk_screen_get_setting(%s) : ignoring bitmap font '%s'\n", 
-                                   name, ncm.lfMenuFont.lfFaceName));
-          else if (ncm.lfMenuFont.lfFaceName && strlen(ncm.lfMenuFont.lfFaceName) > 0 &&
-                   /* Avoid issues like those described in bug #135098 */
-                   g_utf8_validate (ncm.lfMenuFont.lfFaceName, -1, NULL))
-            {
-              char* s = g_strdup_printf ("%s %d", ncm.lfMenuFont.lfFaceName, nHeight);
-              GDK_NOTE(MISC, g_print("gdk_screen_get_setting(%s) : %s\n", name, s));
-              g_value_set_string (value, s);
-
-              g_free(s);
-              return TRUE;
-            }
-        }
-    }
-#endif
-
-  return FALSE;
-}
diff --git a/gdk/win32/gdkscreen-win32.c b/gdk/win32/gdkscreen-win32.c
deleted file mode 100644
index e9051b5..0000000
--- a/gdk/win32/gdkscreen-win32.c
+++ /dev/null
@@ -1,184 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 2002 Hans Breuer
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include "gdk.h"
-#include "gdkprivate-win32.h"
-
-static GdkColormap *default_colormap = NULL;
-
-GdkDisplay *
-gdk_screen_get_display (GdkScreen *screen)
-{
-  return _gdk_display;
-}
-
-GdkWindow *
-gdk_screen_get_root_window (GdkScreen *screen)
-{
-  return _gdk_root;
-}
-
-GdkColormap *
-gdk_screen_get_default_colormap (GdkScreen *screen)
-{
-  return default_colormap;
-}
-
-void
-gdk_screen_set_default_colormap (GdkScreen   *screen,
-				 GdkColormap *colormap)
-{
-  GdkColormap *old_colormap;
-  
-  g_return_if_fail (screen == _gdk_screen);
-  g_return_if_fail (GDK_IS_COLORMAP (colormap));
-
-  old_colormap = default_colormap;
-
-  default_colormap = g_object_ref (colormap);
-  
-  if (old_colormap)
-    g_object_unref (old_colormap);
-}
-
-gint
-gdk_screen_get_n_monitors (GdkScreen *screen)
-{
-  g_return_val_if_fail (screen == _gdk_screen, 0);
-
-  return _gdk_num_monitors;
-}
-
-gint
-gdk_screen_get_primary_monitor (GdkScreen *screen)
-{
-  g_return_val_if_fail (screen == _gdk_screen, 0);
-
-  return 0;
-}
-
-gint
-gdk_screen_get_monitor_width_mm (GdkScreen *screen,
-                                 gint       num_monitor)
-{
-  g_return_val_if_fail (screen == _gdk_screen, 0);
-  g_return_val_if_fail (num_monitor < _gdk_num_monitors, 0);
-  g_return_val_if_fail (num_monitor >= 0, 0);
-
-  return _gdk_monitors[num_monitor].width_mm;
-}
-
-gint
-gdk_screen_get_monitor_height_mm (GdkScreen *screen,
-                                  gint       num_monitor)
-{
-  g_return_val_if_fail (screen == _gdk_screen, 0);
-  g_return_val_if_fail (num_monitor < _gdk_num_monitors, 0);
-  g_return_val_if_fail (num_monitor >= 0, 0);
-
-  return _gdk_monitors[num_monitor].height_mm;
-}
-
-gchar *
-gdk_screen_get_monitor_plug_name (GdkScreen *screen,
-                                  gint       num_monitor)
-{
-  g_return_val_if_fail (screen == _gdk_screen, 0);
-  g_return_val_if_fail (num_monitor < _gdk_num_monitors, 0);
-  g_return_val_if_fail (num_monitor >= 0, 0);
-
-  return g_strdup (_gdk_monitors[num_monitor].name);
-}
-
-void
-gdk_screen_get_monitor_geometry (GdkScreen    *screen, 
-				 gint          num_monitor,
-				 GdkRectangle *dest)
-{
-  g_return_if_fail (screen == _gdk_screen);
-  g_return_if_fail (num_monitor < _gdk_num_monitors);
-  g_return_if_fail (num_monitor >= 0);
-
-  *dest = _gdk_monitors[num_monitor].rect;
-}
-
-GdkColormap *
-gdk_screen_get_rgba_colormap (GdkScreen *screen)
-{
-  g_return_val_if_fail (screen == _gdk_screen, NULL);
-
-  return NULL;
-}
-  
-GdkVisual *
-gdk_screen_get_rgba_visual (GdkScreen *screen)
-{
-  g_return_val_if_fail (screen == _gdk_screen, NULL);
-
-  return NULL;
-}
-  
-gint
-gdk_screen_get_number (GdkScreen *screen)
-{
-  g_return_val_if_fail (screen == _gdk_screen, 0);  
-  
-  return 0;
-}
-
-gchar * 
-_gdk_windowing_substitute_screen_number (const gchar *display_name,
-					 int          screen_number)
-{
-  if (screen_number != 0)
-    return NULL;
-
-  return g_strdup (display_name);
-}
-
-gchar *
-gdk_screen_make_display_name (GdkScreen *screen)
-{
-  return g_strdup (gdk_display_get_name (_gdk_display));
-}
-
-GdkWindow *
-gdk_screen_get_active_window (GdkScreen *screen)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
-
-  return NULL;
-}
-
-GList *
-gdk_screen_get_window_stack (GdkScreen *screen)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
-
-  return NULL;
-}
-
-gboolean
-gdk_screen_is_composited (GdkScreen *screen)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
-
-  return FALSE;
-}
diff --git a/gdk/win32/gdkselection-win32.c b/gdk/win32/gdkselection-win32.c
deleted file mode 100644
index 0553b98..0000000
--- a/gdk/win32/gdkselection-win32.c
+++ /dev/null
@@ -1,1311 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <string.h>
-#include <stdlib.h>
-
-#include "gdkproperty.h"
-#include "gdkselection.h"
-#include "gdkdisplay.h"
-#include "gdkprivate-win32.h"
-
-/* We emulate the GDK_SELECTION window properties of windows (as used
- * in the X11 backend) by using a hash table from window handles to
- * GdkSelProp structs.
- */
-
-typedef struct {
-  guchar *data;
-  gsize length;
-  gint format;
-  GdkAtom type;
-} GdkSelProp;
-
-static GHashTable *sel_prop_table = NULL;
-
-static GdkSelProp *dropfiles_prop = NULL;
-
-/* We store the owner of each selection in this table. Obviously, this only
- * is valid intra-app, and in fact it is necessary for the intra-app DND to work.
- */
-static GHashTable *sel_owner_table = NULL;
-
-/* GdkAtoms for well-known image formats */
-static GdkAtom *known_pixbuf_formats;
-static int n_known_pixbuf_formats;
-
-/* GdkAtoms for well-known text formats */
-static GdkAtom text_plain;
-static GdkAtom text_plain_charset_utf_8;
-static GdkAtom text_plain_charset_CP1252;
-
-void
-_gdk_win32_selection_init (void)
-{
-  GSList *pixbuf_formats;
-  GSList *rover;
-
-  sel_prop_table = g_hash_table_new (NULL, NULL);
-  sel_owner_table = g_hash_table_new (NULL, NULL);
-  _format_atom_table = g_hash_table_new (NULL, NULL);
-
-  pixbuf_formats = gdk_pixbuf_get_formats ();
-
-  n_known_pixbuf_formats = 0;
-  for (rover = pixbuf_formats; rover != NULL; rover = rover->next)
-    {
-      gchar **mime_types =
-	gdk_pixbuf_format_get_mime_types ((GdkPixbufFormat *) rover->data);
-
-      gchar **mime_type;
-
-      for (mime_type = mime_types; *mime_type != NULL; mime_type++)
-	n_known_pixbuf_formats++;
-    }
-
-  known_pixbuf_formats = g_new (GdkAtom, n_known_pixbuf_formats);
-
-  n_known_pixbuf_formats = 0;
-  for (rover = pixbuf_formats; rover != NULL; rover = rover->next)
-    {
-      gchar **mime_types =
-	gdk_pixbuf_format_get_mime_types ((GdkPixbufFormat *) rover->data);
-
-      gchar **mime_type;
-
-      for (mime_type = mime_types; *mime_type != NULL; mime_type++)
-	known_pixbuf_formats[n_known_pixbuf_formats++] = gdk_atom_intern (*mime_type, FALSE);
-    }
-
-  g_slist_free (pixbuf_formats);
-  
-  text_plain = gdk_atom_intern ("text/plain", FALSE);
-  text_plain_charset_utf_8= gdk_atom_intern ("text/plain;charset=utf-8", FALSE);
-  text_plain_charset_CP1252 = gdk_atom_intern ("text/plain;charset=CP1252", FALSE);
-
-  g_hash_table_replace (_format_atom_table,
-			GINT_TO_POINTER (_cf_png),
-			_image_png);
-
-  g_hash_table_replace (_format_atom_table,
-			GINT_TO_POINTER (CF_DIB),
-			_image_bmp);
-}
-
-/* The specifications for COMPOUND_TEXT and STRING specify that C0 and
- * C1 are not allowed except for \n and \t, however the X conversions
- * routines for COMPOUND_TEXT only enforce this in one direction,
- * causing cut-and-paste of \r and \r\n separated text to fail.
- * This routine strips out all non-allowed C0 and C1 characters
- * from the input string and also canonicalizes \r, and \r\n to \n
- */
-static gchar * 
-sanitize_utf8 (const gchar *src,
-	       gint         length)
-{
-  GString *result = g_string_sized_new (length + 1);
-  const gchar *p = src;
-  const gchar *endp = src + length;
-
-  while (p < endp)
-    {
-      if (*p == '\r')
-	{
-	  p++;
-	  if (*p == '\n')
-	    p++;
-
-	  g_string_append_c (result, '\n');
-	}
-      else
-	{
-	  gunichar ch = g_utf8_get_char (p);
-	  char buf[7];
-	  gint buflen;
-	  
-	  if (!((ch < 0x20 && ch != '\t' && ch != '\n') || (ch >= 0x7f && ch < 0xa0)))
-	    {
-	      buflen = g_unichar_to_utf8 (ch, buf);
-	      g_string_append_len (result, buf, buflen);
-	    }
-
-	  p = g_utf8_next_char (p);
-	}
-    }
-  g_string_append_c (result, '\0');
-
-  return g_string_free (result, FALSE);
-}
-
-static gchar *
-_gdk_utf8_to_string_target_internal (const gchar *str,
-				     gint         length)
-{
-  GError *error = NULL;
-  
-  gchar *tmp_str = sanitize_utf8 (str, length);
-  gchar *result =  g_convert_with_fallback (tmp_str, -1,
-					    "ISO-8859-1", "UTF-8",
-					    NULL, NULL, NULL, &error);
-  if (!result)
-    {
-      g_warning ("Error converting from UTF-8 to STRING: %s",
-		 error->message);
-      g_error_free (error);
-    }
-  
-  g_free (tmp_str);
-  return result;
-}
-
-static void
-selection_property_store (GdkWindow *owner,
-			  GdkAtom    type,
-			  gint       format,
-			  guchar    *data,
-			  gint       length)
-{
-  GdkSelProp *prop;
-
-  g_return_if_fail (type != GDK_TARGET_STRING);
-
-  prop = g_hash_table_lookup (sel_prop_table, GDK_WINDOW_HWND (owner));
-
-  if (prop != NULL)
-    {
-      g_free (prop->data);
-      g_free (prop);
-      g_hash_table_remove (sel_prop_table, GDK_WINDOW_HWND (owner));
-    }
-
-  prop = g_new (GdkSelProp, 1);
-
-  prop->data = data;
-  prop->length = length;
-  prop->format = format;
-  prop->type = type;
-
-  g_hash_table_insert (sel_prop_table, GDK_WINDOW_HWND (owner), prop);
-}
-
-void
-_gdk_dropfiles_store (gchar *data)
-{
-  if (data != NULL)
-    {
-      g_assert (dropfiles_prop == NULL);
-
-      dropfiles_prop = g_new (GdkSelProp, 1);
-      dropfiles_prop->data = (guchar *) data;
-      dropfiles_prop->length = strlen (data) + 1;
-      dropfiles_prop->format = 8;
-      dropfiles_prop->type = _text_uri_list;
-    }
-  else
-    {
-      if (dropfiles_prop != NULL)
-	{
-	  g_free (dropfiles_prop->data);
-	  g_free (dropfiles_prop);
-	}
-      dropfiles_prop = NULL;
-    }
-}
-
-static gchar *
-get_mapped_gdk_atom_name (GdkAtom gdk_target)
-{
-  if (gdk_target == _image_png)
-    return g_strdup ("PNG");
-
-  if (gdk_target == _image_jpeg)
-    return g_strdup ("JFIF");
-  
-  if (gdk_target == _image_gif)
-    return g_strdup ("GIF");
-  
-  return gdk_atom_name (gdk_target);
-}
-
-gboolean
-gdk_selection_owner_set_for_display (GdkDisplay *display,
-                                     GdkWindow  *owner,
-                                     GdkAtom     selection,
-                                     guint32     time,
-                                     gboolean    send_event)
-{
-  HWND hwnd;
-  GdkEvent tmp_event;
-
-  g_return_val_if_fail (display == _gdk_display, FALSE);
-  g_return_val_if_fail (selection != GDK_NONE, FALSE);
-
-  GDK_NOTE (DND, {
-      gchar *sel_name = gdk_atom_name (selection);
-
-      g_print ("gdk_selection_owner_set_for_display: %p %s\n",
-	       (owner ? GDK_WINDOW_HWND (owner) : NULL),
-	       sel_name);
-      g_free (sel_name);
-    });
-
-  if (selection != GDK_SELECTION_CLIPBOARD)
-    {
-      if (owner != NULL)
-	g_hash_table_insert (sel_owner_table, selection, GDK_WINDOW_HWND (owner));
-      else
-	g_hash_table_remove (sel_owner_table, selection);
-      return TRUE;
-    }
-
-  /* Rest of this function handles the CLIPBOARD selection */
-  if (owner != NULL)
-    {
-      if (GDK_WINDOW_DESTROYED (owner))
-	return FALSE;
-
-      hwnd = GDK_WINDOW_HWND (owner);
-    }
-  else
-    hwnd = NULL;
-
-  if (!API_CALL (OpenClipboard, (hwnd)))
-    return FALSE;
-
-  _ignore_destroy_clipboard = TRUE;
-  GDK_NOTE (DND, g_print ("... EmptyClipboard()\n"));
-  if (!API_CALL (EmptyClipboard, ()))
-    {
-      _ignore_destroy_clipboard = FALSE;
-      API_CALL (CloseClipboard, ());
-      return FALSE;
-    }
-  _ignore_destroy_clipboard = FALSE;
-
-  if (!API_CALL (CloseClipboard, ()))
-    return FALSE;
-
-  if (owner != NULL)
-    {
-      /* Send ourselves a selection request message so that
-       * gdk_property_change will be called to store the clipboard
-       * data.
-       */
-      GDK_NOTE (DND, g_print ("... sending GDK_SELECTION_REQUEST to ourselves\n"));
-      tmp_event.selection.type = GDK_SELECTION_REQUEST;
-      tmp_event.selection.window = owner;
-      tmp_event.selection.send_event = FALSE;
-      tmp_event.selection.selection = selection;
-      tmp_event.selection.target = _utf8_string;
-      tmp_event.selection.property = _gdk_selection;
-      tmp_event.selection.requestor = hwnd;
-      tmp_event.selection.time = time;
-
-      gdk_event_put (&tmp_event);
-    }
-
-  return TRUE;
-}
-
-GdkWindow*
-gdk_selection_owner_get_for_display (GdkDisplay *display,
-                                     GdkAtom     selection)
-{
-  GdkWindow *window;
-
-  g_return_val_if_fail (display == _gdk_display, NULL);
-  g_return_val_if_fail (selection != GDK_NONE, NULL);
-
-  if (selection == GDK_SELECTION_CLIPBOARD)
-    {
-      HWND owner = GetClipboardOwner ();
-
-      if (owner == NULL)
-	return NULL;
-
-      return gdk_win32_handle_table_lookup ((GdkNativeWindow) owner);
-    }
-
-  window = gdk_window_lookup ((GdkNativeWindow) g_hash_table_lookup (sel_owner_table, selection));
-
-  GDK_NOTE (DND, {
-      gchar *sel_name = gdk_atom_name (selection);
-      
-      g_print ("gdk_selection_owner_get: %s = %p\n",
-	       sel_name,
-	       (window ? GDK_WINDOW_HWND (window) : NULL));
-      g_free (sel_name);
-    });
-
-  return window;
-}
-
-static void
-generate_selection_notify (GdkWindow *requestor,
-			   GdkAtom    selection,
-			   GdkAtom    target,
-			   GdkAtom    property,
-			   guint32    time)
-{
-  GdkEvent tmp_event;
-
-  tmp_event.selection.type = GDK_SELECTION_NOTIFY;
-  tmp_event.selection.window = requestor;
-  tmp_event.selection.send_event = FALSE;
-  tmp_event.selection.selection = selection;
-  tmp_event.selection.target = target;
-  tmp_event.selection.property = property;
-  tmp_event.selection.requestor = 0;
-  tmp_event.selection.time = time;
-
-  gdk_event_put (&tmp_event);
-}
-
-void
-gdk_selection_convert (GdkWindow *requestor,
-		       GdkAtom    selection,
-		       GdkAtom    target,
-		       guint32    time)
-{
-  HGLOBAL hdata;
-  GdkAtom property = _gdk_selection;
-
-  g_return_if_fail (selection != GDK_NONE);
-  g_return_if_fail (requestor != NULL);
-
-  if (GDK_WINDOW_DESTROYED (requestor))
-    return;
-
-  GDK_NOTE (DND, {
-      gchar *sel_name = gdk_atom_name (selection);
-      gchar *tgt_name = gdk_atom_name (target);
-      
-      g_print ("gdk_selection_convert: %p %s %s\n",
-	       GDK_WINDOW_HWND (requestor),
-	       sel_name, tgt_name);
-      g_free (sel_name);
-      g_free (tgt_name);
-    });
-
-  if (selection == GDK_SELECTION_CLIPBOARD && target == _targets)
-    {
-      gint ntargets, fmt;
-      GdkAtom *targets;
-      gboolean has_text = FALSE;
-      gboolean has_png = FALSE;
-      gboolean has_bmp = FALSE;
-
-      if (!API_CALL (OpenClipboard, (GDK_WINDOW_HWND (requestor))))
-	return;
-
-      targets = g_new (GdkAtom, CountClipboardFormats ());
-      ntargets = 0;
-
-      for (fmt = 0; 0 != (fmt = EnumClipboardFormats (fmt)); )
-	{
-	  if (fmt == _cf_png)
-	    {
-	      targets[ntargets++] = _image_png;
-	      has_png = TRUE;
-	    }
-	}
-
-      for (fmt = 0; 0 != (fmt = EnumClipboardFormats (fmt)); )
-	{
-	  gchar sFormat[80];
-
-	  if (fmt == CF_UNICODETEXT || fmt == CF_TEXT)
-	    {
-	      /* Advertise text to GDK always as UTF8_STRING */
-	      if (!has_text)
-		targets[ntargets++] = _utf8_string;
-	      has_text = TRUE;
-	    }
-	  else if (fmt == _cf_png)
-	    {
-	      /* Already handled above */
-	    }
-	  else if (fmt == CF_DIB ||
-		   fmt == CF_DIBV5)
-	    {
-	      /* Don't bother telling that a bitmap is present if there is
-	       * also PNG, which is much more reliable in transferring
-	       * transparency.
-	       */
-	      if (!has_bmp && !has_png)
-		targets[ntargets++] = _image_bmp;
-	      has_bmp = TRUE;
-	    }
-	  else if (fmt == _cf_jfif)
-	    {
-	      /* Ditto for JPEG */
-	      if (!has_png)
-		targets[ntargets++] = _image_jpeg;
-	    }
-	  else if (fmt == _cf_gif)
-	    {
-	      /* Ditto for GIF.
-	       */
-	      if (!has_png)
-		targets[ntargets++] = _image_gif;
-	    }
-	  else if (GetClipboardFormatName (fmt, sFormat, 80) > 0)
-	    {
-	      if (strcmp (sFormat, "image/bmp") == 0 ||
-		  strcmp (sFormat, "image/x-bmp") == 0 ||
-		  strcmp (sFormat, "image/x-MS-bmp") == 0 ||
-		  strcmp (sFormat, "image/x-icon") == 0 ||
-		  strcmp (sFormat, "image/x-ico") == 0 ||
-		  strcmp (sFormat, "image/x-win-bitmap") == 0)
-		{
-		  /* Ignore these (from older GTK+ versions
-		   * presumably), as the same image in the CF_DIB
-		   * format will also be on the clipboard anyway.
-		   */
-		}
-	      else
-		targets[ntargets++] = gdk_atom_intern (sFormat, FALSE);
-            }
-        }
-
-      GDK_NOTE (DND, {
-	  int i;
-	  
-	  g_print ("... ");
-	  for (i = 0; i < ntargets; i++)
-	    {
-	      gchar *atom_name = gdk_atom_name (targets[i]);
-
-	      g_print ("%s", atom_name);
-	      g_free (atom_name);
-	      if (i < ntargets - 1)
-		g_print (", ");
-	    }
-	  g_print ("\n");
-	});
-
-      if (ntargets > 0)
-	selection_property_store (requestor, GDK_SELECTION_TYPE_ATOM,
-				  32, (guchar *) targets,
-				  ntargets * sizeof (GdkAtom));
-      else
-	property = GDK_NONE;
-
-      API_CALL (CloseClipboard, ());
-    }
-  else if (selection == GDK_SELECTION_CLIPBOARD && target == _utf8_string)
-    {
-      /* Converting the CLIPBOARD selection means he wants the
-       * contents of the clipboard. Get the clipboard data, and store
-       * it for later.
-       */
-      if (!API_CALL (OpenClipboard, (GDK_WINDOW_HWND (requestor))))
-	return;
-
-      if ((hdata = GetClipboardData (CF_UNICODETEXT)) != NULL)
-	{
-	  wchar_t *ptr, *p, *q;
-	  guchar *data;
-	  glong length, wclen;
-
-	  if ((ptr = GlobalLock (hdata)) != NULL)
-	    {
-	      length = GlobalSize (hdata);
-
-	      GDK_NOTE (DND, g_print ("... CF_UNICODETEXT: %ld bytes\n",
-				      length));
-
-	      /* Strip out \r */
-	      p = ptr;
-	      q = ptr;
-	      wclen = 0;
-	      while (p < ptr + length / 2)
-		{
-		  if (*p != '\r')
-		    {
-		      *q++ = *p;
-		      wclen++;
-		    }
-		  p++;
-		}
-
-	      data = g_utf16_to_utf8 (ptr, wclen, NULL, NULL, NULL);
-
-	      if (data)
-		selection_property_store (requestor, _utf8_string, 8,
-					  data, strlen (data) + 1);
-	      GlobalUnlock (hdata);
-	    }
-	}
-      else
-	property = GDK_NONE;
-
-      API_CALL (CloseClipboard, ());
-    }
-  else if (selection == GDK_SELECTION_CLIPBOARD && target == _image_bmp)
-    {
-      if (!API_CALL (OpenClipboard, (GDK_WINDOW_HWND (requestor))))
-	return;
-
-      if ((hdata = GetClipboardData (CF_DIB)) != NULL)
-        {
-          BITMAPINFOHEADER *bi;
-
-          if ((bi = GlobalLock (hdata)) != NULL)
-            {
-	      /* Need to add a BMP file header so gdk-pixbuf can load
-	       * it.
-	       *
-	       * If the data is from Mozilla Firefox or IE7, and
-	       * starts with an "old fashioned" BITMAPINFOHEADER,
-	       * i.e. with biSize==40, and biCompression == BI_RGB and
-	       * biBitCount==32, we assume that the "extra" byte in
-	       * each pixel in fact is alpha.
-	       *
-	       * The gdk-pixbuf bmp loader doesn't trust 32-bit BI_RGB
-	       * bitmaps to in fact have alpha, so we have to convince
-	       * it by changing the bitmap header to a version 5
-	       * BI_BITFIELDS one with explicit alpha mask indicated.
-	       *
-	       * The RGB bytes that are in bitmaps on the clipboard
-	       * originating from Firefox or IE7 seem to be
-	       * premultiplied with alpha. The gdk-pixbuf bmp loader
-	       * of course doesn't expect that, so we have to undo the
-	       * premultiplication before feeding the bitmap to the
-	       * bmp loader.
-	       *
-	       * Note that for some reason the bmp loader used to want
-	       * the alpha bytes in its input to actually be
-	       * 255-alpha, but here we assume that this has been
-	       * fixed before this is committed.
-	       */
-              BITMAPFILEHEADER *bf;
-	      gpointer data;
-	      gint data_length = GlobalSize (hdata);
-	      gint new_length;
-	      gboolean make_dibv5 = FALSE;
-
-	      GDK_NOTE (DND, g_print ("... CF_DIB: %d bytes\n", data_length));
-
-	      if (bi->biSize == sizeof (BITMAPINFOHEADER) &&
-		  bi->biPlanes == 1 &&
-		  bi->biBitCount == 32 &&
-		  bi->biCompression == BI_RGB &&
-#if 0
-		  /* Maybe check explicitly for Mozilla or IE7?
-		   *
-		   * If the clipboard format
-		   * application/x-moz-nativeimage is present, that is
-		   * a reliable indicator that the data is offered by
-		   * Mozilla one would think. For IE7,
-		   * UniformResourceLocatorW is presumably not that
-		   * uniqie, so probably need to do some
-		   * GetClipboardOwner(), GetWindowThreadProcessId(),
-		   * OpenProcess(), GetModuleFileNameEx() dance to
-		   * check?
-		   */
-		  (IsClipboardFormatAvailable
-		   (RegisterClipboardFormat ("application/x-moz-nativeimage")) ||
-		   IsClipboardFormatAvailable
-		   (RegisterClipboardFormat ("UniformResourceLocatorW"))) &&
-#endif
-		  TRUE)
-		{
-		  /* We turn the BITMAPINFOHEADER into a
-		   * BITMAPV5HEADER before feeding it to gdk-pixbuf.
-		   */
-		  new_length = (data_length +
-				sizeof (BITMAPFILEHEADER) +
-				(sizeof (BITMAPV5HEADER) - sizeof (BITMAPINFOHEADER)));
-		  make_dibv5 = TRUE;
-		}
-	      else
-		{
-		  new_length = data_length + sizeof (BITMAPFILEHEADER);
-		}
-	      
-              data = g_try_malloc (new_length);
-
-              if (data)
-                {
-                  bf = (BITMAPFILEHEADER *)data;
-                  bf->bfType = 0x4d42; /* "BM" */
-                  bf->bfSize = new_length;
-                  bf->bfReserved1 = 0;
-                  bf->bfReserved2 = 0;
-
-		  if (make_dibv5)
-		    {
-		      BITMAPV5HEADER *bV5 = (BITMAPV5HEADER *) ((char *) data + sizeof (BITMAPFILEHEADER));
-		      guchar *p;
-		      int i;
-
-		      bV5->bV5Size = sizeof (BITMAPV5HEADER);
-		      bV5->bV5Width = bi->biWidth;
-		      bV5->bV5Height = bi->biHeight;
-		      bV5->bV5Planes = 1;
-		      bV5->bV5BitCount = 32;
-		      bV5->bV5Compression = BI_BITFIELDS;
-		      bV5->bV5SizeImage = 4 * bV5->bV5Width * ABS (bV5->bV5Height);
-		      bV5->bV5XPelsPerMeter = bi->biXPelsPerMeter;
-		      bV5->bV5YPelsPerMeter = bi->biYPelsPerMeter;
-		      bV5->bV5ClrUsed = 0;
-		      bV5->bV5ClrImportant = 0;
-		      /* Now the added mask fields */
-		      bV5->bV5RedMask   = 0x00ff0000;
-		      bV5->bV5GreenMask = 0x0000ff00;
-		      bV5->bV5BlueMask  = 0x000000ff;
-		      bV5->bV5AlphaMask = 0xff000000;
-		      ((char *) &bV5->bV5CSType)[3] = 's';
-		      ((char *) &bV5->bV5CSType)[2] = 'R';
-		      ((char *) &bV5->bV5CSType)[1] = 'G';
-		      ((char *) &bV5->bV5CSType)[0] = 'B';
-		      /* Ignore colorspace and profile fields */
-		      bV5->bV5Intent = LCS_GM_GRAPHICS;
-		      bV5->bV5Reserved = 0;
-
-		      bf->bfOffBits = (sizeof (BITMAPFILEHEADER) +
-				       bV5->bV5Size);
-
-		      p = ((guchar *) data) + sizeof (BITMAPFILEHEADER) + sizeof (BITMAPV5HEADER);
-		      memcpy (p, ((char *) bi) + bi->biSize,
-			      data_length - sizeof (BITMAPINFOHEADER));
-
-		      for (i = 0; i < bV5->bV5SizeImage/4; i++)
-			{
-			  if (p[3] != 0)
-			    {
-			      gdouble inverse_alpha = 255./p[3];
-			      
-			      p[0] = p[0] * inverse_alpha + 0.5;
-			      p[1] = p[1] * inverse_alpha + 0.5;
-			      p[2] = p[2] * inverse_alpha + 0.5;
-			    }
-
-			  p += 4;
-			}
-		    }
-		  else
-		    {
-		      bf->bfOffBits = (sizeof (BITMAPFILEHEADER) +
-				       bi->biSize +
-				       bi->biClrUsed * sizeof (RGBQUAD));
-
-		      if (bi->biCompression == BI_BITFIELDS && bi->biBitCount >= 16)
-		        {
-                          /* Screenshots taken with PrintScreen or
-                           * Alt + PrintScreen are found on the clipboard in
-                           * this format. In this case the BITMAPINFOHEADER is
-                           * followed by three DWORD specifying the masks of the
-                           * red green and blue components, so adjust the offset
-                           * accordingly. */
-		          bf->bfOffBits += (3 * sizeof (DWORD));
-		        }
-
-		      memcpy ((char *) data + sizeof (BITMAPFILEHEADER),
-			      bi,
-			      data_length);
-		    }
-
-	          selection_property_store (requestor, _image_bmp, 8,
-					    data, new_length);
-                }
-	      GlobalUnlock (hdata);
-            }
-      }
-
-      API_CALL (CloseClipboard, ());
-    }
-  else if (selection == GDK_SELECTION_CLIPBOARD)
-    {
-      gchar *mapped_target_name;
-      UINT fmt = 0;
-
-      if (!API_CALL (OpenClipboard, (GDK_WINDOW_HWND (requestor))))
-	return;
-
-      mapped_target_name = get_mapped_gdk_atom_name (target);
-
-      /* Check if it's available. We could simply call
-       * GetClipboardData (RegisterClipboardFormat (targetname)), but
-       * the global custom format ID space is limited,
-       * (0xC000~0xFFFF), and we better not waste an format ID if we
-       * are just a requestor.
-       */
-      for ( ; 0 != (fmt = EnumClipboardFormats (fmt)); )
-        {
-          char sFormat[80];
-
-          if (GetClipboardFormatName (fmt, sFormat, 80) > 0 && 
-              strcmp (sFormat, mapped_target_name) == 0)
-            {
-              if ((hdata = GetClipboardData (fmt)) != NULL)
-	        {
-	          /* Simply get it without conversion */
-                  guchar *ptr;
-                  gint length;
-
-                  if ((ptr = GlobalLock (hdata)) != NULL)
-                    {
-                      length = GlobalSize (hdata);
-	      
-                      GDK_NOTE (DND, g_print ("... %s: %d bytes\n", mapped_target_name, length));
-	      
-                      selection_property_store (requestor, target, 8,
-						g_memdup (ptr, length), length);
-	              GlobalUnlock (hdata);
-                      break;
-                    }
-                }
-            }
-        }
-      g_free (mapped_target_name);
-      API_CALL (CloseClipboard, ());
-    }
-  else if (selection == _gdk_win32_dropfiles)
-    {
-      /* This means he wants the names of the dropped files.
-       * gdk_dropfiles_filter already has stored the text/uri-list
-       * data temporarily in dropfiles_prop.
-       */
-      if (dropfiles_prop != NULL)
-	{
-	  selection_property_store
-	    (requestor, dropfiles_prop->type, dropfiles_prop->format,
-	     dropfiles_prop->data, dropfiles_prop->length);
-	  g_free (dropfiles_prop);
-	  dropfiles_prop = NULL;
-	}
-    }
-  else
-    property = GDK_NONE;
-
-  /* Generate a selection notify message so that we actually fetch the
-   * data (if property == _gdk_selection) or indicating failure (if
-   * property == GDK_NONE).
-   */
-  generate_selection_notify (requestor, selection, target, property, time);
-}
-
-gint
-gdk_selection_property_get (GdkWindow  *requestor,
-			    guchar    **data,
-			    GdkAtom    *ret_type,
-			    gint       *ret_format)
-{
-  GdkSelProp *prop;
-
-  g_return_val_if_fail (requestor != NULL, 0);
-  g_return_val_if_fail (GDK_IS_WINDOW (requestor), 0);
-
-  if (GDK_WINDOW_DESTROYED (requestor))
-    return 0;
-  
-  GDK_NOTE (DND, g_print ("gdk_selection_property_get: %p",
-			   GDK_WINDOW_HWND (requestor)));
-
-  prop = g_hash_table_lookup (sel_prop_table, GDK_WINDOW_HWND (requestor));
-
-  if (prop == NULL)
-    {
-      GDK_NOTE (DND, g_print (" (nothing)\n"));
-      *data = NULL;
-
-      return 0;
-    }
-
-  *data = g_malloc (prop->length + 1);
-  (*data)[prop->length] = '\0';
-  if (prop->length > 0)
-    memmove (*data, prop->data, prop->length);
-
-  GDK_NOTE (DND, {
-      gchar *type_name = gdk_atom_name (prop->type);
-
-      g_print (" %s format:%d length:%d\n", type_name, prop->format, prop->length);
-      g_free (type_name);
-    });
-
-  if (ret_type)
-    *ret_type = prop->type;
-
-  if (ret_format)
-    *ret_format = prop->format;
-
-  return prop->length;
-}
-
-void
-_gdk_selection_property_delete (GdkWindow *window)
-{
-  GdkSelProp *prop;
-
-  GDK_NOTE (DND, g_print ("_gdk_selection_property_delete: %p (no-op)\n",
-			   GDK_WINDOW_HWND (window)));
-
-#if 1 /* without this we can only paste the first image from clipboard */
-  prop = g_hash_table_lookup (sel_prop_table, GDK_WINDOW_HWND (window));
-  if (prop != NULL)
-    {
-      g_free (prop->data);
-      g_free (prop);
-      g_hash_table_remove (sel_prop_table, GDK_WINDOW_HWND (window));
-    }
-#endif
-}
-
-void
-gdk_selection_send_notify_for_display (GdkDisplay      *display,
-                                       GdkNativeWindow  requestor,
-                                       GdkAtom     	selection,
-                                       GdkAtom     	target,
-                                       GdkAtom     	property,
-                                       guint32     	time)
-{
-  g_return_if_fail (display == _gdk_display);
-
-  GDK_NOTE (DND, {
-      gchar *sel_name = gdk_atom_name (selection);
-      gchar *tgt_name = gdk_atom_name (target);
-      gchar *prop_name = gdk_atom_name (property);
-      
-      g_print ("gdk_selection_send_notify_for_display: %p %s %s %s (no-op)\n",
-	       requestor, sel_name, tgt_name, prop_name);
-      g_free (sel_name);
-      g_free (tgt_name);
-      g_free (prop_name);
-    });
-}
-
-/* It's hard to say whether implementing this actually is of any use
- * on the Win32 platform? gtk calls only
- * gdk_text_property_to_utf8_list_for_display().
- */
-gint
-gdk_text_property_to_text_list_for_display (GdkDisplay   *display,
-					    GdkAtom       encoding,
-					    gint          format, 
-					    const guchar *text,
-					    gint          length,
-					    gchar      ***list)
-{
-  gchar *result;
-  const gchar *charset;
-  gchar *source_charset;
-
-  g_return_val_if_fail (display == _gdk_display, 0);
-
-  GDK_NOTE (DND, {
-      gchar *enc_name = gdk_atom_name (encoding);
-      
-      g_print ("gdk_text_property_to_text_list_for_display: %s %d %.20s %d\n",
-	       enc_name, format, text, length);
-      g_free (enc_name);
-    });
-    
-  if (!list)
-    return 0;
-
-  if (encoding == GDK_TARGET_STRING)
-    source_charset = g_strdup ("ISO-8859-1");
-  else if (encoding == _utf8_string)
-    source_charset = g_strdup ("UTF-8");
-  else
-    source_charset = gdk_atom_name (encoding);
-    
-  g_get_charset (&charset);
-
-  result = g_convert (text, length, charset, source_charset,
-		      NULL, NULL, NULL);
-  g_free (source_charset);
-
-  if (!result)
-    return 0;
-
-  *list = g_new (gchar *, 1);
-  **list = result;
-  
-  return 1;
-}
-
-void
-gdk_free_text_list (gchar **list)
-{
-  g_return_if_fail (list != NULL);
-
-  g_free (*list);
-  g_free (list);
-}
-
-static gint
-make_list (const gchar  *text,
-	   gint          length,
-	   gboolean      latin1,
-	   gchar      ***list)
-{
-  GSList *strings = NULL;
-  gint n_strings = 0;
-  gint i;
-  const gchar *p = text;
-  const gchar *q;
-  GSList *tmp_list;
-  GError *error = NULL;
-
-  while (p < text + length)
-    {
-      gchar *str;
-      
-      q = p;
-      while (*q && q < text + length)
-	q++;
-
-      if (latin1)
-	{
-	  str = g_convert (p, q - p,
-			   "UTF-8", "ISO-8859-1",
-			   NULL, NULL, &error);
-
-	  if (!str)
-	    {
-	      g_warning ("Error converting selection from STRING: %s",
-			 error->message);
-	      g_error_free (error);
-	    }
-	}
-      else
-	str = g_strndup (p, q - p);
-
-      if (str)
-	{
-	  strings = g_slist_prepend (strings, str);
-	  n_strings++;
-	}
-
-      p = q + 1;
-    }
-
-  if (list)
-    *list = g_new (gchar *, n_strings + 1);
-
-  (*list)[n_strings] = NULL;
-  
-  i = n_strings;
-  tmp_list = strings;
-  while (tmp_list)
-    {
-      if (list)
-	(*list)[--i] = tmp_list->data;
-      else
-	g_free (tmp_list->data);
-
-      tmp_list = tmp_list->next;
-    }
-
-  g_slist_free (strings);
-
-  return n_strings;
-}
-
-gint 
-gdk_text_property_to_utf8_list_for_display (GdkDisplay    *display,
-                                            GdkAtom        encoding,
-                                            gint           format,
-                                            const guchar  *text,
-                                            gint           length,
-                                            gchar       ***list)
-{
-  g_return_val_if_fail (text != NULL, 0);
-  g_return_val_if_fail (length >= 0, 0);
-  g_return_val_if_fail (display == _gdk_display, 0);
-
-  if (encoding == GDK_TARGET_STRING)
-    {
-      return make_list ((gchar *)text, length, TRUE, list);
-    }
-  else if (encoding == _utf8_string)
-    {
-      return make_list ((gchar *)text, length, FALSE, list);
-    }
-  else
-    {
-      gchar *enc_name = gdk_atom_name (encoding);
-
-      g_warning ("gdk_text_property_to_utf8_list_for_display: encoding %s not handled\n", enc_name);
-      g_free (enc_name);
-
-      if (list)
-	*list = NULL;
-
-      return 0;
-    }
-}
-
-gint
-gdk_string_to_compound_text_for_display (GdkDisplay  *display,
-					 const gchar *str,
-					 GdkAtom     *encoding,
-					 gint        *format,
-					 guchar     **ctext,
-					 gint        *length)
-{
-  g_return_val_if_fail (str != NULL, 0);
-  g_return_val_if_fail (length >= 0, 0);
-  g_return_val_if_fail (display == _gdk_display, 0);
-
-  GDK_NOTE (DND, g_print ("gdk_string_to_compound_text_for_display: %.20s\n", str));
-
-  /* Always fail on Win32. No COMPOUND_TEXT support. */
-
-  if (encoding)
-    *encoding = GDK_NONE;
-
-  if (format)
-    *format = 0;
-
-  if (ctext)
-    *ctext = NULL;
-
-  if (length)
-    *length = 0;
-
-  return -1;
-}
-
-gchar *
-gdk_utf8_to_string_target (const gchar *str)
-{
-  return _gdk_utf8_to_string_target_internal (str, strlen (str));
-}
-
-gboolean
-gdk_utf8_to_compound_text_for_display (GdkDisplay  *display,
-                                       const gchar *str,
-                                       GdkAtom     *encoding,
-                                       gint        *format,
-                                       guchar     **ctext,
-                                       gint        *length)
-{
-  g_return_val_if_fail (str != NULL, FALSE);
-  g_return_val_if_fail (display == _gdk_display, FALSE);
-
-  GDK_NOTE (DND, g_print ("gdk_utf8_to_compound_text_for_display: %.20s\n", str));
-
-  /* Always fail on Win32. No COMPOUND_TEXT support. */
-
-  if (encoding)
-    *encoding = GDK_NONE;
-
-  if (format)
-    *format = 0;
-  
-  if (ctext)
-    *ctext = NULL;
-
-  if (length)
-    *length = 0;
-
-  return FALSE;
-}
-
-void
-gdk_free_compound_text (guchar *ctext)
-{
-  /* As we never generate anything claimed to be COMPOUND_TEXT, this
-   * should never be called. Or if it is called, ctext should be the
-   * NULL returned for conversions to COMPOUND_TEXT above.
-   */
-  g_return_if_fail (ctext == NULL);
-}
-
-/* This function is called from gtk_selection_add_target() and
- * gtk_selection_add_targets() in gtkselection.c. It is this function
- * that takes care of setting those clipboard formats for which we use
- * delayed rendering. Formats copied directly to the clipboard are
- * handled in gdk_property_change() in gdkproperty-win32.c.
- */
-
-void
-gdk_win32_selection_add_targets (GdkWindow  *owner,
-				 GdkAtom     selection,
-				 gint	     n_targets,
-				 GdkAtom    *targets)
-{
-  HWND hwnd = NULL;
-  gboolean has_image = FALSE;
-  gint i;
-
-  GDK_NOTE (DND, {
-      gchar *sel_name = gdk_atom_name (selection);
-      
-      g_print ("gdk_win32_selection_add_targets: %p: %s: ",
-	       owner ? GDK_WINDOW_HWND (owner) : NULL,
-	       sel_name);
-      g_free (sel_name);
-
-      for (i = 0; i < n_targets; i++)
-	{
-	  gchar *tgt_name = gdk_atom_name (targets[i]);
-
-	  g_print ("%s", tgt_name);
-	  g_free (tgt_name);
-	  if (i < n_targets - 1)
-	    g_print (", ");
-	}
-      g_print ("\n");
-    });
-
-  if (selection != GDK_SELECTION_CLIPBOARD)
-    return;
-
-  if (owner != NULL)
-    {
-      if (GDK_WINDOW_DESTROYED (owner))
-	return;
-      hwnd = GDK_WINDOW_HWND (owner);
-    }
-
-  if (!API_CALL (OpenClipboard, (hwnd)))
-    return;
-
-  /* We have a very simple strategy: If some kind of pixmap image
-   * format is being added, actually advertise just PNG and DIB. PNG
-   * is our preferred format because it can losslessly represent any
-   * image that gdk-pixbuf formats in general can, even with alpha,
-   * unambiguously. CF_DIB is also advertised because of the general
-   * support for it in Windows software, but note that alpha won't be
-   * handled.
-   */
-  for (i = 0; !has_image && i < n_targets; ++i)
-    {
-      UINT cf;
-      gchar *target_name;
-      int j;
-      
-      for (j = 0; j < n_known_pixbuf_formats; j++)
-	if (targets[i] == known_pixbuf_formats[j])
-	  {
-	    if (!has_image)
-	      {
-		GDK_NOTE (DND, g_print ("... SetClipboardData(PNG,NULL)\n"));
-		SetClipboardData (_cf_png, NULL);
-
-		GDK_NOTE (DND, g_print ("... SetClipboardData(CF_DIB,NULL)\n"));
-		SetClipboardData (CF_DIB, NULL);
-
-		has_image = TRUE;
-	      }
-	    break;
-	  }
-      
-      /* If it is one of the pixmap formats, already handled or not
-       * needed.
-       */
-      if (j < n_known_pixbuf_formats)
-	continue;
-
-      /* We don't bother registering and advertising clipboard formats
-       * that are X11 specific or no non-GTK+ apps will have ever
-       * heard of, and when there are equivalent clipboard formats
-       * that are commonly used.
-       */
-      if (targets[i] == _save_targets ||
-	  targets[i] == _utf8_string ||
-	  targets[i] == GDK_TARGET_STRING ||
-	  targets[i] == _compound_text ||
-	  targets[i] == _text ||
-	  targets[i] == text_plain_charset_utf_8 ||
-	  targets[i] == text_plain_charset_CP1252 ||
-	  targets[i] == text_plain)
-	continue;
-
-      target_name = gdk_atom_name (targets[i]);
-
-      if (g_str_has_prefix (target_name, "text/plain;charset="))
-	{
-	  g_free (target_name);
-	  continue;
-	}
-
-      cf = RegisterClipboardFormat (target_name);
-
-      g_hash_table_replace (_format_atom_table,
-			    GINT_TO_POINTER (cf),
-			    targets[i]);
-      
-      GDK_NOTE (DND, g_print ("... SetClipboardData(%s,NULL)\n",
-			      _gdk_win32_cf_to_string (cf)));
-      SetClipboardData (cf, NULL);
-
-      g_free (target_name);
-    }
-  API_CALL (CloseClipboard, ());
-}
-
-/* Convert from types such as "image/jpg" or "image/png" to DIB using
- * gdk-pixbuf so that image copied from GTK+ apps can be pasted in
- * native apps like mspaint.exe
- */
-HGLOBAL
-_gdk_win32_selection_convert_to_dib (HGLOBAL  hdata,
-				     GdkAtom  target)
-{
-  GDK_NOTE (DND, {
-      gchar *target_name = gdk_atom_name (target);
-
-      g_print ("_gdk_win32_selection_convert_to_dib: %p %s\n",
-	       hdata, target_name);
-      g_free (target_name);
-    });
-
-  if (target == _image_bmp)
-    {
-      HGLOBAL hdatanew;
-      SIZE_T size;
-      guchar *ptr;
-
-      g_return_val_if_fail (GlobalSize (hdata) >= sizeof (BITMAPFILEHEADER), NULL);
-
-      /* No conversion is needed, just strip the BITMAPFILEHEADER */
-      size = GlobalSize (hdata) - sizeof (BITMAPFILEHEADER);
-      ptr = GlobalLock (hdata);
-
-      memmove (ptr, ptr + sizeof (BITMAPFILEHEADER), size);
-      GlobalUnlock (hdata);
-
-      if ((hdatanew = GlobalReAlloc (hdata, size, GMEM_MOVEABLE)) == NULL)
-	{
-	  WIN32_API_FAILED ("GlobalReAlloc");
-	  GlobalFree (hdata); /* The old hdata is not freed if error */
-	}
-      return hdatanew;
-    }
-
-  g_warning ("Should not happen: We provide some image format but not CF_DIB and CF_DIB is requested.");
-
-  return NULL;
-}
diff --git a/gdk/win32/gdkspawn-win32.c b/gdk/win32/gdkspawn-win32.c
deleted file mode 100644
index 8f0df20..0000000
--- a/gdk/win32/gdkspawn-win32.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2003 Sun Microsystems Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- *
- * Authors: Mark McLoughlin <mark@skynet.ie>
- */
-
-#include "config.h"
-
-#include "gdkspawn.h"
-
-#include <glib.h>
-#include <gdk/gdk.h>
-
-gboolean
-gdk_spawn_on_screen (GdkScreen             *screen,
-		     const gchar           *working_directory,
-		     gchar                **argv,
-		     gchar                **envp,
-		     GSpawnFlags            flags,
-		     GSpawnChildSetupFunc   child_setup,
-		     gpointer               user_data,
-		     gint                  *child_pid,
-		     GError               **error)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
-  g_assert (sizeof(GPid) == sizeof(int));
-
-  return g_spawn_async (working_directory,
-			argv,
-			envp,
-			flags,
-			child_setup,
-			user_data,
-			(GPid*)child_pid,
-			error);
-}
-
-gboolean
-gdk_spawn_on_screen_with_pipes (GdkScreen            *screen,
-				const gchar          *working_directory,
-				gchar               **argv,
-				gchar               **envp,
-				GSpawnFlags           flags,
-				GSpawnChildSetupFunc  child_setup,
-				gpointer              user_data,
-				gint                 *child_pid,
-				gint                 *standard_input,
-				gint                 *standard_output,
-				gint                 *standard_error,
-				GError              **error)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
-  g_assert (sizeof(GPid) == sizeof(int));
-
-  return g_spawn_async_with_pipes (working_directory,
-				   argv,
-				   envp,
-				   flags,
-				   child_setup,
-				   user_data,
-				   (GPid*)child_pid,
-				   standard_input,
-				   standard_output,
-				   standard_error,
-				   error);
-}
-
-gboolean
-gdk_spawn_command_line_on_screen (GdkScreen    *screen,
-				  const gchar  *command_line,
-				  GError      **error)
-{
-  gchar    **argv = NULL;
-  gboolean   retval;
-
-  g_return_val_if_fail (command_line != NULL, FALSE);
-
-  if (!g_shell_parse_argv (command_line,
-			   NULL, &argv,
-			   error))
-    return FALSE;
-
-  retval = gdk_spawn_on_screen (screen,
-				NULL, argv, NULL,
-				G_SPAWN_SEARCH_PATH,
-				NULL, NULL, NULL,
-				error);
-  g_strfreev (argv);
-
-  return retval;
-}
diff --git a/gdk/win32/gdktestutils-win32.c b/gdk/win32/gdktestutils-win32.c
deleted file mode 100644
index b895100..0000000
--- a/gdk/win32/gdktestutils-win32.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/* Gtk+ testing utilities
- * Copyright (C) 2007 Imendio AB
- * Authors: Tim Janik
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-#include <gdk/gdktestutils.h>
-#include <gdk/gdkkeysyms.h>
-#include <win32/gdkwin32.h>
-#include "gdkalias.h"
-
-void
-gdk_test_render_sync (GdkWindow *window)
-{
-}
-
-gboolean
-gdk_test_simulate_key (GdkWindow      *window,
-                       gint            x,
-                       gint            y,
-                       guint           keyval,
-                       GdkModifierType modifiers,
-                       GdkEventType    key_pressrelease)
-{
-  gboolean      success = FALSE;
-  GdkKeymapKey *keys    = NULL;
-  gint          n_keys  = 0;
-  INPUT         ip;
-  gint          i;
-
-  g_return_val_if_fail (key_pressrelease == GDK_KEY_PRESS || key_pressrelease == GDK_KEY_RELEASE, FALSE);
-  g_return_val_if_fail (window != NULL, FALSE);
-
-  ip.type = INPUT_KEYBOARD;
-  ip.ki.wScan = 0;
-  ip.ki.time = 0;
-  ip.ki.dwExtraInfo = 0;
-
-  switch (key_pressrelease)
-    {
-    case GDK_KEY_PRESS:
-      ip.ki.dwFlags = 0;
-      break;
-    case GDK_KEY_RELEASE:
-      ip.ki.dwFlags = KEYEVENTF_KEYUP;
-      break;
-    default:
-      /* Not a key event. */
-      return FALSE;
-    }
-  if (gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (), keyval, &keys, &n_keys))
-    {
-      for (i = 0; i < n_keys; i++)
-        {
-          if (key_pressrelease == GDK_KEY_PRESS)
-            {
-              /* AltGr press. */
-              if (keys[i].group)
-                {
-                  /* According to some virtualbox code I found, AltGr is
-                   * simulated on win32 with LCtrl+RAlt */
-                  ip.ki.wVk = VK_CONTROL;
-                  SendInput(1, &ip, sizeof(INPUT));
-                  ip.ki.wVk = VK_MENU;
-                  SendInput(1, &ip, sizeof(INPUT));
-                }
-              /* Shift press. */
-              if (keys[i].level || (modifiers & GDK_SHIFT_MASK))
-                {
-                  ip.ki.wVk = VK_SHIFT;
-                  SendInput(1, &ip, sizeof(INPUT));
-                }
-            }
-
-          /* Key pressed/released. */
-          ip.ki.wVk = keys[i].keycode;
-          SendInput(1, &ip, sizeof(INPUT));
-
-          if (key_pressrelease == GDK_KEY_RELEASE)
-            {
-              /* Shift release. */
-              if (keys[i].level || (modifiers & GDK_SHIFT_MASK))
-                {
-                  ip.ki.wVk = VK_SHIFT;
-                  SendInput(1, &ip, sizeof(INPUT));
-                }
-              /* AltrGr release. */
-              if (keys[i].group)
-                {
-                  ip.ki.wVk = VK_MENU;
-                  SendInput(1, &ip, sizeof(INPUT));
-                  ip.ki.wVk = VK_CONTROL;
-                  SendInput(1, &ip, sizeof(INPUT));
-                }
-            }
-
-          /* No need to loop for alternative keycodes. We want only one
-           * key generated. */
-          success = TRUE;
-          break;
-        }
-      g_free (keys);
-    }
-  return success;
-}
-
-gboolean
-gdk_test_simulate_button (GdkWindow      *window,
-                          gint            x,
-                          gint            y,
-                          guint           button, /*1..3*/
-                          GdkModifierType modifiers,
-                          GdkEventType    button_pressrelease)
-{
-  g_return_val_if_fail (button_pressrelease == GDK_BUTTON_PRESS || button_pressrelease == GDK_BUTTON_RELEASE, FALSE);
-  g_return_val_if_fail (window != NULL, FALSE);
-
-  return FALSE;
-}
diff --git a/gdk/win32/gdkvisual-win32.c b/gdk/win32/gdkvisual-win32.c
deleted file mode 100644
index 440f6ce..0000000
--- a/gdk/win32/gdkvisual-win32.c
+++ /dev/null
@@ -1,401 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2002 Tor Lillqvist
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <stdlib.h>
-
-#include "gdkvisual.h"
-#include "gdkscreen.h" /* gdk_screen_get_default() */
-#include "gdkprivate-win32.h"
-
-static void  gdk_visual_decompose_mask (gulong     mask,
-					gint      *shift,
-					gint      *prec);
-
-static GdkVisual *system_visual = NULL;
-
-static gint available_depths[1];
-
-static GdkVisualType available_types[1];
-
-static void
-gdk_visual_finalize (GObject *object)
-{
-  g_error ("A GdkVisual object was finalized. This should not happen");
-}
-
-static void
-gdk_visual_class_init (GObjectClass *class)
-{
-  class->finalize = gdk_visual_finalize;
-}
-
-GType
-gdk_visual_get_type (void)
-{
-  static GType object_type = 0;
-
-  if (!object_type)
-    {
-      const GTypeInfo object_info =
-      {
-        sizeof (GdkVisualClass),
-        (GBaseInitFunc) NULL,
-        (GBaseFinalizeFunc) NULL,
-        (GClassInitFunc) gdk_visual_class_init,
-        NULL,           /* class_finalize */
-        NULL,           /* class_data */
-        sizeof (GdkVisual),
-        0,              /* n_preallocs */
-        (GInstanceInitFunc) NULL,
-      };
-      
-      object_type = g_type_register_static (G_TYPE_OBJECT,
-                                            "GdkVisual",
-                                            &object_info, 0);
-    }
-  
-  return object_type;
-}
-
-void
-_gdk_visual_init (void)
-{
-  struct
-  {
-    BITMAPINFOHEADER bi;
-    union
-    {
-      RGBQUAD colors[256];
-      DWORD fields[256];
-    } u;
-  } bmi;
-  HBITMAP hbm;
-
-  const gint rastercaps = GetDeviceCaps (_gdk_display_hdc, RASTERCAPS);
-  const int numcolors = GetDeviceCaps (_gdk_display_hdc, NUMCOLORS);
-  gint bitspixel = GetDeviceCaps (_gdk_display_hdc, BITSPIXEL);
-  gint map_entries = 0;
-
-  system_visual = g_object_new (GDK_TYPE_VISUAL, NULL);
-
-  GDK_NOTE (COLORMAP, g_print ("BITSPIXEL=%d NUMCOLORS=%d\n",
-			       bitspixel, numcolors));
-
-  if (rastercaps & RC_PALETTE)
-    {
-      const int sizepalette = GetDeviceCaps (_gdk_display_hdc, SIZEPALETTE);
-      gchar *max_colors = getenv ("GDK_WIN32_MAX_COLORS");
-      system_visual->type = GDK_VISUAL_PSEUDO_COLOR;
-
-      GDK_NOTE (COLORMAP, g_print ("SIZEPALETTE=%d\n", sizepalette));
-      g_assert (sizepalette == 256);
-
-      if (max_colors != NULL)
-	_gdk_max_colors = atoi (max_colors);
-      
-      map_entries = _gdk_max_colors;
-
-      if (map_entries >= 16 && map_entries < sizepalette)
-	{
-	  /* The calls to gdk_rgb_set_min_colors() here have knowledge
-	   * of what color cubes gdk_rgb_do_colormaps() will try, and
-	   * of the static system palette colors... XXX
-	   */
-	  if (map_entries < 32)
-	    {
-	      map_entries = 16;
-	      system_visual->type = GDK_VISUAL_STATIC_COLOR;
-	      bitspixel = 4;
-	      gdk_rgb_set_min_colors (2*2*2);
-	    }
-	  else if (map_entries < 64)
-	    {
-	      map_entries = 32;
-	      bitspixel = 5;
-	      gdk_rgb_set_min_colors (3*3*3);
-	    }
-	  else if (map_entries < 128)
-	    {
-	      map_entries = 64;
-	      bitspixel = 6;
-	      gdk_rgb_set_min_colors (3*3*3);
-	    }
-	  else if (map_entries < 256)
-	    {
-	      map_entries = 128;
-	      bitspixel = 7;
-	      gdk_rgb_set_min_colors (5*5*4);
-	    }
-	  else
-	    g_assert_not_reached ();
-	}
-      else
-	map_entries = sizepalette;
-    }
-  else if (bitspixel == 1 && numcolors == 16)
-    {
-      bitspixel = 4;
-      system_visual->type = GDK_VISUAL_STATIC_COLOR;
-      map_entries = 16;
-    }
-  else if (bitspixel == 1)
-    {
-      system_visual->type = GDK_VISUAL_STATIC_GRAY;
-      map_entries = 2;
-    }
-  else if (bitspixel == 4)
-    {
-      system_visual->type = GDK_VISUAL_STATIC_COLOR;
-      map_entries = 16;
-    }
-  else if (bitspixel == 8)
-    {
-      system_visual->type = GDK_VISUAL_STATIC_COLOR;
-      map_entries = 256;
-    }
-  else if (bitspixel == 16)
-    {
-      system_visual->type = GDK_VISUAL_TRUE_COLOR;
-#if 1
-      /* This code by Mike Enright,
-       * see http://www.users.cts.com/sd/m/menright/display.html
-       */
-      memset (&bmi, 0, sizeof (bmi));
-      bmi.bi.biSize = sizeof (bmi.bi);
-
-      hbm = CreateCompatibleBitmap (_gdk_display_hdc, 1, 1);
-      GetDIBits (_gdk_display_hdc, hbm, 0, 1, NULL,
-		 (BITMAPINFO *) &bmi, DIB_RGB_COLORS);
-      GetDIBits (_gdk_display_hdc, hbm, 0, 1, NULL,
-		 (BITMAPINFO *) &bmi, DIB_RGB_COLORS);
-      DeleteObject (hbm);
-
-      if (bmi.bi.biCompression != BI_BITFIELDS)
-	{
-	  /* Either BI_RGB or BI_RLE_something
-	   * .... or perhaps (!!) something else.
-	   * Theoretically biCompression might be
-	   * mmioFourCC('c','v','i','d') but I doubt it.
-	   */
-	  if (bmi.bi.biCompression == BI_RGB)
-	    {
-	      /* It's 555 */
-	      bitspixel = 15;
-	      system_visual->red_mask   = 0x00007C00;
-	      system_visual->green_mask = 0x000003E0;
-	      system_visual->blue_mask  = 0x0000001F;
-	    }
-	  else
-	    {
-	      g_assert_not_reached ();
-	    }
-	}
-      else
-	{
-	  DWORD allmasks =
-	    bmi.u.fields[0] | bmi.u.fields[1] | bmi.u.fields[2];
-	  int k = 0;
-	  while (allmasks)
-	    {
-	      if (allmasks&1)
-		k++;
-	      allmasks/=2;
-	    }
-	  bitspixel = k;
-	  system_visual->red_mask = bmi.u.fields[0];
-	  system_visual->green_mask = bmi.u.fields[1];
-	  system_visual->blue_mask  = bmi.u.fields[2];
-	}
-#else
-      /* Old, incorrect (but still working) code. */
-#if 0
-      system_visual->red_mask   = 0x0000F800;
-      system_visual->green_mask = 0x000007E0;
-      system_visual->blue_mask  = 0x0000001F;
-#else
-      system_visual->red_mask   = 0x00007C00;
-      system_visual->green_mask = 0x000003E0;
-      system_visual->blue_mask  = 0x0000001F;
-#endif
-#endif
-    }
-  else if (bitspixel == 24 || bitspixel == 32)
-    {
-      bitspixel = 24;
-      system_visual->type = GDK_VISUAL_TRUE_COLOR;
-      system_visual->red_mask   = 0x00FF0000;
-      system_visual->green_mask = 0x0000FF00;
-      system_visual->blue_mask  = 0x000000FF;
-    }
-  else
-    g_error ("_gdk_visual_init: unsupported BITSPIXEL: %d\n", bitspixel);
-
-  system_visual->depth = bitspixel;
-  system_visual->byte_order = GDK_LSB_FIRST;
-  system_visual->bits_per_rgb = 42; /* Not used? */
-
-  if ((system_visual->type == GDK_VISUAL_TRUE_COLOR) ||
-      (system_visual->type == GDK_VISUAL_DIRECT_COLOR))
-    {
-      gdk_visual_decompose_mask (system_visual->red_mask,
-				 &system_visual->red_shift,
-				 &system_visual->red_prec);
-
-      gdk_visual_decompose_mask (system_visual->green_mask,
-				 &system_visual->green_shift,
-				 &system_visual->green_prec);
-
-      gdk_visual_decompose_mask (system_visual->blue_mask,
-				 &system_visual->blue_shift,
-				 &system_visual->blue_prec);
-      map_entries = 1 << (MAX (system_visual->red_prec,
-			       MAX (system_visual->green_prec,
-				    system_visual->blue_prec)));
-    }
-  else
-    {
-      system_visual->red_mask = 0;
-      system_visual->red_shift = 0;
-      system_visual->red_prec = 0;
-
-      system_visual->green_mask = 0;
-      system_visual->green_shift = 0;
-      system_visual->green_prec = 0;
-
-      system_visual->blue_mask = 0;
-      system_visual->blue_shift = 0;
-      system_visual->blue_prec = 0;
-    }
-  system_visual->colormap_size = map_entries;
-
-  available_depths[0] = system_visual->depth;
-  available_types[0] = system_visual->type;
-}
-
-gint
-gdk_visual_get_best_depth (void)
-{
-  return available_depths[0];
-}
-
-GdkVisualType
-gdk_visual_get_best_type (void)
-{
-  return available_types[0];
-}
-
-GdkVisual*
-gdk_screen_get_system_visual (GdkScreen *screen)
-{
-  return system_visual;
-}
-
-GdkVisual*
-gdk_visual_get_best (void)
-{
-  return ((GdkVisual*) system_visual);
-}
-
-GdkVisual*
-gdk_visual_get_best_with_depth (gint depth)
-{
-  if (depth == system_visual->depth)
-    return (GdkVisual*) system_visual;
-  else
-    return NULL;
-}
-
-GdkVisual*
-gdk_visual_get_best_with_type (GdkVisualType visual_type)
-{
-  if (visual_type == system_visual->type)
-    return system_visual;
-  else
-    return NULL;
-}
-
-GdkVisual*
-gdk_visual_get_best_with_both (gint          depth,
-			       GdkVisualType visual_type)
-{
-  if ((depth == system_visual->depth) && (visual_type == system_visual->type))
-    return system_visual;
-  else
-    return NULL;
-}
-
-void
-gdk_query_depths  (gint **depths,
-		   gint  *count)
-{
-  *count = 1;
-  *depths = available_depths;
-}
-
-void
-gdk_query_visual_types (GdkVisualType **visual_types,
-			gint           *count)
-{
-  *count = 1;
-  *visual_types = available_types;
-}
-
-GList*
-gdk_screen_list_visuals (GdkScreen *screen)
-{
-  return g_list_append (NULL, (gpointer) system_visual);
-}
-
-GdkScreen *
-gdk_visual_get_screen (GdkVisual *visual)
-{
-  g_return_val_if_fail (GDK_IS_VISUAL (visual), NULL);
-
-  return gdk_screen_get_default ();
-}
-
-static void
-gdk_visual_decompose_mask (gulong  mask,
-			   gint   *shift,
-			   gint   *prec)
-{
-  *shift = 0;
-  *prec = 0;
-
-  while (!(mask & 0x1))
-    {
-      (*shift)++;
-      mask >>= 1;
-    }
-
-  while (mask & 0x1)
-    {
-      (*prec)++;
-      mask >>= 1;
-    }
-}
diff --git a/gdk/win32/gdkwin32.h b/gdk/win32/gdkwin32.h
deleted file mode 100644
index 32777ad..0000000
--- a/gdk/win32/gdkwin32.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#ifndef __GDK_WIN32_H__
-#define __GDK_WIN32_H__
-
-#include <gdk/gdkprivate.h>
-
-#ifndef STRICT
-#define STRICT			/* We want strict type checks */
-#endif
-#include <windows.h>
-#include <commctrl.h>
-
-G_BEGIN_DECLS
-
-#ifdef INSIDE_GDK_WIN32
-
-#include "gdkprivate-win32.h"
-
-#undef GDK_ROOT_PARENT /* internal access is direct */
-#define GDK_ROOT_PARENT()             ((GdkWindow *) _gdk_parent_root)
-#define GDK_WINDOW_HWND(win)          (GDK_DRAWABLE_IMPL_WIN32(((GdkWindowObject *)win)->impl)->handle)
-#define GDK_PIXMAP_HBITMAP(pixmap)    (GDK_DRAWABLE_IMPL_WIN32(((GdkPixmapObject *)pixmap)->impl)->handle)
-#define GDK_DRAWABLE_IMPL_WIN32_HANDLE(d) (((GdkDrawableImplWin32 *) d)->handle)
-#define GDK_DRAWABLE_HANDLE(win)      (GDK_IS_WINDOW (win) ? GDK_WINDOW_HWND (win) : (GDK_IS_PIXMAP (win) ? GDK_PIXMAP_HBITMAP (win) : (GDK_IS_DRAWABLE_IMPL_WIN32 (win) ? GDK_DRAWABLE_IMPL_WIN32_HANDLE (win) : 0)))
-#else
-/* definition for exported 'internals' go here */
-#define GDK_WINDOW_HWND(d) (gdk_win32_drawable_get_handle (d))
-
-#endif
-
-#define GDK_ROOT_WINDOW()             ((guint32) HWND_DESKTOP)
-#define GDK_DISPLAY()                 NULL
-
-
-/* These need to be here so gtkstatusicon.c can pick them up if needed. */
-#ifndef WM_XBUTTONDOWN
-#define WM_XBUTTONDOWN 0x020B
-#endif
-#ifndef WM_XBUTTONUP
-#define WM_XBUTTONUP 0x020C
-#endif
-#ifndef GET_XBUTTON_WPARAM
-#define GET_XBUTTON_WPARAM(w) (HIWORD(w))
-#endif
-#ifndef XBUTTON1
-#define XBUTTON1 1
-#endif
-#ifndef XBUTTON2
-#define XBUTTON2 2
-#endif
-
-
-/* Return true if the GdkWindow is a win32 implemented window */
-gboolean      gdk_win32_window_is_win32 (GdkWindow *window);
-HWND          gdk_win32_window_get_impl_hwnd (GdkWindow *window);
-
-/* Return the Gdk* for a particular HANDLE */
-gpointer      gdk_win32_handle_table_lookup (GdkNativeWindow handle);
-
-/* Translate from drawable to Windows handle */
-HGDIOBJ       gdk_win32_drawable_get_handle (GdkDrawable *drawable);
-
-/* Return a device context to draw in a drawable, given a GDK GC,
- * and a mask indicating which GC values might be used (for efficiency,
- * no need to muck around with text-related stuff if we aren't going
- * to output text, for instance).
- */
-HDC           gdk_win32_hdc_get      (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      GdkGCValuesMask usage);
-
-/* Each HDC returned from gdk_win32_hdc_get must be released with
- * this function
- */
-void          gdk_win32_hdc_release  (GdkDrawable    *drawable,
-				      GdkGC          *gc,
-				      GdkGCValuesMask usage);
-
-void          gdk_win32_selection_add_targets (GdkWindow  *owner,
-					       GdkAtom     selection,
-					       gint	   n_targets,
-					       GdkAtom    *targets);
-
-/* For internal GTK use only */
-GdkPixbuf    *gdk_win32_icon_to_pixbuf_libgtk_only (HICON hicon);
-HICON         gdk_win32_pixbuf_to_hicon_libgtk_only (GdkPixbuf *pixbuf);
-void          gdk_win32_set_modal_dialog_libgtk_only (HWND window);
-
-GdkDrawable  *gdk_win32_begin_direct_draw_libgtk_only (GdkDrawable *drawable,
-						       GdkGC *gc,
-						       gpointer *priv_data,
-						       gint *x_offset_out,
-						       gint *y_offset_out);
-void          gdk_win32_end_direct_draw_libgtk_only (gpointer priv_data);
-
-GdkWindow *   gdk_win32_window_foreign_new_for_display (GdkDisplay *display,
-                                                        GdkNativeWindow anid);
-GdkWindow *   gdk_win32_window_lookup_for_display (GdkDisplay *display,
-                                                   GdkNativeWindow anid);
-
-
-G_END_DECLS
-
-#endif /* __GDK_WIN32_H__ */
diff --git a/gdk/win32/gdkwin32id.c b/gdk/win32/gdkwin32id.c
deleted file mode 100644
index 4ccb399..0000000
--- a/gdk/win32/gdkwin32id.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <gdk/gdk.h>
-
-#include "gdkprivate-win32.h"
-
-static GHashTable *handle_ht = NULL;
-
-static guint
-gdk_handle_hash (HANDLE *handle)
-{
-#ifdef _WIN64
-  return ((guint *) handle)[0] ^ ((guint *) handle)[1];
-#else
-  return (guint) *handle;
-#endif
-}
-
-static gint
-gdk_handle_equal (HANDLE *a,
-		  HANDLE *b)
-{
-  return (*a == *b);
-}
-
-void
-gdk_win32_handle_table_insert (HANDLE  *handle,
-			       gpointer data)
-{
-  g_return_if_fail (handle != NULL);
-
-  if (!handle_ht)
-    handle_ht = g_hash_table_new ((GHashFunc) gdk_handle_hash,
-				  (GEqualFunc) gdk_handle_equal);
-
-  g_hash_table_insert (handle_ht, handle, data);
-}
-
-void
-gdk_win32_handle_table_remove (HANDLE handle)
-{
-  if (!handle_ht)
-    handle_ht = g_hash_table_new ((GHashFunc) gdk_handle_hash,
-				  (GEqualFunc) gdk_handle_equal);
-
-  g_hash_table_remove (handle_ht, &handle);
-}
-
-gpointer
-gdk_win32_handle_table_lookup (GdkNativeWindow handle)
-{
-  gpointer data = NULL;
-
-  if (handle_ht)
-    data = g_hash_table_lookup (handle_ht, &handle);
-  
-  return data;
-}
diff --git a/gdk/win32/gdkwin32keys.h b/gdk/win32/gdkwin32keys.h
deleted file mode 100644
index 8c8aed1..0000000
--- a/gdk/win32/gdkwin32keys.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 2010 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __GDK_WIN32_KEYS_H__
-#define __GDK_WIN32_KEYS_H__
-
-
-#include <gdk/gdk.h>
-
-G_BEGIN_DECLS
-
-/**
- * GdkWin32KeymapMatch:
- * @GDK_WIN32_KEYMAP_MATCH_NONE: no matches found. Output is not valid.
- * @GDK_WIN32_KEYMAP_MATCH_INCOMPLETE: the sequence matches so far, but is incomplete. Output is not valid.
- * @GDK_WIN32_KEYMAP_MATCH_PARTIAL: the sequence matches up to the last key,
- *     which does not match. Output is valid.
- * @GDK_WIN32_KEYMAP_MATCH_EXACT: the sequence matches exactly. Output is valid.
- *
- * An enumeration describing the result of a deadkey combination matching.
- */
-typedef enum
-{
-  GDK_WIN32_KEYMAP_MATCH_NONE,
-  GDK_WIN32_KEYMAP_MATCH_INCOMPLETE,
-  GDK_WIN32_KEYMAP_MATCH_PARTIAL,
-  GDK_WIN32_KEYMAP_MATCH_EXACT
-} GdkWin32KeymapMatch;
-
-#ifdef GDK_COMPILATION
-typedef struct _GdkWin32Keymap GdkWin32Keymap;
-#else
-typedef GdkKeymap GdkWin32Keymap;
-#endif
-typedef struct _GdkWin32KeymapClass GdkWin32KeymapClass;
-
-#define GDK_TYPE_WIN32_KEYMAP              (gdk_win32_keymap_get_type())
-#define GDK_WIN32_KEYMAP(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_WIN32_KEYMAP, GdkWin32Keymap))
-#define GDK_WIN32_KEYMAP_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_WIN32_KEYMAP, GdkWin32KeymapClass))
-#define GDK_IS_WIN32_KEYMAP(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_WIN32_KEYMAP))
-#define GDK_IS_WIN32_KEYMAP_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_WIN32_KEYMAP))
-#define GDK_WIN32_KEYMAP_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GDK_TYPE_WIN32_KEYMAP, GdkWin32KeymapClass))
-
-GType gdk_win32_keymap_get_type (void);
-
-GdkWin32KeymapMatch gdk_win32_keymap_check_compose (GdkWin32Keymap *keymap,
-                                                    guint          *compose_buffer,
-                                                    gsize           compose_buffer_len,
-                                                    guint16        *output,
-                                                    gsize          *output_len);
-
-G_END_DECLS
-
-#endif /* __GDK_WIN32_KEYMAP_H__ */
diff --git a/gdk/win32/gdkwindow-win32.c b/gdk/win32/gdkwindow-win32.c
deleted file mode 100644
index d918686..0000000
--- a/gdk/win32/gdkwindow-win32.c
+++ /dev/null
@@ -1,4171 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- * Copyright (C) 1998-2004 Tor Lillqvist
- * Copyright (C) 2001-2009 Hans Breuer
- * Copyright (C) 2007-2009 Cody Russell
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#include "config.h"
-#include <stdlib.h>
-
-#include "gdk.h"
-#include "gdkwindowimpl.h"
-#include "gdkprivate-win32.h"
-#include "gdkinput-win32.h"
-#include "gdkenumtypes.h"
-
-static GdkColormap* gdk_window_impl_win32_get_colormap (GdkDrawable *drawable);
-static void         gdk_window_impl_win32_set_colormap (GdkDrawable *drawable,
-							GdkColormap *cmap);
-
-static void gdk_window_impl_win32_get_size   (GdkDrawable        *drawable,
-                                              gint               *width,
-                                              gint               *height);
-static void gdk_window_impl_win32_init       (GdkWindowImplWin32      *window);
-static void gdk_window_impl_win32_class_init (GdkWindowImplWin32Class *klass);
-static void gdk_window_impl_win32_finalize   (GObject                 *object);
-
-static gpointer parent_class = NULL;
-static GSList *modal_window_stack = NULL;
-
-typedef struct _FullscreenInfo FullscreenInfo;
-
-struct _FullscreenInfo
-{
-  RECT  r;
-  guint hint_flags;
-  LONG  style;
-};
-
-static void     update_style_bits         (GdkWindow         *window);
-static gboolean _gdk_window_get_functions (GdkWindow         *window,
-                                           GdkWMFunction     *functions);
-
-#define WINDOW_IS_TOPLEVEL(window)		   \
-  (GDK_WINDOW_TYPE (window) != GDK_WINDOW_CHILD && \
-   GDK_WINDOW_TYPE (window) != GDK_WINDOW_FOREIGN && \
-   GDK_WINDOW_TYPE (window) != GDK_WINDOW_OFFSCREEN)
-
-static void gdk_window_impl_iface_init (GdkWindowImplIface *iface);
-
-GdkScreen *
-GDK_WINDOW_SCREEN (GObject *win)
-{
-  return _gdk_screen;
-}
-
-GType
-_gdk_window_impl_win32_get_type (void)
-{
-  static GType object_type = 0;
-
-  if (!object_type)
-    {
-      const GTypeInfo object_info =
-      {
-        sizeof (GdkWindowImplWin32Class),
-        (GBaseInitFunc) NULL,
-        (GBaseFinalizeFunc) NULL,
-        (GClassInitFunc) gdk_window_impl_win32_class_init,
-        NULL,           /* class_finalize */
-        NULL,           /* class_data */
-        sizeof (GdkWindowImplWin32),
-        0,              /* n_preallocs */
-        (GInstanceInitFunc) gdk_window_impl_win32_init,
-      };
-
-      const GInterfaceInfo window_impl_info =
-      {
-	(GInterfaceInitFunc) gdk_window_impl_iface_init,
-	NULL,
-	NULL
-      };
-      
-      object_type = g_type_register_static (GDK_TYPE_DRAWABLE_IMPL_WIN32,
-                                            "GdkWindowImplWin32",
-                                            &object_info, 0);
-      g_type_add_interface_static (object_type,
-				   GDK_TYPE_WINDOW_IMPL,
-				   &window_impl_info);
-    }
-  
-  return object_type;
-}
-
-GType
-_gdk_window_impl_get_type (void)
-{
-  return _gdk_window_impl_win32_get_type ();
-}
-
-static void
-gdk_window_impl_win32_get_size (GdkDrawable *drawable,
-                                gint        *width,
-                                gint        *height)
-{
-  GdkWindowObject *wrapper;
-  GdkDrawableImplWin32 *draw_impl;
-
-  g_return_if_fail (GDK_IS_WINDOW_IMPL_WIN32 (drawable));
-
-  draw_impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-  wrapper = (GdkWindowObject*) draw_impl->wrapper;
-
-  if (width)
-    *width = wrapper->width;
-  if (height)
-    *height = wrapper->height;
-}
-
-static void
-gdk_window_impl_win32_init (GdkWindowImplWin32 *impl)
-{
-  impl->toplevel_window_type = -1;
-  impl->hcursor = NULL;
-  impl->hicon_big = NULL;
-  impl->hicon_small = NULL;
-  impl->hint_flags = 0;
-  impl->type_hint = GDK_WINDOW_TYPE_HINT_NORMAL;
-  impl->extension_events_mask = 0;
-  impl->transient_owner = NULL;
-  impl->transient_children = NULL;
-  impl->num_transients = 0;
-  impl->changing_state = FALSE;
-}
-
-static void
-gdk_window_impl_win32_class_init (GdkWindowImplWin32Class *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GdkDrawableClass *drawable_class = GDK_DRAWABLE_CLASS (klass);
-  
-  parent_class = g_type_class_peek_parent (klass);
-
-  object_class->finalize = gdk_window_impl_win32_finalize;
-
-  drawable_class->set_colormap = gdk_window_impl_win32_set_colormap;
-  drawable_class->get_colormap = gdk_window_impl_win32_get_colormap;
-  drawable_class->get_size = gdk_window_impl_win32_get_size;
-}
-
-static void
-gdk_window_impl_win32_finalize (GObject *object)
-{
-  GdkWindowObject *wrapper;
-  GdkDrawableImplWin32 *draw_impl;
-  GdkWindowImplWin32 *window_impl;
-  
-  g_return_if_fail (GDK_IS_WINDOW_IMPL_WIN32 (object));
-
-  draw_impl = GDK_DRAWABLE_IMPL_WIN32 (object);
-  window_impl = GDK_WINDOW_IMPL_WIN32 (object);
-  
-  wrapper = (GdkWindowObject*) draw_impl->wrapper;
-
-  if (!GDK_WINDOW_DESTROYED (wrapper))
-    {
-      gdk_win32_handle_table_remove (draw_impl->handle);
-    }
-
-  if (window_impl->hcursor != NULL)
-    {
-      if (GetCursor () == window_impl->hcursor)
-	SetCursor (NULL);
-
-      GDI_CALL (DestroyCursor, (window_impl->hcursor));
-      window_impl->hcursor = NULL;
-    }
-
-  if (window_impl->hicon_big != NULL)
-    {
-      GDI_CALL (DestroyIcon, (window_impl->hicon_big));
-      window_impl->hicon_big = NULL;
-    }
-
-  if (window_impl->hicon_small != NULL)
-    {
-      GDI_CALL (DestroyIcon, (window_impl->hicon_small));
-      window_impl->hicon_small = NULL;
-    }
-
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-void
-_gdk_win32_adjust_client_rect (GdkWindow *window,
-			       RECT      *rect)
-{
-  LONG style, exstyle;
-
-  style = GetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE);
-  exstyle = GetWindowLong (GDK_WINDOW_HWND (window), GWL_EXSTYLE);
-  API_CALL (AdjustWindowRectEx, (rect, style, FALSE, exstyle));
-}
-
-static GdkColormap*
-gdk_window_impl_win32_get_colormap (GdkDrawable *drawable)
-{
-  GdkDrawableImplWin32 *drawable_impl;
-  
-  g_return_val_if_fail (GDK_IS_WINDOW_IMPL_WIN32 (drawable), NULL);
-
-  drawable_impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-
-  if (!((GdkWindowObject *) drawable_impl->wrapper)->input_only && 
-      drawable_impl->colormap == NULL)
-    {
-      drawable_impl->colormap = gdk_screen_get_system_colormap (_gdk_screen);
-      g_object_ref (drawable_impl->colormap);
-    }
-  
-  return drawable_impl->colormap;
-}
-
-static void
-gdk_window_impl_win32_set_colormap (GdkDrawable *drawable,
-				    GdkColormap *cmap)
-{
-  GdkWindowImplWin32 *impl;
-  GdkDrawableImplWin32 *draw_impl;
-  
-  g_return_if_fail (GDK_IS_WINDOW_IMPL_WIN32 (drawable));
-
-  impl = GDK_WINDOW_IMPL_WIN32 (drawable);
-  draw_impl = GDK_DRAWABLE_IMPL_WIN32 (drawable);
-
-  /* chain up */
-  GDK_DRAWABLE_CLASS (parent_class)->set_colormap (drawable, cmap);
-  
-  if (cmap)
-    {
-      /* XXX */
-      g_print ("gdk_window_impl_win32_set_colormap: XXX\n");
-    }
-}
-
-void
-_gdk_root_window_size_init (void)
-{
-  GdkWindowObject *window_object;
-  GdkRectangle rect;
-  int i;
-
-  window_object = GDK_WINDOW_OBJECT (_gdk_root);
-  rect = _gdk_monitors[0].rect;
-  for (i = 1; i < _gdk_num_monitors; i++)
-    gdk_rectangle_union (&rect, &_gdk_monitors[i].rect, &rect);
-
-  window_object->width = rect.width;
-  window_object->height = rect.height;
-}
-
-void
-_gdk_windowing_window_init (GdkScreen *screen)
-{
-  GdkWindowObject *private;
-  GdkDrawableImplWin32 *draw_impl;
-
-  g_assert (_gdk_root == NULL);
-  
-  _gdk_root = g_object_new (GDK_TYPE_WINDOW, NULL);
-  private = (GdkWindowObject *)_gdk_root;
-  private->impl = g_object_new (_gdk_window_impl_get_type (), NULL);
-  private->impl_window = private;
-
-  draw_impl = GDK_DRAWABLE_IMPL_WIN32 (private->impl);
-  
-  draw_impl->handle = GetDesktopWindow ();
-  draw_impl->wrapper = GDK_DRAWABLE (private);
-  draw_impl->colormap = gdk_screen_get_default_colormap (_gdk_screen);
-  g_object_ref (draw_impl->colormap);
-  
-  private->window_type = GDK_WINDOW_ROOT;
-  private->depth = gdk_visual_get_system ()->depth;
-
-  _gdk_root_window_size_init ();
-
-  private->x = 0;
-  private->y = 0;
-  private->abs_x = 0;
-  private->abs_y = 0;
-  /* width and height already initialised in _gdk_root_window_size_init() */
-  private->viewable = TRUE;
-
-  gdk_win32_handle_table_insert ((HANDLE *) &draw_impl->handle, _gdk_root);
-
-  GDK_NOTE (MISC, g_print ("_gdk_root=%p\n", GDK_WINDOW_HWND (_gdk_root)));
-}
-
-static const gchar *
-get_default_title (void)
-{
-  const char *title;
-  title = g_get_application_name ();
-  if (!title)
-    title = g_get_prgname ();
-
-  return title;
-}
-
-/* RegisterGdkClass
- *   is a wrapper function for RegisterWindowClassEx.
- *   It creates at least one unique class for every 
- *   GdkWindowType. If support for single window-specific icons
- *   is ever needed (e.g Dialog specific), every such window should
- *   get its own class
- */
-static ATOM
-RegisterGdkClass (GdkWindowType wtype, GdkWindowTypeHint wtype_hint)
-{
-  static ATOM klassTOPLEVEL   = 0;
-  static ATOM klassDIALOG     = 0;
-  static ATOM klassCHILD      = 0;
-  static ATOM klassTEMP       = 0;
-  static ATOM klassTEMPSHADOW = 0;
-  static HICON hAppIcon = NULL;
-  static HICON hAppIconSm = NULL;
-  static WNDCLASSEXW wcl; 
-  ATOM klass = 0;
-
-  wcl.cbSize = sizeof (WNDCLASSEX);
-  wcl.style = 0; /* DON'T set CS_<H,V>REDRAW. It causes total redraw
-                  * on WM_SIZE and WM_MOVE. Flicker, Performance!
-                  */
-  wcl.lpfnWndProc = _gdk_win32_window_procedure;
-  wcl.cbClsExtra = 0;
-  wcl.cbWndExtra = 0;
-  wcl.hInstance = _gdk_app_hmodule;
-  wcl.hIcon = 0;
-  wcl.hIconSm = 0;
-
-  /* initialize once! */
-  if (0 == hAppIcon && 0 == hAppIconSm)
-    {
-      gchar sLoc [MAX_PATH+1];
-
-      if (0 != GetModuleFileName (_gdk_app_hmodule, sLoc, MAX_PATH))
-        {
-          ExtractIconEx (sLoc, 0, &hAppIcon, &hAppIconSm, 1);
-
-          if (0 == hAppIcon && 0 == hAppIconSm)
-            {
-              if (0 != GetModuleFileName (_gdk_dll_hinstance, sLoc, MAX_PATH))
-		{
-		  ExtractIconEx (sLoc, 0, &hAppIcon, &hAppIconSm, 1);
-		}
-            }
-        }
-
-      if (0 == hAppIcon && 0 == hAppIconSm)
-        {
-          hAppIcon = LoadImage (NULL, IDI_APPLICATION, IMAGE_ICON,
-                                GetSystemMetrics (SM_CXICON),
-                                GetSystemMetrics (SM_CYICON), 0);
-          hAppIconSm = LoadImage (NULL, IDI_APPLICATION, IMAGE_ICON,
-                                  GetSystemMetrics (SM_CXSMICON),
-                                  GetSystemMetrics (SM_CYSMICON), 0);
-        }
-    }
-
-  if (0 == hAppIcon)
-    hAppIcon = hAppIconSm;
-  else if (0 == hAppIconSm)
-    hAppIconSm = hAppIcon;
-
-  wcl.lpszMenuName = NULL;
-
-  /* initialize once per class */
-  /*
-   * HB: Setting the background brush leads to flicker, because we
-   * don't get asked how to clear the background. This is not what
-   * we want, at least not for input_only windows ...
-   */
-#define ONCE_PER_CLASS() \
-  wcl.hIcon = CopyIcon (hAppIcon); \
-  wcl.hIconSm = CopyIcon (hAppIconSm); \
-  wcl.hbrBackground = NULL; \
-  wcl.hCursor = LoadCursor (NULL, IDC_ARROW); 
-  
-  switch (wtype)
-    {
-    case GDK_WINDOW_TOPLEVEL:
-      if (0 == klassTOPLEVEL)
-	{
-	  wcl.lpszClassName = L"gdkWindowToplevel";
-	  
-	  ONCE_PER_CLASS ();
-	  klassTOPLEVEL = RegisterClassExW (&wcl);
-	}
-      klass = klassTOPLEVEL;
-      break;
-      
-    case GDK_WINDOW_CHILD:
-      if (0 == klassCHILD)
-	{
-	  wcl.lpszClassName = L"gdkWindowChild";
-	  
-	  wcl.style |= CS_PARENTDC; /* MSDN: ... enhances system performance. */
-	  ONCE_PER_CLASS ();
-	  klassCHILD = RegisterClassExW (&wcl);
-	}
-      klass = klassCHILD;
-      break;
-      
-    case GDK_WINDOW_DIALOG:
-      if (0 == klassDIALOG)
-	{
-	  wcl.lpszClassName = L"gdkWindowDialog";
-	  wcl.style |= CS_SAVEBITS;
-	  ONCE_PER_CLASS ();
-	  klassDIALOG = RegisterClassExW (&wcl);
-	}
-      klass = klassDIALOG;
-      break;
-      
-    case GDK_WINDOW_TEMP:
-      if ((wtype_hint == GDK_WINDOW_TYPE_HINT_MENU) ||
-          (wtype_hint == GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU) ||
-          (wtype_hint == GDK_WINDOW_TYPE_HINT_POPUP_MENU) ||
-          (wtype_hint == GDK_WINDOW_TYPE_HINT_TOOLTIP))
-        {
-          if (klassTEMPSHADOW == 0)
-            {
-              wcl.lpszClassName = L"gdkWindowTempShadow";
-              wcl.style |= CS_SAVEBITS;
-              if (LOBYTE (g_win32_get_windows_version()) > 0x05 ||
-		  LOWORD (g_win32_get_windows_version()) == 0x0105)
-		{
-		  /* Windows XP (5.1) or above */
-		  wcl.style |= 0x00020000; /* CS_DROPSHADOW */
-		}
-              ONCE_PER_CLASS ();
-              klassTEMPSHADOW = RegisterClassExW (&wcl);
-            }
-
-          klass = klassTEMPSHADOW;
-        }
-       else
-        {
-          if (klassTEMP == 0)
-            {
-              wcl.lpszClassName = L"gdkWindowTemp";
-              wcl.style |= CS_SAVEBITS;
-              ONCE_PER_CLASS ();
-              klassTEMP = RegisterClassExW (&wcl);
-            }
-
-          klass = klassTEMP;
-        }
-      break;
-      
-    default:
-      g_assert_not_reached ();
-      break;
-    }
-  
-  if (klass == 0)
-    {
-      WIN32_API_FAILED ("RegisterClassExW");
-      g_error ("That is a fatal error");
-    }
-  return klass;
-}
-
-/*
- * Create native windows.
- *
- * With the default Gdk the created windows are mostly toplevel windows.
- * A lot of child windows are only created for GDK_NATIVE_WINDOWS.
- *
- * Placement of the window is derived from the passed in window,
- * except for toplevel window where OS/Window Manager placement
- * is used.
- *
- * The visual parameter, is based on GDK_WA_VISUAL if set already.
- * From attributes the only things used is: colormap, title, 
- * wmclass and type_hint. [1]. We are checking redundant information
- * and complain if that changes, which would break this implementation
- * again.
- *
- * [1] http://mail.gnome.org/archives/gtk-devel-list/2010-August/msg00214.html
- */
-void
-_gdk_window_impl_new (GdkWindow     *window,
-		      GdkWindow     *real_parent,
-		      GdkScreen     *screen,
-		      GdkVisual     *visual,
-		      GdkEventMask   event_mask,
-		      GdkWindowAttr *attributes,
-		      gint           attributes_mask)
-{
-  HWND hwndNew;
-  HANDLE hparent;
-  ATOM klass = 0;
-  DWORD dwStyle = 0, dwExStyle;
-  RECT rect;
-  GdkWindowObject *private;
-  GdkWindowImplWin32 *impl;
-  GdkDrawableImplWin32 *draw_impl;
-  const gchar *title;
-  wchar_t *wtitle;
-  gboolean override_redirect;
-  gint window_width, window_height;
-  gint offset_x = 0, offset_y = 0;
-  gint x, y, real_x = 0, real_y = 0;
-  /* check consistency of redundant information */
-  guint remaining_mask = attributes_mask;
-
-  private = (GdkWindowObject *)window;
-
-  GDK_NOTE (MISC,
-	    g_print ("_gdk_window_impl_new: %s %s\n",
-		     (private->window_type == GDK_WINDOW_TOPLEVEL ? "TOPLEVEL" :
-		      (private->window_type == GDK_WINDOW_CHILD ? "CHILD" :
-		       (private->window_type == GDK_WINDOW_DIALOG ? "DIALOG" :
-			(private->window_type == GDK_WINDOW_TEMP ? "TEMP" :
-			 "???")))),
-		     (attributes->wclass == GDK_INPUT_OUTPUT ? "" : "input-only"))
-			   );
-
-  /* to ensure to not miss important information some additional check against
-   * attributes which may silently work on X11 */
-  if ((attributes_mask & GDK_WA_X) != 0)
-    {
-      g_assert (attributes->x == private->x);
-      remaining_mask &= ~GDK_WA_X;
-    }
-  if ((attributes_mask & GDK_WA_Y) != 0)
-    {
-      g_assert (attributes->y == private->y);
-      remaining_mask &= ~GDK_WA_Y;
-    }
-  override_redirect = FALSE;
-  if ((attributes_mask & GDK_WA_NOREDIR) != 0)
-    {
-      override_redirect = !!attributes->override_redirect;
-      remaining_mask &= ~GDK_WA_NOREDIR;
-    }
-
-  if ((remaining_mask & ~(GDK_WA_WMCLASS|GDK_WA_VISUAL|GDK_WA_CURSOR|GDK_WA_COLORMAP|GDK_WA_TITLE|GDK_WA_TYPE_HINT)) != 0)
-    g_warning ("_gdk_window_impl_new: uexpected attribute 0x%X",
-               remaining_mask & ~(GDK_WA_WMCLASS|GDK_WA_VISUAL|GDK_WA_CURSOR|GDK_WA_COLORMAP|GDK_WA_TITLE|GDK_WA_TYPE_HINT));
-
-  hparent = GDK_WINDOW_HWND (real_parent);
-
-  impl = g_object_new (_gdk_window_impl_get_type (), NULL);
-  private->impl = (GdkDrawable *)impl;
-  draw_impl = GDK_DRAWABLE_IMPL_WIN32 (impl);
-  draw_impl->wrapper = GDK_DRAWABLE (window);
-
-  if (attributes_mask & GDK_WA_VISUAL)
-    g_assert (visual == attributes->visual);
-
-  impl->extension_events_mask = 0;
-  impl->override_redirect = override_redirect;
-
-  /* wclass is not any longer set always, but if is ... */
-  if ((attributes_mask & GDK_WA_WMCLASS) == GDK_WA_WMCLASS)
-    g_assert ((attributes->wclass == GDK_INPUT_OUTPUT) == !private->input_only);
-
-  if (!private->input_only)
-    {
-      dwExStyle = 0;
-
-      private->input_only = FALSE;
-      private->depth = visual->depth;
-      
-      if (attributes_mask & GDK_WA_COLORMAP)
-	{
-	  draw_impl->colormap = attributes->colormap;
-	  g_object_ref (attributes->colormap);
-	}
-      else
-	{
-	  draw_impl->colormap = gdk_screen_get_system_colormap (_gdk_screen);
-	  g_object_ref (draw_impl->colormap);
-	}
-    }
-  else
-    {
-      /* I very much doubt using WS_EX_TRANSPARENT actually
-       * corresponds to how X11 InputOnly windows work, but it appears
-       * to work well enough for the actual use cases in gtk.
-       */
-      dwExStyle = WS_EX_TRANSPARENT;
-      private->depth = 0; /* xxx: was 0 for years */
-      private->input_only = TRUE;
-      draw_impl->colormap = gdk_screen_get_system_colormap (_gdk_screen);
-      g_object_ref (draw_impl->colormap);
-      GDK_NOTE (MISC, g_print ("... GDK_INPUT_ONLY, system colormap\n"));
-    }
-
-  if (attributes_mask & GDK_WA_TITLE)
-    title = attributes->title;
-  else
-    title = get_default_title ();
-  if (!title || !*title)
-    title = "";
-
-  impl->native_event_mask = GDK_STRUCTURE_MASK | event_mask;
-      
-  if (attributes_mask & GDK_WA_TYPE_HINT)
-    gdk_window_set_type_hint (window, attributes->type_hint);
-
-  if (impl->type_hint == GDK_WINDOW_TYPE_HINT_UTILITY)
-    dwExStyle |= WS_EX_TOOLWINDOW;
-
-  switch (private->window_type)
-    {
-    case GDK_WINDOW_TOPLEVEL:
-    case GDK_WINDOW_DIALOG:
-      if (GDK_WINDOW_TYPE (private->parent) != GDK_WINDOW_ROOT)
-	{
-	  /* The common code warns for this case. */
-	  hparent = GetDesktopWindow ();
-	}
-      /* Children of foreign windows aren't toplevel windows */
-      if (GDK_WINDOW_TYPE (real_parent) == GDK_WINDOW_FOREIGN)
-	{
-	  dwStyle = WS_CHILDWINDOW | WS_CLIPCHILDREN;
-	}
-      else
-	{
-	  if (private->window_type == GDK_WINDOW_TOPLEVEL)
-	    dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
-	  else
-	    dwStyle = WS_OVERLAPPED | WS_MINIMIZEBOX | WS_SYSMENU | WS_CAPTION | WS_THICKFRAME | WS_CLIPCHILDREN;
-
-	  offset_x = _gdk_offset_x;
-	  offset_y = _gdk_offset_y;
-	}
-      break;
-
-    case GDK_WINDOW_CHILD:
-      dwStyle = WS_CHILDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
-      break;
-
-    case GDK_WINDOW_TEMP:
-      /* A temp window is not necessarily a top level window */
-      dwStyle = (_gdk_root == real_parent ? WS_POPUP : WS_CHILDWINDOW);
-      dwStyle |= WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
-      dwExStyle |= WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
-      offset_x = _gdk_offset_x;
-      offset_y = _gdk_offset_y;
-      break;
-
-    default:
-      g_assert_not_reached ();
-    }
-
-  if (private->window_type != GDK_WINDOW_CHILD)
-    {
-      rect.left = private->x;
-      rect.top = private->y;
-      rect.right = private->width + private->x;
-      rect.bottom = private->height + private->y;
-
-      AdjustWindowRectEx (&rect, dwStyle, FALSE, dwExStyle);
-
-      real_x = private->x - offset_x;
-      real_y = private->y - offset_y;
-
-      if (private->window_type == GDK_WINDOW_TOPLEVEL ||
-	  private->window_type == GDK_WINDOW_DIALOG)
-	{
-	  /* We initially place it at default so that we can get the
-	     default window positioning if we want */
-	  x = y = CW_USEDEFAULT;
-	}
-      else
-	{
-	  /* TEMP, FOREIGN: Put these where requested */
-	  x = real_x;
-	  y = real_y;
-	}
-
-      window_width = rect.right - rect.left;
-      window_height = rect.bottom - rect.top;
-    }
-  else
-    {
-      /* adjust position relative to real_parent */
-      window_width = private->width;
-      window_height = private->height;
-      /* use given position for initial placement, native coordinates */
-      x = private->x + private->parent->abs_x - offset_x;
-      y = private->y + private->parent->abs_y - offset_y;
-    }
-
-  klass = RegisterGdkClass (private->window_type, impl->type_hint);
-
-  wtitle = g_utf8_to_utf16 (title, -1, NULL, NULL, NULL);
-  
-  hwndNew = CreateWindowExW (dwExStyle,
-			     MAKEINTRESOURCEW (klass),
-			     wtitle,
-			     dwStyle,
-			     x,
-			     y,
-			     window_width, window_height,
-			     hparent,
-			     NULL,
-			     _gdk_app_hmodule,
-			     window);
-  if (GDK_WINDOW_HWND (window) != hwndNew)
-    {
-      g_warning ("gdk_window_new: gdk_event_translate::WM_CREATE (%p, %p) HWND mismatch.",
-		 GDK_WINDOW_HWND (window),
-		 hwndNew);
-
-      /* HB: IHMO due to a race condition the handle was increased by
-       * one, which causes much trouble. Because I can't find the 
-       * real bug, try to workaround it ...
-       * To reproduce: compile with MSVC 5, DEBUG=1
-       */
-# if 0
-      gdk_win32_handle_table_remove (GDK_WINDOW_HWND (window));
-      GDK_WINDOW_HWND (window) = hwndNew;
-      gdk_win32_handle_table_insert (&GDK_WINDOW_HWND (window), window);
-# else
-      /* the old behaviour, but with warning */
-      draw_impl->handle = hwndNew;
-# endif
-
-    }
-
-  if (private->window_type != GDK_WINDOW_CHILD)
-    {
-      GetWindowRect (GDK_WINDOW_HWND (window), &rect);
-      impl->initial_x = rect.left;
-      impl->initial_y = rect.top;
-
-      /* Now we know the initial position, move to actually specified position */
-      if (real_x != x || real_y != y)
-	{
-	  API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), NULL,
-				   real_x, real_y, 0, 0,
-				   SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER));
-	}
-    }
-
-  g_object_ref (window);
-  gdk_win32_handle_table_insert (&GDK_WINDOW_HWND (window), window);
-
-  GDK_NOTE (MISC, g_print ("... \"%s\" %dx%d@%+d%+d %p = %p\n",
-			   title,
-			   window_width, window_height,
-			   private->x - offset_x,
-			   private->y - offset_y, 
-			   hparent,
-			   GDK_WINDOW_HWND (window)));
-
-  /* Add window handle to title */
-  GDK_NOTE (MISC_OR_EVENTS, gdk_window_set_title (window, title));
-
-  g_free (wtitle);
-
-  if (draw_impl->handle == NULL)
-    {
-      WIN32_API_FAILED ("CreateWindowExW");
-      g_object_unref (window);
-      return;
-    }
-
-//  if (!from_set_skip_taskbar_hint && private->window_type == GDK_WINDOW_TEMP)
-//    gdk_window_set_skip_taskbar_hint (window, TRUE);
-
-  if (attributes_mask & GDK_WA_CURSOR)
-    gdk_window_set_cursor (window, attributes->cursor);
-}
-
-GdkWindow *
-gdk_window_foreign_new_for_display (GdkDisplay      *display,
-                                    GdkNativeWindow  anid)
-{
-  return gdk_win32_window_foreign_new_for_display (display, anid);
-}
-
-GdkWindow *
-gdk_win32_window_foreign_new_for_display (GdkDisplay      *display,
-                                          GdkNativeWindow  anid)
-{
-  GdkWindow *window;
-  GdkWindowObject *private;
-  GdkWindowImplWin32 *impl;
-  GdkDrawableImplWin32 *draw_impl;
-
-  HANDLE parent;
-  RECT rect;
-  POINT point;
-
-  g_return_val_if_fail (display == _gdk_display, NULL);
-
-  window = g_object_new (GDK_TYPE_WINDOW, NULL);
-  private = (GdkWindowObject *)window;
-  private->impl = g_object_new (_gdk_window_impl_get_type (), NULL);
-  impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-  draw_impl = GDK_DRAWABLE_IMPL_WIN32 (private->impl);
-  draw_impl->wrapper = GDK_DRAWABLE (window);
-  parent = GetParent ((HWND)anid);
-  
-  private->parent = gdk_win32_handle_table_lookup ((GdkNativeWindow) parent);
-  if (!private->parent || GDK_WINDOW_TYPE (private->parent) == GDK_WINDOW_FOREIGN)
-    private->parent = (GdkWindowObject *)_gdk_root;
-  
-  private->parent->children = g_list_prepend (private->parent->children, window);
-
-  draw_impl->handle = (HWND) anid;
-  GetClientRect ((HWND) anid, &rect);
-  point.x = rect.left;
-  point.y = rect.right;
-  ClientToScreen ((HWND) anid, &point);
-  if (parent != GetDesktopWindow ())
-    ScreenToClient (parent, &point);
-  private->x = point.x;
-  private->y = point.y;
-  private->width = rect.right - rect.left;
-  private->height = rect.bottom - rect.top;
-  private->window_type = GDK_WINDOW_FOREIGN;
-  private->destroyed = FALSE;
-  private->event_mask = GDK_ALL_EVENTS_MASK; /* XXX */
-  if (IsWindowVisible ((HWND) anid))
-    private->state &= (~GDK_WINDOW_STATE_WITHDRAWN);
-  else
-    private->state |= GDK_WINDOW_STATE_WITHDRAWN;
-  if (GetWindowLong ((HWND)anid, GWL_EXSTYLE) & WS_EX_TOPMOST)
-    private->state |= GDK_WINDOW_STATE_ABOVE;
-  else
-    private->state &= (~GDK_WINDOW_STATE_ABOVE);
-  private->state &= (~GDK_WINDOW_STATE_BELOW);
-  private->viewable = TRUE;
-
-  private->depth = gdk_visual_get_system ()->depth;
-
-  g_object_ref (window);
-  gdk_win32_handle_table_insert (&GDK_WINDOW_HWND (window), window);
-
-  GDK_NOTE (MISC, g_print ("gdk_window_foreign_new_for_display: %p: %s@%+d%+d\n",
-			   (HWND) anid,
-			   _gdk_win32_drawable_description (window),
-			   private->x, private->y));
-
-  return window;
-}
-
-GdkWindow*
-gdk_window_lookup (GdkNativeWindow hwnd)
-{
-  return (GdkWindow*) gdk_win32_handle_table_lookup (hwnd); 
-}
-
-void
-_gdk_win32_window_destroy (GdkWindow *window,
-			   gboolean   recursing,
-			   gboolean   foreign_destroy)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-  GdkWindowImplWin32 *window_impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-  GSList *tmp;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  GDK_NOTE (MISC, g_print ("_gdk_win32_window_destroy: %p\n",
-			   GDK_WINDOW_HWND (window)));
-
-  /* Remove ourself from the modal stack */
-  _gdk_remove_modal_window (window);
-
-  /* Remove all our transient children */
-  tmp = window_impl->transient_children;
-  while (tmp != NULL)
-    {
-      GdkWindow *child = tmp->data;
-      GdkWindowImplWin32 *child_impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (child)->impl);
-
-      child_impl->transient_owner = NULL;
-      tmp = g_slist_next (tmp);
-    }
-  g_slist_free (window_impl->transient_children);
-  window_impl->transient_children = NULL;
-
-  /* Remove ourself from our transient owner */
-  if (window_impl->transient_owner != NULL)
-    {
-      gdk_window_set_transient_for (window, NULL);
-    }
-
-  if (!recursing && !foreign_destroy)
-    {
-      _gdk_win32_drawable_finish (private->impl);
-
-      private->destroyed = TRUE;
-      DestroyWindow (GDK_WINDOW_HWND (window));
-    }
-}
-
-void
-_gdk_windowing_window_destroy_foreign (GdkWindow *window)
-{
-  /* It's somebody else's window, but in our hierarchy, so reparent it
-   * to the desktop, and then try to destroy it.
-   */
-  gdk_window_hide (window);
-  gdk_window_reparent (window, NULL, 0, 0);
-  
-  PostMessage (GDK_WINDOW_HWND (window), WM_CLOSE, 0, 0);
-}
-
-/* This function is called when the window really gone.
- */
-void
-gdk_window_destroy_notify (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  GDK_NOTE (EVENTS,
-	    g_print ("gdk_window_destroy_notify: %p%s\n",
-		     GDK_WINDOW_HWND (window),
-		     (GDK_WINDOW_DESTROYED (window) ? " (destroyed)" : "")));
-
-  if (!GDK_WINDOW_DESTROYED (window))
-    {
-      if (GDK_WINDOW_TYPE (window) != GDK_WINDOW_FOREIGN)
-	g_warning ("window %p unexpectedly destroyed",
-		   GDK_WINDOW_HWND (window));
-
-      _gdk_window_destroy (window, TRUE);
-    }
-  
-  gdk_win32_handle_table_remove (GDK_WINDOW_HWND (window));
-  g_object_unref (window);
-}
-
-static void
-get_outer_rect (GdkWindow *window,
-		gint       width,
-		gint       height,
-		RECT      *rect)
-{
-  rect->left = rect->top = 0;
-  rect->right = width;
-  rect->bottom = height;
-      
-  _gdk_win32_adjust_client_rect (window, rect);
-}
-
-static void
-adjust_for_gravity_hints (GdkWindow *window,
-			  RECT      *outer_rect,
-			  gint		*x,
-			  gint		*y)
-{
-	GdkWindowObject *obj;
-	GdkWindowImplWin32 *impl;
-
-	obj = GDK_WINDOW_OBJECT (window);
-	impl = GDK_WINDOW_IMPL_WIN32 (obj->impl);
-
-  if (impl->hint_flags & GDK_HINT_WIN_GRAVITY)
-    {
-#ifdef G_ENABLE_DEBUG
-      gint orig_x = *x, orig_y = *y;
-#endif
-
-      switch (impl->hints.win_gravity)
-	{
-	case GDK_GRAVITY_NORTH:
-	case GDK_GRAVITY_CENTER:
-	case GDK_GRAVITY_SOUTH:
-	  *x -= (outer_rect->right - outer_rect->left) / 2;
-	  *x += obj->width / 2;
-	  break;
-	      
-	case GDK_GRAVITY_SOUTH_EAST:
-	case GDK_GRAVITY_EAST:
-	case GDK_GRAVITY_NORTH_EAST:
-	  *x -= outer_rect->right - outer_rect->left;
-	  *x += obj->width;
-	  break;
-
-	case GDK_GRAVITY_STATIC:
-	  *x += outer_rect->left;
-	  break;
-
-	default:
-	  break;
-	}
-
-      switch (impl->hints.win_gravity)
-	{
-	case GDK_GRAVITY_WEST:
-	case GDK_GRAVITY_CENTER:
-	case GDK_GRAVITY_EAST:
-	  *y -= (outer_rect->bottom - outer_rect->top) / 2;
-	  *y += obj->height / 2;
-	  break;
-
-	case GDK_GRAVITY_SOUTH_WEST:
-	case GDK_GRAVITY_SOUTH:
-	case GDK_GRAVITY_SOUTH_EAST:
-	  *y -= outer_rect->bottom - outer_rect->top;
-	  *y += obj->height;
-	  break;
-
-	case GDK_GRAVITY_STATIC:
-	  *y += outer_rect->top;
-	  break;
-
-	default:
-	  break;
-	}
-      GDK_NOTE (MISC,
-		(orig_x != *x || orig_y != *y) ?
-		g_print ("adjust_for_gravity_hints: x: %d->%d, y: %d->%d\n",
-			 orig_x, *x, orig_y, *y)
-		  : (void) 0);
-    }
-}
-
-static void
-show_window_internal (GdkWindow *window,
-                      gboolean   already_mapped,
-		      gboolean   deiconify)
-{
-  GdkWindowObject *private;
-  GdkWindowImplWin32 *window_impl;
-  gboolean focus_on_map = FALSE;
-  DWORD exstyle;
-
-  private = (GdkWindowObject *) window;
-
-  if (private->destroyed)
-    return;
-
-  GDK_NOTE (MISC, g_print ("show_window_internal: %p: %s%s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (private->state),
-			   (deiconify ? " deiconify" : "")));
-  
-  /* If asked to show (not deiconify) an withdrawn and iconified
-   * window, do that.
-   */
-  if (!deiconify &&
-      !already_mapped &&
-      (private->state & GDK_WINDOW_STATE_ICONIFIED))
-    {	
-      ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWMINNOACTIVE);
-      return;
-    }
-  
-  /* If asked to just show an iconified window, do nothing. */
-  if (!deiconify && (private->state & GDK_WINDOW_STATE_ICONIFIED))
-    return;
-  
-  /* If asked to deiconify an already noniconified window, do
-   * nothing. (Especially, don't cause the window to rise and
-   * activate. There are different calls for that.)
-   */
-  if (deiconify && !(private->state & GDK_WINDOW_STATE_ICONIFIED))
-    return;
-  
-  /* If asked to show (but not raise) a window that is already
-   * visible, do nothing.
-   */
-  if (!deiconify && !already_mapped && IsWindowVisible (GDK_WINDOW_HWND (window)))
-    return;
-
-  /* Other cases */
-  
-  if (!already_mapped)
-    focus_on_map = private->focus_on_map;
-
-  exstyle = GetWindowLong (GDK_WINDOW_HWND (window), GWL_EXSTYLE);
-
-  /* Use SetWindowPos to show transparent windows so automatic redraws
-   * in other windows can be suppressed.
-   */
-  if (exstyle & WS_EX_TRANSPARENT)
-    {
-      UINT flags = SWP_SHOWWINDOW | SWP_NOREDRAW | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER;
-
-      if (GDK_WINDOW_TYPE (window) == GDK_WINDOW_TEMP || !focus_on_map)
-	flags |= SWP_NOACTIVATE;
-
-      SetWindowPos (GDK_WINDOW_HWND (window), HWND_TOP, 0, 0, 0, 0, flags);
-
-      return;
-    }
-
-  /* For initial map of "normal" windows we want to emulate WM window
-   * positioning behaviour, which means: 
-   * + Use user specified position if GDK_HINT_POS or GDK_HINT_USER_POS
-   * otherwise:
-   * + default to the initial CW_USEDEFAULT placement,
-   *   no matter if the user moved the window before showing it.
-   * + Certain window types and hints have more elaborate positioning
-   *   schemes.
-   */
-  window_impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-  if (!already_mapped &&
-      (GDK_WINDOW_TYPE (window) == GDK_WINDOW_TOPLEVEL ||
-       GDK_WINDOW_TYPE (window) == GDK_WINDOW_DIALOG) &&
-      (window_impl->hint_flags & (GDK_HINT_POS | GDK_HINT_USER_POS)) == 0 &&
-      !window_impl->override_redirect)
-    {
-      gboolean center = FALSE;
-      RECT window_rect, center_on_rect;
-      int x, y;
-
-      x = window_impl->initial_x;
-      y = window_impl->initial_y;
-
-      if (window_impl->type_hint == GDK_WINDOW_TYPE_HINT_SPLASHSCREEN)
-	{
-	  HMONITOR monitor;
-	  MONITORINFO mi;
-
-	  monitor = MonitorFromWindow (GDK_WINDOW_HWND (window), MONITOR_DEFAULTTONEAREST);
-	  mi.cbSize = sizeof (mi);
-	  if (monitor && GetMonitorInfo (monitor, &mi))
-	    center_on_rect = mi.rcMonitor;
-	  else
-	    {
-	      center_on_rect.left = 0;
-	      center_on_rect.right = 0;
-	      center_on_rect.right = GetSystemMetrics (SM_CXSCREEN);
-	      center_on_rect.bottom = GetSystemMetrics (SM_CYSCREEN);
-	    }
-	  center = TRUE;
-	}
-      else if (window_impl->transient_owner != NULL &&
-	       GDK_WINDOW_IS_MAPPED (window_impl->transient_owner))
-	{
-	  GdkWindowObject *owner = GDK_WINDOW_OBJECT (window_impl->transient_owner);
-	  /* Center on transient parent */
-	  center_on_rect.left = owner->x;
-	  center_on_rect.top = owner->y;
-	  center_on_rect.right = center_on_rect.left + owner->width;
-	  center_on_rect.bottom = center_on_rect.top + owner->height;
-	  _gdk_win32_adjust_client_rect (GDK_WINDOW (owner), &center_on_rect);
-	  center = TRUE;
-	}
-
-      if (center) 
-	{
-	  window_rect.left = 0;
-	  window_rect.top = 0;
-	  window_rect.right = private->width;
-	  window_rect.bottom = private->height;
-	  _gdk_win32_adjust_client_rect (window, &window_rect);
-
-	  x = center_on_rect.left + ((center_on_rect.right - center_on_rect.left) - (window_rect.right - window_rect.left)) / 2;
-	  y = center_on_rect.top + ((center_on_rect.bottom - center_on_rect.top) - (window_rect.bottom - window_rect.top)) / 2;
-	}
-
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), NULL,
-			       x, y, 0, 0,
-			       SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER));
-    }
-
-  if (!already_mapped &&
-      (GDK_WINDOW_TYPE (window) == GDK_WINDOW_TOPLEVEL ||
-       GDK_WINDOW_TYPE (window) == GDK_WINDOW_DIALOG) &&
-      !window_impl->override_redirect)
-    {
-      /* Ensure new windows are fully onscreen */
-      RECT window_rect;
-      HMONITOR monitor;
-      MONITORINFO mi;
-      int x, y;
-
-      GetWindowRect (GDK_WINDOW_HWND (window), &window_rect);
-
-      monitor = MonitorFromWindow (GDK_WINDOW_HWND (window), MONITOR_DEFAULTTONEAREST);
-      mi.cbSize = sizeof (mi);
-      if (monitor && GetMonitorInfo (monitor, &mi))
-	{
-	  x = window_rect.left;
-	  y = window_rect.top;
-
-	  if (window_rect.right > mi.rcWork.right)
-	    {
-	      window_rect.left -= (window_rect.right - mi.rcWork.right);
-	      window_rect.right -= (window_rect.right - mi.rcWork.right);
-	    }
-
-	  if (window_rect.bottom > mi.rcWork.bottom)
-	    {
-	      window_rect.top -= (window_rect.bottom - mi.rcWork.bottom);
-	      window_rect.bottom -= (window_rect.bottom - mi.rcWork.bottom);
-	    }
-
-	  if (window_rect.left < mi.rcWork.left)
-	    {
-	      window_rect.right += (mi.rcWork.left - window_rect.left);
-	      window_rect.left += (mi.rcWork.left - window_rect.left);
-	    }
-
-	  if (window_rect.top < mi.rcWork.top)
-	    {
-	      window_rect.bottom += (mi.rcWork.top - window_rect.top);
-	      window_rect.top += (mi.rcWork.top - window_rect.top);
-	    }
-
-	  if (x != window_rect.left || y != window_rect.top)
-	    API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), NULL,
-				     window_rect.left, window_rect.top, 0, 0,
-				     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER));
-	}
-    }
-
-
-  if (private->state & GDK_WINDOW_STATE_FULLSCREEN)
-    {
-      gdk_window_fullscreen (window);
-    }
-  else if (private->state & GDK_WINDOW_STATE_MAXIMIZED)
-    {
-      ShowWindow (GDK_WINDOW_HWND (window), SW_MAXIMIZE);
-    }
-  else if (private->state & GDK_WINDOW_STATE_ICONIFIED)
-    {
-      if (focus_on_map)
-	ShowWindow (GDK_WINDOW_HWND (window), SW_RESTORE);
-      else
-	ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWNOACTIVATE);
-    }
-  else if (GDK_WINDOW_TYPE (window) == GDK_WINDOW_TEMP || !focus_on_map)
-    {
-      if (!IsWindowVisible (GDK_WINDOW_HWND (window)))
-        ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWNOACTIVATE);
-      else
-        ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWNA);
-    }
-  else if (!IsWindowVisible (GDK_WINDOW_HWND (window)))
-    {
-      ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWNORMAL);
-    }
-  else
-    {
-      ShowWindow (GDK_WINDOW_HWND (window), SW_SHOW);
-    }
-
-  /* Sync STATE_ABOVE to TOPMOST */
-  if (GDK_WINDOW_TYPE (window) != GDK_WINDOW_TEMP &&
-      (((private->state & GDK_WINDOW_STATE_ABOVE) &&
-       !(exstyle & WS_EX_TOPMOST)) ||
-      (!(private->state & GDK_WINDOW_STATE_ABOVE) &&
-       (exstyle & WS_EX_TOPMOST))))
-    {
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window),
-			       (private->state & GDK_WINDOW_STATE_ABOVE)?HWND_TOPMOST:HWND_NOTOPMOST,
-			       0, 0, 0, 0,
-			       SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE));
-    }
-}
-
-static void
-gdk_win32_window_show (GdkWindow *window, 
-		       gboolean already_mapped)
-{
-  show_window_internal (window, already_mapped, FALSE);
-}
-
-static void
-gdk_win32_window_hide (GdkWindow *window)
-{
-  GdkWindowObject *private;
-  
-  private = (GdkWindowObject*) window;
-  if (private->destroyed)
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_hide: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (private->state)));
-  
-  if (GDK_WINDOW_IS_MAPPED (window))
-    gdk_synthesize_window_state (window,
-				 0,
-				 GDK_WINDOW_STATE_WITHDRAWN);
-  
-  _gdk_window_clear_update_area (window);
-  
-  if (GDK_WINDOW_TYPE (window) == GDK_WINDOW_TOPLEVEL)
-    ShowOwnedPopups (GDK_WINDOW_HWND (window), FALSE);
-  
-  if (GetWindowLong (GDK_WINDOW_HWND (window), GWL_EXSTYLE) & WS_EX_TRANSPARENT)
-    {
-      SetWindowPos (GDK_WINDOW_HWND (window), HWND_BOTTOM,
-		    0, 0, 0, 0,
-		    SWP_HIDEWINDOW | SWP_NOREDRAW | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE);
-    }
-  else
-    {
-      ShowWindow (GDK_WINDOW_HWND (window), SW_HIDE);
-    }
-}
-
-static void
-gdk_win32_window_withdraw (GdkWindow *window)
-{
-  GdkWindowObject *private;
-  
-  private = (GdkWindowObject*) window;
-  if (private->destroyed)
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_withdraw: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (private->state)));
-  
-  gdk_window_hide (window);	/* ??? */
-}
-
-static void
-gdk_win32_window_move (GdkWindow *window,
-		       gint x, gint y)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-  GdkWindowImplWin32 *impl;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_move: %p: %+d%+d\n",
-                           GDK_WINDOW_HWND (window), x, y));
-
-  impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-
-  if (private->state & GDK_WINDOW_STATE_FULLSCREEN)
-    return;
-
-  /* Don't check GDK_WINDOW_TYPE (private) == GDK_WINDOW_CHILD.
-   * Foreign windows (another app's windows) might be children of our
-   * windows! Especially in the case of gtkplug/socket.
-   */
-  if (GetAncestor (GDK_WINDOW_HWND (window), GA_PARENT) != GetDesktopWindow ())
-    {
-      _gdk_window_move_resize_child (window, x, y, private->width, private->height);
-    }
-  else
-    {
-      RECT outer_rect;
-
-      get_outer_rect (window, private->width, private->height, &outer_rect);
-
-      adjust_for_gravity_hints (window, &outer_rect, &x, &y);
-
-      GDK_NOTE (MISC, g_print ("... SetWindowPos(%p,NULL,%d,%d,0,0,"
-                               "NOACTIVATE|NOSIZE|NOZORDER)\n",
-                               GDK_WINDOW_HWND (window),
-                               x - _gdk_offset_x, y - _gdk_offset_y));
-
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), NULL,
-                               x - _gdk_offset_x, y - _gdk_offset_y, 0, 0,
-                               SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER));
-    }
-}
-
-static void
-gdk_win32_window_resize (GdkWindow *window,
-			 gint width, gint height)
-{
-  GdkWindowObject *private = (GdkWindowObject*) window;
-  GdkWindowImplWin32 *impl;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  if (width < 1)
-    width = 1;
-  if (height < 1)
-    height = 1;
-
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_resize: %p: %dx%d\n",
-                           GDK_WINDOW_HWND (window), width, height));
-
-  impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-
-  if (private->state & GDK_WINDOW_STATE_FULLSCREEN)
-    return;
-
-  if (GetAncestor (GDK_WINDOW_HWND (window), GA_PARENT) != GetDesktopWindow ())
-    {
-      _gdk_window_move_resize_child (window, private->x, private->y, width, height);
-    }
-  else
-    {
-      RECT outer_rect;
-
-      get_outer_rect (window, width, height, &outer_rect);
-
-      GDK_NOTE (MISC, g_print ("... SetWindowPos(%p,NULL,0,0,%ld,%ld,"
-                               "NOACTIVATE|NOMOVE|NOZORDER)\n",
-                               GDK_WINDOW_HWND (window),
-                               outer_rect.right - outer_rect.left,
-                               outer_rect.bottom - outer_rect.top));
-
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), NULL,
-                               0, 0,
-                               outer_rect.right - outer_rect.left,
-                               outer_rect.bottom - outer_rect.top,
-                               SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER));
-      private->resize_count += 1;
-    }
-}
-
-static void
-gdk_win32_window_move_resize_internal (GdkWindow *window,
-				       gint       x,
-				       gint       y,
-				       gint       width,
-				       gint       height)
-{
-  GdkWindowObject *private;
-  GdkWindowImplWin32 *impl;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  if (width < 1)
-    width = 1;
-  if (height < 1)
-    height = 1;
-
-  private = GDK_WINDOW_OBJECT (window);
-  impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-
-  if (private->state & GDK_WINDOW_STATE_FULLSCREEN)
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_move_resize: %p: %dx%d@%+d%+d\n",
-                           GDK_WINDOW_HWND (window),
-                           width, height, x, y));
-
-  if (GetAncestor (GDK_WINDOW_HWND (window), GA_PARENT) != GetDesktopWindow ())
-    {
-      _gdk_window_move_resize_child (window, x, y, width, height);
-    }
-  else
-    {
-      RECT outer_rect;
-
-      get_outer_rect (window, width, height, &outer_rect);
-
-      adjust_for_gravity_hints (window, &outer_rect, &x, &y);
-
-      GDK_NOTE (MISC, g_print ("... SetWindowPos(%p,NULL,%d,%d,%ld,%ld,"
-                               "NOACTIVATE|NOZORDER)\n",
-                               GDK_WINDOW_HWND (window),
-                               x - _gdk_offset_x, y - _gdk_offset_y,
-                               outer_rect.right - outer_rect.left,
-                               outer_rect.bottom - outer_rect.top));
-
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), NULL,
-                               x - _gdk_offset_x, y - _gdk_offset_y,
-                               outer_rect.right - outer_rect.left,
-                               outer_rect.bottom - outer_rect.top,
-                               SWP_NOACTIVATE | SWP_NOZORDER));
-    }
-}
-
-static void
-gdk_win32_window_move_resize (GdkWindow *window,
-			      gboolean   with_move,
-			      gint       x,
-			      gint       y,
-			      gint       width,
-			      gint       height)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-  GdkWindowImplWin32 *window_impl;
-
-  window_impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-  window_impl->inhibit_configure = TRUE;
-
-  /* We ignore changes to the window being moved or resized by the 
-     user, as we don't want to fight the user */
-  if (GDK_WINDOW_HWND (window) == _modal_move_resize_window)
-    goto out;
-
-  if (with_move && (width < 0 && height < 0))
-    {
-      gdk_win32_window_move (window, x, y);
-    }
-  else
-    {
-      if (with_move)
-	{
-	  gdk_win32_window_move_resize_internal (window, x, y, width, height);
-	}
-      else
-	{
-	  gdk_win32_window_resize (window, width, height);
-	}
-    }
-
- out:
-  window_impl->inhibit_configure = FALSE;
-
-  if (WINDOW_IS_TOPLEVEL (window))
-    _gdk_win32_emit_configure_event (window);
-}
-
-static gboolean
-gdk_win32_window_reparent (GdkWindow *window,
-			   GdkWindow *new_parent,
-			   gint       x,
-			   gint       y)
-{
-  GdkWindowObject *window_private;
-  GdkWindowObject *parent_private;
-  GdkWindowObject *old_parent_private;
-  GdkWindowImplWin32 *impl;
-  gboolean was_toplevel;
-  LONG style;
-
-  if (!new_parent)
-    new_parent = _gdk_root;
-
-  window_private = (GdkWindowObject*) window;
-  old_parent_private = (GdkWindowObject *) window_private->parent;
-  parent_private = (GdkWindowObject*) new_parent;
-  impl = GDK_WINDOW_IMPL_WIN32 (window_private->impl);
-
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_reparent: %p: %p\n",
-			   GDK_WINDOW_HWND (window),
-			   GDK_WINDOW_HWND (new_parent)));
-
-  style = GetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE);
-
-  was_toplevel = GetAncestor (GDK_WINDOW_HWND (window), GA_PARENT) == GetDesktopWindow ();
-  if (was_toplevel && new_parent != _gdk_root)
-    {
-      /* Reparenting from top-level (child of desktop). Clear out
-       * decorations.
-       */
-      style &= ~(WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
-      style |= WS_CHILD;
-      SetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE, style);
-    }
-  else if (new_parent == _gdk_root)
-    {
-      /* Reparenting to top-level. Add decorations. */
-      style &= ~(WS_CHILD);
-      style |= WS_OVERLAPPEDWINDOW;
-      SetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE, style);
-    }
-
-  API_CALL (SetParent, (GDK_WINDOW_HWND (window),
-			GDK_WINDOW_HWND (new_parent)));
-  
-  API_CALL (MoveWindow, (GDK_WINDOW_HWND (window),
-			 x, y, window_private->width, window_private->height, TRUE));
-
-  /* From here on, we treat parents of type GDK_WINDOW_FOREIGN like
-   * the root window
-   */
-  if (GDK_WINDOW_TYPE (new_parent) == GDK_WINDOW_FOREIGN)
-    new_parent = _gdk_root;
-  
-  window_private->parent = (GdkWindowObject *)new_parent;
-
-  /* Switch the window type as appropriate */
-
-  switch (GDK_WINDOW_TYPE (new_parent))
-    {
-    case GDK_WINDOW_ROOT:
-      if (impl->toplevel_window_type != -1)
-	GDK_WINDOW_TYPE (window) = impl->toplevel_window_type;
-      else if (GDK_WINDOW_TYPE (window) == GDK_WINDOW_CHILD)
-	GDK_WINDOW_TYPE (window) = GDK_WINDOW_TOPLEVEL;
-      break;
-
-    case GDK_WINDOW_TOPLEVEL:
-    case GDK_WINDOW_CHILD:
-    case GDK_WINDOW_DIALOG:
-    case GDK_WINDOW_TEMP:
-      if (WINDOW_IS_TOPLEVEL (window))
-	{
-	  /* Save the original window type so we can restore it if the
-	   * window is reparented back to be a toplevel.
-	   */
-	  impl->toplevel_window_type = GDK_WINDOW_TYPE (window);
-	  GDK_WINDOW_TYPE (window) = GDK_WINDOW_CHILD;
-	}
-    }
-
-  if (old_parent_private)
-    old_parent_private->children =
-      g_list_remove (old_parent_private->children, window);
-
-  parent_private->children = g_list_prepend (parent_private->children, window);
-
-  return FALSE;
-}
-
-static void
-erase_background (GdkWindow *window,
-		  HDC        hdc)
-{
-  HDC bgdc = NULL;
-  HBRUSH hbr = NULL;
-  HPALETTE holdpal = NULL;
-  RECT rect;
-  COLORREF bg;
-  GdkColormap *colormap;
-  GdkColormapPrivateWin32 *colormap_private;
-  int x, y;
-  int x_offset, y_offset;
-  
-  if (((GdkWindowObject *) window)->input_only ||
-      ((GdkWindowObject *) window)->bg_pixmap == GDK_NO_BG)
-    {
-      return;
-    }
-
-  colormap = gdk_drawable_get_colormap (window);
-
-  if (colormap &&
-      (colormap->visual->type == GDK_VISUAL_PSEUDO_COLOR ||
-       colormap->visual->type == GDK_VISUAL_STATIC_COLOR))
-    {
-      int k;
-	  
-      colormap_private = GDK_WIN32_COLORMAP_DATA (colormap);
-
-      if (!(holdpal = SelectPalette (hdc,  colormap_private->hpal, FALSE)))
-        WIN32_GDI_FAILED ("SelectPalette");
-      else if ((k = RealizePalette (hdc)) == GDI_ERROR)
-	WIN32_GDI_FAILED ("RealizePalette");
-      else if (k > 0)
-	GDK_NOTE (COLORMAP, g_print ("erase_background: realized %p: %d colors\n",
-				     colormap_private->hpal, k));
-    }
-  
-  x_offset = y_offset = 0;
-  while (window && ((GdkWindowObject *) window)->bg_pixmap == GDK_PARENT_RELATIVE_BG)
-    {
-      /* If this window should have the same background as the parent,
-       * fetch the parent. (And if the same goes for the parent, fetch
-       * the grandparent, etc.)
-       */
-      x_offset += ((GdkWindowObject *) window)->x;
-      y_offset += ((GdkWindowObject *) window)->y;
-      window = GDK_WINDOW (((GdkWindowObject *) window)->parent);
-    }
-  
-  GetClipBox (hdc, &rect);
-
-  if (((GdkWindowObject *) window)->bg_pixmap == NULL)
-    {
-      bg = _gdk_win32_colormap_color (GDK_DRAWABLE_IMPL_WIN32 (((GdkWindowObject *) window)->impl)->colormap,
-				      ((GdkWindowObject *) window)->bg_color.pixel);
-      
-      if (!(hbr = CreateSolidBrush (bg)))
-	WIN32_GDI_FAILED ("CreateSolidBrush");
-      else if (!FillRect (hdc, &rect, hbr))
-	WIN32_GDI_FAILED ("FillRect");
-      if (hbr != NULL)
-	DeleteObject (hbr);
-    }
-  else if (((GdkWindowObject *) window)->bg_pixmap != GDK_NO_BG)
-    {
-      GdkPixmap *pixmap = ((GdkWindowObject *) window)->bg_pixmap;
-      GdkPixmapImplWin32 *pixmap_impl = GDK_PIXMAP_IMPL_WIN32 (GDK_PIXMAP_OBJECT (pixmap)->impl);
-      
-      if (x_offset == 0 && y_offset == 0 &&
-	  pixmap_impl->width <= 8 && pixmap_impl->height <= 8)
-	{
-	  if (!(hbr = CreatePatternBrush (GDK_PIXMAP_HBITMAP (pixmap))))
-	    WIN32_GDI_FAILED ("CreatePatternBrush");
-	  else if (!FillRect (hdc, &rect, hbr))
-	    WIN32_GDI_FAILED ("FillRect");
-	  if (hbr != NULL)
-	    DeleteObject (hbr);
-	}
-      else
-	{
-	  HGDIOBJ oldbitmap;
-
-	  if (!(bgdc = CreateCompatibleDC (hdc)))
-	    {
-	      WIN32_GDI_FAILED ("CreateCompatibleDC");
-	      return;
-	    }
-	  if (!(oldbitmap = SelectObject (bgdc, GDK_PIXMAP_HBITMAP (pixmap))))
-	    {
-	      WIN32_GDI_FAILED ("SelectObject");
-	      DeleteDC (bgdc);
-	      return;
-	    }
-	  x = -x_offset;
-	  while (x < rect.right)
-	    {
-	      if (x + pixmap_impl->width >= rect.left)
-		{
-		  y = -y_offset;
-		  while (y < rect.bottom)
-		    {
-		      if (y + pixmap_impl->height >= rect.top)
-			{
-			  if (!BitBlt (hdc, x, y,
-				       pixmap_impl->width, pixmap_impl->height,
-				       bgdc, 0, 0, SRCCOPY))
-			    {
-			      WIN32_GDI_FAILED ("BitBlt");
-			      SelectObject (bgdc, oldbitmap);
-			      DeleteDC (bgdc);
-			      return;
-			    }
-			}
-		      y += pixmap_impl->height;
-		    }
-		}
-	      x += pixmap_impl->width;
-	    }
-	  SelectObject (bgdc, oldbitmap);
-	  DeleteDC (bgdc);
-	}
-    }
-}
-
-static void
-gdk_win32_window_clear_area (GdkWindow *window,
-			     gint       x,
-			     gint       y,
-			     gint       width,
-			     gint       height,
-			     gboolean   send_expose)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-
-  if (!GDK_WINDOW_DESTROYED (window))
-    {
-      HDC hdc;
-      RECT rect;
-
-      hdc = GetDC (GDK_WINDOW_HWND (window));
-
-      if (!send_expose)
-	{
-	  if (width == 0)
-	    width = private->width - x;
-	  if (height == 0)
-	    height = private->height - y;
-	  GDK_NOTE (MISC, g_print ("_gdk_windowing_window_clear_area: %p: "
-				   "%dx%d@%+d%+d\n",
-				   GDK_WINDOW_HWND (window),
-				   width, height, x, y));
-	  IntersectClipRect (hdc, x, y, x + width, y + height);
-	  erase_background (window, hdc);
-	  GDI_CALL (ReleaseDC, (GDK_WINDOW_HWND (window), hdc));
-	}
-      else
-	{
-	  /* The background should be erased before the expose event is
-	     generated */
-	  IntersectClipRect (hdc, x, y, x + width, y + height);
-	  erase_background (window, hdc);
-	  GDI_CALL (ReleaseDC, (GDK_WINDOW_HWND (window), hdc));
-
-	  rect.left = x;
-	  rect.right = x + width;
-	  rect.top = y;
-	  rect.bottom = y + height;
-
-	  GDI_CALL (InvalidateRect, (GDK_WINDOW_HWND (window), &rect, TRUE));
-	  UpdateWindow (GDK_WINDOW_HWND (window));
-	}
-    }
-}
-
-static void
-gdk_window_win32_clear_region (GdkWindow *window,
-			     GdkRegion *region,
-			     gboolean   send_expose)
-{
-  GdkRectangle *rectangles;
-  int n_rectangles, i;
-
-  gdk_region_get_rectangles  (region,
-			      &rectangles,
-			      &n_rectangles);
-
-  for (i = 0; i < n_rectangles; i++)
-    gdk_win32_window_clear_area (window,
-		rectangles[i].x, rectangles[i].y,
-		rectangles[i].width, rectangles[i].height,
-		send_expose);
-
-  g_free (rectangles);
-}
-
-static void
-gdk_win32_window_raise (GdkWindow *window)
-{
-  if (!GDK_WINDOW_DESTROYED (window))
-    {
-      GDK_NOTE (MISC, g_print ("gdk_win32_window_raise: %p\n",
-			       GDK_WINDOW_HWND (window)));
-
-      if (GDK_WINDOW_TYPE (window) == GDK_WINDOW_TEMP)
-        API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), HWND_TOPMOST,
-	                         0, 0, 0, 0,
-				 SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE));
-      else if (((GdkWindowObject *)window)->accept_focus)
-        /* Do not wrap this in an API_CALL macro as SetForegroundWindow might
-         * fail when for example dragging a window belonging to a different
-         * application at the time of a gtk_window_present() call due to focus
-         * stealing prevention. */
-        SetForegroundWindow (GDK_WINDOW_HWND (window));
-      else
-        API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), HWND_TOP,
-  			         0, 0, 0, 0,
-			         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE));
-    }
-}
-
-static void
-gdk_win32_window_lower (GdkWindow *window)
-{
-  if (!GDK_WINDOW_DESTROYED (window))
-    {
-      GDK_NOTE (MISC, g_print ("gdk_win32_window_lower: %p\n"
-			       "... SetWindowPos(%p,HWND_BOTTOM,0,0,0,0,"
-			       "NOACTIVATE|NOMOVE|NOSIZE)\n",
-			       GDK_WINDOW_HWND (window),
-			       GDK_WINDOW_HWND (window)));
-
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), HWND_BOTTOM,
-			       0, 0, 0, 0,
-			       SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE));
-    }
-}
-
-void
-gdk_window_set_hints (GdkWindow *window,
-		      gint       x,
-		      gint       y,
-		      gint       min_width,
-		      gint       min_height,
-		      gint       max_width,
-		      gint       max_height,
-		      gint       flags)
-{
-  /* Note that this function is obsolete */
-
-  GdkWindowImplWin32 *impl;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-  
-  impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_hints: %p: %dx%d..%dx%d @%+d%+d\n",
-			   GDK_WINDOW_HWND (window),
-			   min_width, min_height, max_width, max_height,
-			   x, y));
-
-  if (flags)
-    {
-      GdkGeometry geom;
-      gint geom_mask = 0;
-
-      geom.min_width  = min_width;
-      geom.min_height = min_height;
-      geom.max_width  = max_width;
-      geom.max_height = max_height;
-
-      if (flags & GDK_HINT_MIN_SIZE)
-        geom_mask |= GDK_HINT_MIN_SIZE;
-
-      if (flags & GDK_HINT_MAX_SIZE)
-        geom_mask |= GDK_HINT_MAX_SIZE;
-
-      gdk_window_set_geometry_hints (window, &geom, geom_mask);
-    }
-}
-
-void
-gdk_window_set_urgency_hint (GdkWindow *window,
-			     gboolean   urgent)
-{
-  FLASHWINFO flashwinfo;
-  typedef BOOL (WINAPI *PFN_FlashWindowEx) (FLASHWINFO*);
-  PFN_FlashWindowEx flashWindowEx = NULL;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_return_if_fail (GDK_WINDOW_TYPE (window) != GDK_WINDOW_CHILD);
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  flashWindowEx = (PFN_FlashWindowEx) GetProcAddress (GetModuleHandle ("user32.dll"), "FlashWindowEx");
-
-  if (flashWindowEx)
-    {
-      flashwinfo.cbSize = sizeof (flashwinfo);
-      flashwinfo.hwnd = GDK_WINDOW_HWND (window);
-      if (urgent)
-	flashwinfo.dwFlags = FLASHW_ALL | FLASHW_TIMER;
-      else
-	flashwinfo.dwFlags = FLASHW_STOP;
-      flashwinfo.uCount = 0;
-      flashwinfo.dwTimeout = 0;
-      
-      flashWindowEx (&flashwinfo);
-    }
-  else
-    {
-      FlashWindow (GDK_WINDOW_HWND (window), urgent);
-    }
-}
-
-static gboolean
-get_effective_window_decorations (GdkWindow       *window,
-                                  GdkWMDecoration *decoration)
-{
-  GdkWindowImplWin32 *impl;
-
-  impl = (GdkWindowImplWin32 *)((GdkWindowObject *)window)->impl;
-
-  if (gdk_window_get_decorations (window, decoration))
-    return TRUE;
-    
-  if (((GdkWindowObject *) window)->window_type != GDK_WINDOW_TOPLEVEL &&
-      ((GdkWindowObject *) window)->window_type != GDK_WINDOW_DIALOG)
-    {
-      return FALSE;
-    }
-
-  if ((impl->hint_flags & GDK_HINT_MIN_SIZE) &&
-      (impl->hint_flags & GDK_HINT_MAX_SIZE) &&
-      impl->hints.min_width == impl->hints.max_width &&
-      impl->hints.min_height == impl->hints.max_height)
-    {
-      *decoration = GDK_DECOR_ALL | GDK_DECOR_RESIZEH | GDK_DECOR_MAXIMIZE;
-
-      if (impl->type_hint == GDK_WINDOW_TYPE_HINT_DIALOG ||
-	  impl->type_hint == GDK_WINDOW_TYPE_HINT_MENU ||
-	  impl->type_hint == GDK_WINDOW_TYPE_HINT_TOOLBAR)
-	{
-	  *decoration |= GDK_DECOR_MINIMIZE;
-	}
-      else if (impl->type_hint == GDK_WINDOW_TYPE_HINT_SPLASHSCREEN)
-	{
-	  *decoration |= GDK_DECOR_MENU | GDK_DECOR_MINIMIZE;
-	}
-
-      return TRUE;
-    }
-  else if (impl->hint_flags & GDK_HINT_MAX_SIZE)
-    {
-      *decoration = GDK_DECOR_ALL | GDK_DECOR_MAXIMIZE;
-      if (impl->type_hint == GDK_WINDOW_TYPE_HINT_DIALOG ||
-	  impl->type_hint == GDK_WINDOW_TYPE_HINT_MENU ||
-	  impl->type_hint == GDK_WINDOW_TYPE_HINT_TOOLBAR)
-	{
-	  *decoration |= GDK_DECOR_MINIMIZE;
-	}
-
-      return TRUE;
-    }
-  else
-    {
-      switch (impl->type_hint)
-	{
-	case GDK_WINDOW_TYPE_HINT_DIALOG:
-	  *decoration = (GDK_DECOR_ALL | GDK_DECOR_MINIMIZE | GDK_DECOR_MAXIMIZE);
-	  return TRUE;
-
-	case GDK_WINDOW_TYPE_HINT_MENU:
-	  *decoration = (GDK_DECOR_ALL | GDK_DECOR_RESIZEH | GDK_DECOR_MINIMIZE | GDK_DECOR_MAXIMIZE);
-	  return TRUE;
-
-	case GDK_WINDOW_TYPE_HINT_TOOLBAR:
-	case GDK_WINDOW_TYPE_HINT_UTILITY:
-	  gdk_window_set_skip_taskbar_hint (window, TRUE);
-	  gdk_window_set_skip_pager_hint (window, TRUE);
-	  *decoration = (GDK_DECOR_ALL | GDK_DECOR_MINIMIZE | GDK_DECOR_MAXIMIZE);
-	  return TRUE;
-
-	case GDK_WINDOW_TYPE_HINT_SPLASHSCREEN:
-	  *decoration = (GDK_DECOR_ALL | GDK_DECOR_RESIZEH | GDK_DECOR_MENU |
-			 GDK_DECOR_MINIMIZE | GDK_DECOR_MAXIMIZE);
-	  return TRUE;
-	  
-	case GDK_WINDOW_TYPE_HINT_DOCK:
-	  return FALSE;
-	  
-	case GDK_WINDOW_TYPE_HINT_DESKTOP:
-	  return FALSE;
-
-	default:
-	  /* Fall thru */
-	case GDK_WINDOW_TYPE_HINT_NORMAL:
-	  *decoration = GDK_DECOR_ALL;
-	  return TRUE;
-	}
-    }
-    
-  return FALSE;
-}
-
-void 
-gdk_window_set_geometry_hints (GdkWindow         *window,
-			       const GdkGeometry *geometry,
-			       GdkWindowHints     geom_mask)
-{
-  GdkWindowImplWin32 *impl;
-  FullscreenInfo *fi;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_geometry_hints: %p\n",
-			   GDK_WINDOW_HWND (window)));
-
-  impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-  fi = g_object_get_data (G_OBJECT (window), "fullscreen-info");
-  if (fi)
-    fi->hint_flags = geom_mask;
-  else
-    impl->hint_flags = geom_mask;
-  impl->hints = *geometry;
-
-  if (geom_mask & GDK_HINT_POS)
-    ; /* even the X11 mplementation doesn't care */
-
-  if (geom_mask & GDK_HINT_MIN_SIZE)
-    {
-      GDK_NOTE (MISC, g_print ("... MIN_SIZE: %dx%d\n",
-			       geometry->min_width, geometry->min_height));
-    }
-  
-  if (geom_mask & GDK_HINT_MAX_SIZE)
-    {
-      GDK_NOTE (MISC, g_print ("... MAX_SIZE: %dx%d\n",
-			       geometry->max_width, geometry->max_height));
-    }
-
-  if (geom_mask & GDK_HINT_BASE_SIZE)
-    {
-      GDK_NOTE (MISC, g_print ("... BASE_SIZE: %dx%d\n",
-			       geometry->base_width, geometry->base_height));
-    }
-  
-  if (geom_mask & GDK_HINT_RESIZE_INC)
-    {
-      GDK_NOTE (MISC, g_print ("... RESIZE_INC: (%d,%d)\n",
-			       geometry->width_inc, geometry->height_inc));
-    }
-  
-  if (geom_mask & GDK_HINT_ASPECT)
-    {
-      GDK_NOTE (MISC, g_print ("... ASPECT: %g--%g\n",
-			       geometry->min_aspect, geometry->max_aspect));
-    }
-
-  if (geom_mask & GDK_HINT_WIN_GRAVITY)
-    {
-      GDK_NOTE (MISC, g_print ("... GRAVITY: %d\n", geometry->win_gravity));
-    }
-
-  update_style_bits (window);
-}
-
-void
-gdk_window_set_title (GdkWindow   *window,
-		      const gchar *title)
-{
-  wchar_t *wtitle;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_return_if_fail (title != NULL);
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* Empty window titles not allowed, so set it to just a period. */
-  if (!title[0])
-    title = ".";
-  
-  GDK_NOTE (MISC, g_print ("gdk_window_set_title: %p: %s\n",
-			   GDK_WINDOW_HWND (window), title));
-  
-  GDK_NOTE (MISC_OR_EVENTS, title = g_strdup_printf ("%p %s", GDK_WINDOW_HWND (window), title));
-
-  wtitle = g_utf8_to_utf16 (title, -1, NULL, NULL, NULL);
-  API_CALL (SetWindowTextW, (GDK_WINDOW_HWND (window), wtitle));
-  g_free (wtitle);
-
-  GDK_NOTE (MISC_OR_EVENTS, g_free ((char *) title));
-}
-
-void          
-gdk_window_set_role (GdkWindow   *window,
-		     const gchar *role)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  GDK_NOTE (MISC, g_print ("gdk_window_set_role: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   (role ? role : "NULL")));
-  /* XXX */
-}
-
-void
-gdk_window_set_transient_for (GdkWindow *window, 
-			      GdkWindow *parent)
-{
-  HWND window_id, parent_id;
-  GdkWindowImplWin32 *window_impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-  GdkWindowImplWin32 *parent_impl = NULL;
-  GSList *item;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  window_id = GDK_WINDOW_HWND (window);
-  parent_id = parent != NULL ? GDK_WINDOW_HWND (parent) : NULL;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_transient_for: %p: %p\n", window_id, parent_id));
-
-  if (GDK_WINDOW_DESTROYED (window) || (parent && GDK_WINDOW_DESTROYED (parent)))
-    {
-      if (GDK_WINDOW_DESTROYED (window))
-	GDK_NOTE (MISC, g_print ("... destroyed!\n"));
-      else
-	GDK_NOTE (MISC, g_print ("... owner destroyed!\n"));
-
-      return;
-    }
-
-  if (((GdkWindowObject *) window)->window_type == GDK_WINDOW_CHILD)
-    {
-      GDK_NOTE (MISC, g_print ("... a child window!\n"));
-      return;
-    }
-
-  if (parent == NULL)
-    {
-      GdkWindowImplWin32 *trans_impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window_impl->transient_owner)->impl);
-      if (trans_impl->transient_children != NULL)
-        {
-          item = g_slist_find (trans_impl->transient_children, window);
-          item->data = NULL;
-          trans_impl->transient_children = g_slist_delete_link (trans_impl->transient_children, item);
-          trans_impl->num_transients--;
-
-          if (!trans_impl->num_transients)
-            {
-              trans_impl->transient_children = NULL;
-            }
-        }
-      g_object_unref (G_OBJECT (window_impl->transient_owner));
-      g_object_unref (G_OBJECT (window));
-
-      window_impl->transient_owner = NULL;
-    }
-  else
-    {
-      parent_impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (parent)->impl);
-
-      parent_impl->transient_children = g_slist_append (parent_impl->transient_children, window);
-      g_object_ref (G_OBJECT (window));
-      parent_impl->num_transients++;
-      window_impl->transient_owner = parent;
-      g_object_ref (G_OBJECT (parent));
-    }
-
-  /* This changes the *owner* of the window, despite the misleading
-   * name. (Owner and parent are unrelated concepts.) At least that's
-   * what people who seem to know what they talk about say on
-   * USENET. Search on Google.
-   */
-  SetLastError (0);
-  if (SetWindowLongPtr (window_id, GWLP_HWNDPARENT, (LONG_PTR) parent_id) == 0 &&
-      GetLastError () != 0)
-    WIN32_API_FAILED ("SetWindowLongPtr");
-}
-
-void
-_gdk_push_modal_window (GdkWindow *window)
-{
-  modal_window_stack = g_slist_prepend (modal_window_stack,
-                                        window);
-}
-
-void
-_gdk_remove_modal_window (GdkWindow *window)
-{
-  GSList *tmp;
-
-  g_return_if_fail (window != NULL);
-
-  /* It's possible to be NULL here if someone sets the modal hint of the window
-   * to FALSE before a modal window stack has ever been created. */
-  if (modal_window_stack == NULL)
-    return;
-
-  /* Find the requested window in the stack and remove it.  Yeah, I realize this
-   * means we're not a 'real stack', strictly speaking.  Sue me. :) */
-  tmp = g_slist_find (modal_window_stack, window);
-  if (tmp != NULL)
-    {
-      modal_window_stack = g_slist_delete_link (modal_window_stack, tmp);
-    }
-}
-
-gboolean
-_gdk_modal_blocked (GdkWindow *window)
-{
-  GSList *l;
-  gboolean found_any = FALSE;
-
-  for (l = modal_window_stack; l != NULL; l = l->next)
-    {
-      GdkWindow *modal = l->data;
-
-      if (modal == window)
-	return FALSE;
-
-      if (GDK_WINDOW_IS_MAPPED (modal))
-	found_any = TRUE;
-    }
-
-  return found_any;
-}
-
-GdkWindow *
-_gdk_modal_current (void)
-{
-  GSList *l;
-
-  for (l = modal_window_stack; l != NULL; l = l->next)
-    {
-      GdkWindow *modal = l->data;
-
-      if (GDK_WINDOW_IS_MAPPED (modal))
-	return modal;
-    }
-
-  return NULL;
-}
-
-static void
-gdk_win32_window_set_background (GdkWindow      *window,
-				 const GdkColor *color)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-  
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_set_background: %p: %s\n",
-			   GDK_WINDOW_HWND (window), 
-			   _gdk_win32_color_to_string (color)));
-
-  private->bg_color = *color;
-
-  if (private->bg_pixmap &&
-      private->bg_pixmap != GDK_PARENT_RELATIVE_BG &&
-      private->bg_pixmap != GDK_NO_BG)
-    {
-      g_object_unref (private->bg_pixmap);
-      private->bg_pixmap = NULL;
-    }
-}
-
-static void
-gdk_win32_window_set_back_pixmap (GdkWindow *window,
-				  GdkPixmap *pixmap)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-
-  if (pixmap != GDK_PARENT_RELATIVE_BG &&
-      pixmap != GDK_NO_BG &&
-      pixmap && !gdk_drawable_get_colormap (pixmap))
-    {
-      g_warning ("gdk_window_set_back_pixmap(): pixmap must have a colormap");
-      return;
-    }
-  
-  if (private->bg_pixmap &&
-      private->bg_pixmap != GDK_PARENT_RELATIVE_BG &&
-      private->bg_pixmap != GDK_NO_BG)
-    g_object_unref (private->bg_pixmap);
-
-  if (pixmap != GDK_PARENT_RELATIVE_BG &&
-      pixmap != GDK_NO_BG &&
-      pixmap)
-    {
-      g_object_ref (pixmap);
-      private->bg_pixmap = pixmap;
-    }
-  else
-    {
-      private->bg_pixmap = pixmap;
-    }
-}
-
-static void
-gdk_win32_window_set_cursor (GdkWindow *window,
-			     GdkCursor *cursor)
-{
-  GdkWindowImplWin32 *impl;
-  GdkCursorPrivate *cursor_private;
-  GdkWindowObject *parent_window;
-  HCURSOR hcursor;
-  HCURSOR hprevcursor;
-  
-  impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-  cursor_private = (GdkCursorPrivate*) cursor;
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  if (!cursor)
-    hcursor = NULL;
-  else
-    hcursor = cursor_private->hcursor;
-  
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_set_cursor: %p: %p\n",
-			   GDK_WINDOW_HWND (window),
-			   hcursor));
-
-  /* First get the old cursor, if any (we wait to free the old one
-   * since it may be the current cursor set in the Win32 API right
-   * now).
-   */
-  hprevcursor = impl->hcursor;
-
-  if (hcursor == NULL)
-    impl->hcursor = NULL;
-  else
-    {
-      /* We must copy the cursor as it is OK to destroy the GdkCursor
-       * while still in use for some window. See for instance
-       * gimp_change_win_cursor() which calls gdk_window_set_cursor
-       * (win, cursor), and immediately afterwards gdk_cursor_destroy
-       * (cursor).
-       */
-      if ((impl->hcursor = CopyCursor (hcursor)) == NULL)
-	WIN32_API_FAILED ("CopyCursor");
-      GDK_NOTE (MISC, g_print ("... CopyCursor (%p) = %p\n",
-			       hcursor, impl->hcursor));
-    }
-
-  if (impl->hcursor != NULL)
-    {
-      /* If the pointer is over our window, set new cursor */
-      GdkWindow *curr_window = gdk_window_get_pointer (window, NULL, NULL, NULL);
-      if (curr_window == window ||
-	  (curr_window && window == gdk_window_get_toplevel (curr_window)))
-        SetCursor (impl->hcursor);
-      else
-	{
-	  /* Climb up the tree and find whether our window is the
-	   * first ancestor that has cursor defined, and if so, set
-	   * new cursor.
-	   */
-	  GdkWindowObject *curr_window_obj = GDK_WINDOW_OBJECT (curr_window);
-	  while (curr_window_obj &&
-		 !GDK_WINDOW_IMPL_WIN32 (curr_window_obj->impl)->hcursor)
-	    {
-	      curr_window_obj = curr_window_obj->parent;
-	      if (curr_window_obj == GDK_WINDOW_OBJECT (window))
-		{
-	          SetCursor (impl->hcursor);
-		  break;
-		}
-	    }
-	}
-    }
-
-  /* Destroy the previous cursor: Need to make sure it's no longer in
-   * use before we destroy it, in case we're not over our window but
-   * the cursor is still set to our old one.
-   */
-  if (hprevcursor != NULL)
-    {
-      if (GetCursor () == hprevcursor)
-	{
-	  /* Look for a suitable cursor to use instead */
-	  hcursor = NULL;
-          parent_window = GDK_WINDOW_OBJECT (window)->parent;
-          while (hcursor == NULL)
-	    {
-	      if (parent_window)
-		{
-		  impl = GDK_WINDOW_IMPL_WIN32 (parent_window->impl);
-		  hcursor = impl->hcursor;
-		  parent_window = parent_window->parent;
-		}
-	      else
-		{
-		  hcursor = LoadCursor (NULL, IDC_ARROW);
-		}
-	    }
-          SetCursor (hcursor);
-        }
-
-      GDK_NOTE (MISC, g_print ("... DestroyCursor (%p)\n", hprevcursor));
-      
-      API_CALL (DestroyCursor, (hprevcursor));
-    }
-}
-
-static void
-gdk_win32_window_get_geometry (GdkWindow *window,
-			       gint      *x,
-			       gint      *y,
-			       gint      *width,
-			       gint      *height,
-			       gint      *depth)
-{
-  if (!window)
-    window = _gdk_root;
-  
-  if (!GDK_WINDOW_DESTROYED (window))
-    {
-      RECT rect;
-
-      API_CALL (GetClientRect, (GDK_WINDOW_HWND (window), &rect));
-
-      if (window != _gdk_root)
-	{
-	  POINT pt;
-	  GdkWindow *parent = gdk_window_get_parent (window);
-
-	  pt.x = rect.left;
-	  pt.y = rect.top;
-	  ClientToScreen (GDK_WINDOW_HWND (window), &pt);
-	  ScreenToClient (GDK_WINDOW_HWND (parent), &pt);
-	  rect.left = pt.x;
-	  rect.top = pt.y;
-
-	  pt.x = rect.right;
-	  pt.y = rect.bottom;
-	  ClientToScreen (GDK_WINDOW_HWND (window), &pt);
-	  ScreenToClient (GDK_WINDOW_HWND (parent), &pt);
-	  rect.right = pt.x;
-	  rect.bottom = pt.y;
-
-	  if (parent == _gdk_root)
-	    {
-	      rect.left += _gdk_offset_x;
-	      rect.top += _gdk_offset_y;
-	      rect.right += _gdk_offset_x;
-	      rect.bottom += _gdk_offset_y;
-	    }
-	}
-
-      if (x)
-	*x = rect.left;
-      if (y)
-	*y = rect.top;
-      if (width)
-	*width = rect.right - rect.left;
-      if (height)
-	*height = rect.bottom - rect.top;
-      if (depth)
-	*depth = gdk_drawable_get_visual (window)->depth;
-
-      GDK_NOTE (MISC, g_print ("gdk_win32_window_get_geometry: %p: %ldx%ldx%d@%+ld%+ld\n",
-			       GDK_WINDOW_HWND (window),
-			       rect.right - rect.left, rect.bottom - rect.top,
-			       gdk_drawable_get_visual (window)->depth,
-			       rect.left, rect.top));
-    }
-}
-
-static gint
-gdk_win32_window_get_root_coords (GdkWindow *window,
-				  gint       x,
-				  gint       y,
-				  gint      *root_x,
-				  gint      *root_y)
-{
-  gint tx;
-  gint ty;
-  POINT pt;
-
-  pt.x = x;
-  pt.y = y;
-  ClientToScreen (GDK_WINDOW_HWND (window), &pt);
-  tx = pt.x;
-  ty = pt.y;
-  
-  if (root_x)
-    *root_x = tx + _gdk_offset_x;
-  if (root_y)
-    *root_y = ty + _gdk_offset_y;
-
-  GDK_NOTE (MISC, g_print ("gdk_win32_window_get_root_coords: %p: %+d%+d %+d%+d\n",
-			   GDK_WINDOW_HWND (window),
-			   x, y,
-			   tx + _gdk_offset_x, ty + _gdk_offset_y));
-  return 1;
-}
-
-static gboolean
-gdk_win32_window_get_deskrelative_origin (GdkWindow *window,
-					  gint      *x,
-					  gint      *y)
-{
-  return gdk_win32_window_get_root_coords (window, 0, 0, x, y);
-}
-
-static void
-gdk_win32_window_restack_under (GdkWindow *window,
-				GList *native_siblings)
-{
-  GList *list;
-
-  /* input order is bottom-most first */
-  for (list = native_siblings;;)
-    {
-      HWND lower = list->data, upper;
-
-      list = list->next;
-      if (!list)
-	break;
-      upper = list->data;
-      API_CALL (SetWindowPos, (upper, lower, 0, 0, 0, 0, 
-		  SWP_NOMOVE|SWP_NOSIZE|SWP_NOREDRAW));
-    }
-
-}
-
-static void
-gdk_win32_window_restack_toplevel (GdkWindow *window,
-				   GdkWindow *sibling,
-				   gboolean   above)
-{
-  HWND lower = above ? GDK_WINDOW_HWND (sibling) : GDK_WINDOW_HWND (window);
-  HWND upper = above ? GDK_WINDOW_HWND (window) : GDK_WINDOW_HWND (sibling);
-
-  API_CALL (SetWindowPos, (upper, lower, 0, 0, 0, 0, 
-	      SWP_NOMOVE|SWP_NOSIZE|SWP_NOREDRAW));
-}
-
-void
-gdk_window_get_root_origin (GdkWindow *window,
-			    gint      *x,
-			    gint      *y)
-{
-  GdkRectangle rect;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  gdk_window_get_frame_extents (window, &rect);
-
-  if (x)
-    *x = rect.x;
-
-  if (y)
-    *y = rect.y;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_get_root_origin: %p: %+d%+d\n",
-			   GDK_WINDOW_HWND (window), rect.x, rect.y));
-}
-
-void
-gdk_window_get_frame_extents (GdkWindow    *window,
-                              GdkRectangle *rect)
-{
-  GdkWindowObject *private;
-  HWND hwnd;
-  RECT r;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_return_if_fail (rect != NULL);
-
-  private = GDK_WINDOW_OBJECT (window);
-
-  rect->x = 0;
-  rect->y = 0;
-  rect->width = 1;
-  rect->height = 1;
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* FIXME: window is documented to be a toplevel GdkWindow, so is it really
-   * necessary to walk its parent chain?
-   */
-  while (private->parent && ((GdkWindowObject*) private->parent)->parent)
-    private = (GdkWindowObject*) private->parent;
-
-  hwnd = GDK_WINDOW_HWND (window);
-  API_CALL (GetWindowRect, (hwnd, &r));
-
-  rect->x = r.left + _gdk_offset_x;
-  rect->y = r.top + _gdk_offset_y;
-  rect->width = r.right - r.left;
-  rect->height = r.bottom - r.top;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_get_frame_extents: %p: %ldx%ld@%+ld%+ld\n",
-			   GDK_WINDOW_HWND (window),
-			   r.right - r.left, r.bottom - r.top,
-			   r.left, r.top));
-}
-
-
-static GdkModifierType
-get_current_mask (void)
-{
-  GdkModifierType mask;
-  BYTE kbd[256];
-
-  GetKeyboardState (kbd);
-  mask = 0;
-  if (kbd[VK_SHIFT] & 0x80)
-    mask |= GDK_SHIFT_MASK;
-  if (kbd[VK_CAPITAL] & 0x80)
-    mask |= GDK_LOCK_MASK;
-  if (kbd[VK_CONTROL] & 0x80)
-    mask |= GDK_CONTROL_MASK;
-  if (kbd[VK_MENU] & 0x80)
-    mask |= GDK_MOD1_MASK;
-  if (kbd[VK_LBUTTON] & 0x80)
-    mask |= GDK_BUTTON1_MASK;
-  if (kbd[VK_MBUTTON] & 0x80)
-    mask |= GDK_BUTTON2_MASK;
-  if (kbd[VK_RBUTTON] & 0x80)
-    mask |= GDK_BUTTON3_MASK;
-
-  return mask;
-}
-    
-static gboolean
-gdk_window_win32_get_pointer (GdkWindow       *window,
-			      gint            *x,
-			      gint            *y,
-			      GdkModifierType *mask)
-{
-  gboolean return_val;
-  POINT point;
-  HWND hwnd, hwndc;
-
-  g_return_val_if_fail (window == NULL || GDK_IS_WINDOW (window), FALSE);
-  
-  return_val = TRUE;
-
-  hwnd = GDK_WINDOW_HWND (window);
-  GetCursorPos (&point);
-  ScreenToClient (hwnd, &point);
-
-  *x = point.x;
-  *y = point.y;
-
-  if (window == _gdk_root)
-    {
-      *x += _gdk_offset_x;
-      *y += _gdk_offset_y;
-    }
-
-  hwndc = ChildWindowFromPoint (hwnd, point);
-  if (hwndc != NULL && hwndc != hwnd &&
-      !gdk_win32_handle_table_lookup ((GdkNativeWindow) hwndc))
-    return_val = FALSE; /* Direct child unknown to gdk */
-
-  *mask = get_current_mask ();
-  
-  return return_val;
-}
-
-void
-_gdk_windowing_get_pointer (GdkDisplay       *display,
-			    GdkScreen       **screen,
-			    gint             *x,
-			    gint             *y,
-			    GdkModifierType  *mask)
-{
-  POINT point;
-
-  g_return_if_fail (display == _gdk_display);
-  
-  *screen = _gdk_screen;
-  GetCursorPos (&point);
-  *x = point.x + _gdk_offset_x;
-  *y = point.y + _gdk_offset_y;
-
-  *mask = get_current_mask ();
-}
-
-void
-gdk_display_warp_pointer (GdkDisplay *display,
-			  GdkScreen  *screen,
-			  gint        x,
-			  gint        y)
-{
-  g_return_if_fail (display == _gdk_display);
-  g_return_if_fail (screen == _gdk_screen);
-
-  SetCursorPos (x - _gdk_offset_x, y - _gdk_offset_y);
-}
-
-static void
-screen_to_client (HWND hwnd, POINT screen_pt, POINT *client_pt)
-{
-  *client_pt = screen_pt;
-  ScreenToClient (hwnd, client_pt);
-}
-
-GdkWindow*
-_gdk_windowing_window_at_pointer (GdkDisplay *display,
-				  gint       *win_x,
-				  gint       *win_y,
-				  GdkModifierType *mask,
-				  gboolean    get_toplevel)
-{
-  GdkWindow *window = NULL;
-  POINT screen_pt, client_pt;
-  HWND hwnd, hwndc;
-  RECT rect;
-
-  GetCursorPos (&screen_pt);
-
-  if (get_toplevel)
-    {
-      /* Only consider visible children of the desktop to avoid the various
-       * non-visible windows you often find on a running Windows box. These
-       * might overlap our windows and cause our walk to fail. As we assume
-       * WindowFromPoint() can find our windows, we follow similar logic
-       * here, and ignore invisible and disabled windows.
-       */
-      hwnd = GetDesktopWindow ();
-      do {
-        window = gdk_win32_handle_table_lookup ((GdkNativeWindow) hwnd);
-
-        if (window != NULL &&
-            GDK_WINDOW_TYPE (window) != GDK_WINDOW_ROOT &&
-            GDK_WINDOW_TYPE (window) != GDK_WINDOW_FOREIGN)
-          break;
-
-        screen_to_client (hwnd, screen_pt, &client_pt);
-        hwndc = ChildWindowFromPointEx (hwnd, client_pt, CWP_SKIPDISABLED  |
-                                                         CWP_SKIPINVISIBLE);
-
-	/* Verify that we're really inside the client area of the window */
-	if (hwndc != hwnd)
-	  {
-	    GetClientRect (hwndc, &rect);
-	    screen_to_client (hwndc, screen_pt, &client_pt);
-	    if (!PtInRect (&rect, client_pt))
-	      hwndc = hwnd;
-	  }
-
-      } while (hwndc != hwnd && (hwnd = hwndc, 1));
-
-    }
-  else
-    {
-      hwnd = WindowFromPoint (screen_pt);
-
-      /* Verify that we're really inside the client area of the window */
-      GetClientRect (hwnd, &rect);
-      screen_to_client (hwnd, screen_pt, &client_pt);
-      if (!PtInRect (&rect, client_pt))
-	hwnd = NULL;
-
-      /* If we didn't hit any window at that point, return the desktop */
-      if (hwnd == NULL)
-        {
-          if (win_x)
-            *win_x = screen_pt.x + _gdk_offset_x;
-          if (win_y)
-            *win_y = screen_pt.y + _gdk_offset_y;
-          return _gdk_root;
-        }
-
-      window = gdk_win32_handle_table_lookup ((GdkNativeWindow) hwnd);
-    }
-
-  if (window && (win_x || win_y))
-    {
-      if (win_x)
-        *win_x = client_pt.x;
-      if (win_y)
-        *win_y = client_pt.y;
-    }
-
-  GDK_NOTE (MISC, g_print ("_gdk_windowing_window_at_pointer: %+d%+d %p%s\n",
-			   *win_x, *win_y,
-			   hwnd,
-			   (window == NULL ? " NULL" : "")));
-
-  return window;
-}
-
-static GdkEventMask  
-gdk_win32_window_get_events (GdkWindow *window)
-{
-  GdkWindowImplWin32 *impl;
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return 0;
-
-  impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-  return impl->native_event_mask;
-}
-
-static void          
-gdk_win32_window_set_events (GdkWindow   *window,
-			     GdkEventMask event_mask)
-{
-  GdkWindowImplWin32 *impl;
-
-  impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-  /* gdk_window_new() always sets the GDK_STRUCTURE_MASK, so better
-   * set it here, too. Not that I know or remember why it is
-   * necessary, will have to test some day.
-   */
-  impl->native_event_mask = GDK_STRUCTURE_MASK | event_mask;
-}
-
-static void
-do_shape_combine_region (GdkWindow *window,
-			 HRGN	    hrgn,
-			 gint       x, gint y)
-{
-  RECT rect;
-
-  GetClientRect (GDK_WINDOW_HWND (window), &rect);
-  _gdk_win32_adjust_client_rect (window, &rect);
-
-  OffsetRgn (hrgn, -rect.left, -rect.top);
-  OffsetRgn (hrgn, x, y);
-
-  /* If this is a top-level window, add the title bar to the region */
-  if (GDK_WINDOW_TYPE (window) == GDK_WINDOW_TOPLEVEL)
-    {
-      HRGN tmp = CreateRectRgn (0, 0, rect.right - rect.left, -rect.top);
-      CombineRgn (hrgn, hrgn, tmp, RGN_OR);
-      DeleteObject (tmp);
-    }
-  
-  SetWindowRgn (GDK_WINDOW_HWND (window), hrgn, TRUE);
-}
-
-static void
-gdk_win32_window_shape_combine_mask (GdkWindow *window,
-				     GdkBitmap *mask,
-				     gint x, gint y)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-
-  if (!mask)
-    {
-      GDK_NOTE (MISC, g_print ("gdk_window_shape_combine_mask: %p: none\n",
-			       GDK_WINDOW_HWND (window)));
-      SetWindowRgn (GDK_WINDOW_HWND (window), NULL, TRUE);
-
-      private->shaped = FALSE;
-    }
-  else
-    {
-      HRGN hrgn;
-
-      GDK_NOTE (MISC, g_print ("gdk_window_shape_combine_mask: %p: %p\n",
-			       GDK_WINDOW_HWND (window),
-			       GDK_WINDOW_HWND (mask)));
-
-      /* Convert mask bitmap to region */
-      hrgn = _gdk_win32_bitmap_to_hrgn (mask);
-
-      do_shape_combine_region (window, hrgn, x, y);
-
-      private->shaped = TRUE;
-    }
-}
-
-void
-gdk_window_set_override_redirect (GdkWindow *window,
-				  gboolean   override_redirect)
-{
-  GdkWindowObject *private;
-  GdkWindowImplWin32 *window_impl;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  private = (GdkWindowObject *) window;
-  window_impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-
-  window_impl->override_redirect = !!override_redirect;
-}
-
-void
-gdk_window_set_accept_focus (GdkWindow *window,
-			     gboolean accept_focus)
-{
-  GdkWindowObject *private;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  private = (GdkWindowObject *)window;  
-  
-  accept_focus = accept_focus != FALSE;
-
-  if (private->accept_focus != accept_focus)
-    private->accept_focus = accept_focus;
-}
-
-void
-gdk_window_set_focus_on_map (GdkWindow *window,
-			     gboolean focus_on_map)
-{
-  GdkWindowObject *private;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  private = (GdkWindowObject *)window;  
-  
-  focus_on_map = focus_on_map != FALSE;
-
-  if (private->focus_on_map != focus_on_map)
-    private->focus_on_map = focus_on_map;
-}
-
-void          
-gdk_window_set_icon_list (GdkWindow *window,
-			  GList     *pixbufs)
-{
-  GdkPixbuf *pixbuf, *big_pixbuf, *small_pixbuf;
-  gint big_diff, small_diff;
-  gint big_w, big_h, small_w, small_h;
-  gint w, h;
-  gint dw, dh, diff;
-  HICON small_hicon, big_hicon;
-  GdkWindowImplWin32 *impl;
-  gint i, big_i, small_i;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  impl = GDK_WINDOW_IMPL_WIN32 (GDK_WINDOW_OBJECT (window)->impl);
-
-  /* ideal sizes for small and large icons */
-  big_w = GetSystemMetrics (SM_CXICON);
-  big_h = GetSystemMetrics (SM_CYICON);
-  small_w = GetSystemMetrics (SM_CXSMICON);
-  small_h = GetSystemMetrics (SM_CYSMICON);
-
-  /* find closest sized icons in the list */
-  big_pixbuf = NULL;
-  small_pixbuf = NULL;
-  big_diff = 0;
-  small_diff = 0;
-  i = 0;
-  while (pixbufs)
-    {
-      pixbuf = (GdkPixbuf*) pixbufs->data;
-      w = gdk_pixbuf_get_width (pixbuf);
-      h = gdk_pixbuf_get_height (pixbuf);
-
-      dw = ABS (w - big_w);
-      dh = ABS (h - big_h);
-      diff = dw*dw + dh*dh;
-      if (big_pixbuf == NULL || diff < big_diff)
-	{
-	  big_pixbuf = pixbuf;
-	  big_diff = diff;
-	  big_i = i;
-	}
-
-      dw = ABS (w - small_w);
-      dh = ABS (h - small_h);
-      diff = dw*dw + dh*dh;
-      if (small_pixbuf == NULL || diff < small_diff)
-	{
-	  small_pixbuf = pixbuf;
-	  small_diff = diff;
-	  small_i = i;
-	}
-
-      pixbufs = g_list_next (pixbufs);
-      i++;
-    }
-
-  /* Create the icons */
-  big_hicon = _gdk_win32_pixbuf_to_hicon (big_pixbuf);
-  small_hicon = _gdk_win32_pixbuf_to_hicon (small_pixbuf);
-
-  /* Set the icons */
-  SendMessageW (GDK_WINDOW_HWND (window), WM_SETICON, ICON_BIG,
-		(LPARAM)big_hicon);
-  SendMessageW (GDK_WINDOW_HWND (window), WM_SETICON, ICON_SMALL,
-		(LPARAM)small_hicon);
-
-  /* Store the icons, destroying any previous icons */
-  if (impl->hicon_big)
-    GDI_CALL (DestroyIcon, (impl->hicon_big));
-  impl->hicon_big = big_hicon;
-  if (impl->hicon_small)
-    GDI_CALL (DestroyIcon, (impl->hicon_small));
-  impl->hicon_small = small_hicon;
-}
-
-void          
-gdk_window_set_icon (GdkWindow *window, 
-		     GdkWindow *icon_window,
-		     GdkPixmap *pixmap,
-		     GdkBitmap *mask)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  /* do nothing, use gdk_window_set_icon_list instead */
-}
-
-void
-gdk_window_set_icon_name (GdkWindow   *window, 
-			  const gchar *name)
-{
-  /* In case I manage to confuse this again (or somebody else does):
-   * Please note that "icon name" here really *does* mean the name or
-   * title of an window minimized as an icon on the desktop, or in the
-   * taskbar. It has nothing to do with the freedesktop.org icon
-   * naming stuff.
-   */
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-  
-#if 0
-  /* This is not the correct thing to do. We should keep both the
-   * "normal" window title, and the icon name. When the window is
-   * minimized, call SetWindowText() with the icon name, and when the
-   * window is restored, with the normal window title. Also, the name
-   * is in UTF-8, so we should do the normal conversion to either wide
-   * chars or system codepage, and use either the W or A version of
-   * SetWindowText(), depending on Windows version.
-   */
-  API_CALL (SetWindowText, (GDK_WINDOW_HWND (window), name));
-#endif
-}
-
-GdkWindow *
-gdk_window_get_group (GdkWindow *window)
-{
-  g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
-  g_return_val_if_fail (GDK_WINDOW_TYPE (window) != GDK_WINDOW_CHILD, NULL);
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return NULL;
-  
-  g_warning ("gdk_window_get_group not yet implemented");
-
-  return NULL;
-}
-
-void          
-gdk_window_set_group (GdkWindow *window, 
-		      GdkWindow *leader)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_return_if_fail (GDK_WINDOW_TYPE (window) != GDK_WINDOW_CHILD);
-  g_return_if_fail (leader == NULL || GDK_IS_WINDOW (leader));
-
-  if (GDK_WINDOW_DESTROYED (window) || GDK_WINDOW_DESTROYED (leader))
-    return;
-  
-  g_warning ("gdk_window_set_group not implemented");
-}
-
-static void
-update_single_bit (LONG    *style,
-                   gboolean all,
-		   int      gdk_bit,
-		   int      style_bit)
-{
-  /* all controls the interpretation of gdk_bit -- if all is TRUE,
-   * gdk_bit indicates whether style_bit is off; if all is FALSE, gdk
-   * bit indicate whether style_bit is on
-   */
-  if ((!all && gdk_bit) || (all && !gdk_bit))
-    *style |= style_bit;
-  else
-    *style &= ~style_bit;
-}
-
-static void
-update_style_bits (GdkWindow *window)
-{
-  GdkWindowObject *private = (GdkWindowObject *)window;
-  GdkWindowImplWin32 *impl = (GdkWindowImplWin32 *)private->impl;
-  GdkWMDecoration decorations;
-  LONG old_style, new_style, old_exstyle, new_exstyle;
-  gboolean all;
-  RECT rect, before, after;
-
-  if (private->state & GDK_WINDOW_STATE_FULLSCREEN)
-    return;
-
-  old_style = GetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE);
-  old_exstyle = GetWindowLong (GDK_WINDOW_HWND (window), GWL_EXSTYLE);
-
-  GetClientRect (GDK_WINDOW_HWND (window), &before);
-  after = before;
-  AdjustWindowRectEx (&before, old_style, FALSE, old_exstyle);
-
-  new_style = old_style;
-  new_exstyle = old_exstyle;
-
-  if (private->window_type == GDK_WINDOW_TEMP)
-    new_exstyle |= WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
-  else if (impl->type_hint == GDK_WINDOW_TYPE_HINT_UTILITY)
-    new_exstyle |= WS_EX_TOOLWINDOW ;
-  else
-    new_exstyle &= ~WS_EX_TOOLWINDOW;
-
-  if (get_effective_window_decorations (window, &decorations))
-    {
-      all = (decorations & GDK_DECOR_ALL);
-      update_single_bit (&new_style, all, decorations & GDK_DECOR_BORDER, WS_BORDER);
-      update_single_bit (&new_style, all, decorations & GDK_DECOR_RESIZEH, WS_THICKFRAME);
-      update_single_bit (&new_style, all, decorations & GDK_DECOR_TITLE, WS_CAPTION);
-      update_single_bit (&new_style, all, decorations & GDK_DECOR_MENU, WS_SYSMENU);
-      update_single_bit (&new_style, all, decorations & GDK_DECOR_MINIMIZE, WS_MINIMIZEBOX);
-      update_single_bit (&new_style, all, decorations & GDK_DECOR_MAXIMIZE, WS_MAXIMIZEBOX);
-    }
-
-  if (old_style == new_style && old_exstyle == new_exstyle )
-    {
-      GDK_NOTE (MISC, g_print ("update_style_bits: %p: no change\n",
-			       GDK_WINDOW_HWND (window)));
-      return;
-    }
-
-  if (old_style != new_style)
-    {
-      GDK_NOTE (MISC, g_print ("update_style_bits: %p: STYLE: %s => %s\n",
-			       GDK_WINDOW_HWND (window),
-			       _gdk_win32_window_style_to_string (old_style),
-			       _gdk_win32_window_style_to_string (new_style)));
-      
-      SetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE, new_style);
-    }
-
-  if (old_exstyle != new_exstyle)
-    {
-      GDK_NOTE (MISC, g_print ("update_style_bits: %p: EXSTYLE: %s => %s\n",
-			       GDK_WINDOW_HWND (window),
-			       _gdk_win32_window_exstyle_to_string (old_exstyle),
-			       _gdk_win32_window_exstyle_to_string (new_exstyle)));
-      
-      SetWindowLong (GDK_WINDOW_HWND (window), GWL_EXSTYLE, new_exstyle);
-    }
-
-  AdjustWindowRectEx (&after, new_style, FALSE, new_exstyle);
-
-  GetWindowRect (GDK_WINDOW_HWND (window), &rect);
-  rect.left += after.left - before.left;
-  rect.top += after.top - before.top;
-  rect.right += after.right - before.right;
-  rect.bottom += after.bottom - before.bottom;
-
-  SetWindowPos (GDK_WINDOW_HWND (window), NULL,
-		rect.left, rect.top,
-		rect.right - rect.left, rect.bottom - rect.top,
-		SWP_FRAMECHANGED | SWP_NOACTIVATE | 
-		SWP_NOREPOSITION | SWP_NOZORDER);
-
-}
-
-static void
-update_single_system_menu_entry (HMENU    hmenu,
-				 gboolean all,
-				 int      gdk_bit,
-				 int      menu_entry)
-{
-  /* all controls the interpretation of gdk_bit -- if all is TRUE,
-   * gdk_bit indicates whether menu entry is disabled; if all is
-   * FALSE, gdk bit indicate whether menu entry is enabled
-   */
-  if ((!all && gdk_bit) || (all && !gdk_bit))
-    EnableMenuItem (hmenu, menu_entry, MF_BYCOMMAND | MF_ENABLED);
-  else
-    EnableMenuItem (hmenu, menu_entry, MF_BYCOMMAND | MF_GRAYED);
-}
-
-static void
-update_system_menu (GdkWindow *window)
-{
-  GdkWMFunction functions;
-  BOOL all;
-
-  if (_gdk_window_get_functions (window, &functions))
-    {
-      HMENU hmenu = GetSystemMenu (GDK_WINDOW_HWND (window), FALSE);
-
-      all = (functions & GDK_FUNC_ALL);
-      update_single_system_menu_entry (hmenu, all, functions & GDK_FUNC_RESIZE, SC_SIZE);
-      update_single_system_menu_entry (hmenu, all, functions & GDK_FUNC_MOVE, SC_MOVE);
-      update_single_system_menu_entry (hmenu, all, functions & GDK_FUNC_MINIMIZE, SC_MINIMIZE);
-      update_single_system_menu_entry (hmenu, all, functions & GDK_FUNC_MAXIMIZE, SC_MAXIMIZE);
-      update_single_system_menu_entry (hmenu, all, functions & GDK_FUNC_CLOSE, SC_CLOSE);
-    }
-}
-
-static GQuark
-get_decorations_quark ()
-{
-  static GQuark quark = 0;
-  
-  if (!quark)
-    quark = g_quark_from_static_string ("gdk-window-decorations");
-  
-  return quark;
-}
-
-void
-gdk_window_set_decorations (GdkWindow      *window,
-			    GdkWMDecoration decorations)
-{
-  GdkWMDecoration* decorations_copy;
-  
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  GDK_NOTE (MISC, g_print ("gdk_window_set_decorations: %p: %s %s%s%s%s%s%s\n",
-			   GDK_WINDOW_HWND (window),
-			   (decorations & GDK_DECOR_ALL ? "clearing" : "setting"),
-			   (decorations & GDK_DECOR_BORDER ? "BORDER " : ""),
-			   (decorations & GDK_DECOR_RESIZEH ? "RESIZEH " : ""),
-			   (decorations & GDK_DECOR_TITLE ? "TITLE " : ""),
-			   (decorations & GDK_DECOR_MENU ? "MENU " : ""),
-			   (decorations & GDK_DECOR_MINIMIZE ? "MINIMIZE " : ""),
-			   (decorations & GDK_DECOR_MAXIMIZE ? "MAXIMIZE " : "")));
-
-  decorations_copy = g_malloc (sizeof (GdkWMDecoration));
-  *decorations_copy = decorations;
-  g_object_set_qdata_full (G_OBJECT (window), get_decorations_quark (), decorations_copy, g_free);
-
-  update_style_bits (window);
-}
-
-gboolean
-gdk_window_get_decorations (GdkWindow       *window,
-			    GdkWMDecoration *decorations)
-{
-  GdkWMDecoration* decorations_set;
-  
-  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
-
-  decorations_set = g_object_get_qdata (G_OBJECT (window), get_decorations_quark ());
-  if (decorations_set)
-    *decorations = *decorations_set;
-
-  return (decorations_set != NULL);
-}
-
-static GQuark
-get_functions_quark ()
-{
-  static GQuark quark = 0;
-  
-  if (!quark)
-    quark = g_quark_from_static_string ("gdk-window-functions");
-  
-  return quark;
-}
-
-void
-gdk_window_set_functions (GdkWindow    *window,
-			  GdkWMFunction functions)
-{
-  GdkWMFunction* functions_copy;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  GDK_NOTE (MISC, g_print ("gdk_window_set_functions: %p: %s %s%s%s%s%s\n",
-			   GDK_WINDOW_HWND (window),
-			   (functions & GDK_FUNC_ALL ? "clearing" : "setting"),
-			   (functions & GDK_FUNC_RESIZE ? "RESIZE " : ""),
-			   (functions & GDK_FUNC_MOVE ? "MOVE " : ""),
-			   (functions & GDK_FUNC_MINIMIZE ? "MINIMIZE " : ""),
-			   (functions & GDK_FUNC_MAXIMIZE ? "MAXIMIZE " : ""),
-			   (functions & GDK_FUNC_CLOSE ? "CLOSE " : "")));
-
-  functions_copy = g_malloc (sizeof (GdkWMFunction));
-  *functions_copy = functions;
-  g_object_set_qdata_full (G_OBJECT (window), get_functions_quark (), functions_copy, g_free);
-
-  update_system_menu (window);
-}
-
-gboolean
-_gdk_window_get_functions (GdkWindow     *window,
-		           GdkWMFunction *functions)
-{
-  GdkWMFunction* functions_set;
-  
-  functions_set = g_object_get_qdata (G_OBJECT (window), get_functions_quark ());
-  if (functions_set)
-    *functions = *functions_set;
-
-  return (functions_set != NULL);
-}
-
-static gboolean 
-gdk_win32_window_set_static_gravities (GdkWindow *window,
-				 gboolean   use_static)
-{
-  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
-
-  return !use_static;
-}
-
-void
-gdk_window_begin_resize_drag (GdkWindow     *window,
-                              GdkWindowEdge  edge,
-                              gint           button,
-                              gint           root_x,
-                              gint           root_y,
-                              guint32        timestamp)
-{
-  WPARAM winedge;
-  
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* Tell Windows to start interactively resizing the window by pretending that
-   * the left pointer button was clicked in the suitable edge or corner. This
-   * will only work if the button is down when this function is called, and
-   * will only work with button 1 (left), since Windows only allows window
-   * dragging using the left mouse button.
-   */
-  if (button != 1)
-    return;
-  
-  /* Must break the automatic grab that occured when the button was
-   * pressed, otherwise it won't work.
-   */
-  gdk_display_pointer_ungrab (_gdk_display, 0);
-
-  switch (edge)
-    {
-    case GDK_WINDOW_EDGE_NORTH_WEST:
-      winedge = HTTOPLEFT;
-      break;
-
-    case GDK_WINDOW_EDGE_NORTH:
-      winedge = HTTOP;
-      break;
-
-    case GDK_WINDOW_EDGE_NORTH_EAST:
-      winedge = HTTOPRIGHT;
-      break;
-
-    case GDK_WINDOW_EDGE_WEST:
-      winedge = HTLEFT;
-      break;
-
-    case GDK_WINDOW_EDGE_EAST:
-      winedge = HTRIGHT;
-      break;
-
-    case GDK_WINDOW_EDGE_SOUTH_WEST:
-      winedge = HTBOTTOMLEFT;
-      break;
-
-    case GDK_WINDOW_EDGE_SOUTH:
-      winedge = HTBOTTOM;
-      break;
-
-    case GDK_WINDOW_EDGE_SOUTH_EAST:
-    default:
-      winedge = HTBOTTOMRIGHT;
-      break;
-    }
-
-  DefWindowProcW (GDK_WINDOW_HWND (window), WM_NCLBUTTONDOWN, winedge,
-		  MAKELPARAM (root_x - _gdk_offset_x, root_y - _gdk_offset_y));
-}
-
-void
-gdk_window_begin_move_drag (GdkWindow *window,
-                            gint       button,
-                            gint       root_x,
-                            gint       root_y,
-                            guint32    timestamp)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* Tell Windows to start interactively moving the window by pretending that
-   * the left pointer button was clicked in the titlebar. This will only work
-   * if the button is down when this function is called, and will only work
-   * with button 1 (left), since Windows only allows window dragging using the
-   * left mouse button.
-   */
-  if (button != 1)
-    return;
-  
-  /* Must break the automatic grab that occured when the button was pressed,
-   * otherwise it won't work.
-   */
-  gdk_display_pointer_ungrab (_gdk_display, 0);
-
-  DefWindowProcW (GDK_WINDOW_HWND (window), WM_NCLBUTTONDOWN, HTCAPTION,
-		  MAKELPARAM (root_x - _gdk_offset_x, root_y - _gdk_offset_y));
-}
-
-
-/*
- * Setting window states
- */
-void
-gdk_window_iconify (GdkWindow *window)
-{
-  HWND old_active_window;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_iconify: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (((GdkWindowObject *) window)->state)));
-
-  if (GDK_WINDOW_IS_MAPPED (window))
-    {
-      old_active_window = GetActiveWindow ();
-      ShowWindow (GDK_WINDOW_HWND (window), SW_MINIMIZE);
-      if (old_active_window != GDK_WINDOW_HWND (window))
-	SetActiveWindow (old_active_window);
-    }
-  else
-    {
-      gdk_synthesize_window_state (window,
-                                   0,
-                                   GDK_WINDOW_STATE_ICONIFIED);
-    }
-}
-
-void
-gdk_window_deiconify (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_deiconify: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (((GdkWindowObject *) window)->state)));
-
-  if (GDK_WINDOW_IS_MAPPED (window))
-    {  
-      show_window_internal (window, GDK_WINDOW_IS_MAPPED (window), TRUE);
-    }
-  else
-    {
-      gdk_synthesize_window_state (window,
-                                   GDK_WINDOW_STATE_ICONIFIED,
-                                   0);
-    }
-}
-
-void
-gdk_window_stick (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* FIXME: Do something? */
-}
-
-void
-gdk_window_unstick (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* FIXME: Do something? */
-}
-
-void
-gdk_window_maximize (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_maximize: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (((GdkWindowObject *) window)->state)));
-
-  if (GDK_WINDOW_IS_MAPPED (window))
-    ShowWindow (GDK_WINDOW_HWND (window), SW_MAXIMIZE);
-  else
-    gdk_synthesize_window_state (window,
-				 0,
-				 GDK_WINDOW_STATE_MAXIMIZED);
-}
-
-void
-gdk_window_unmaximize (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_unmaximize: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (((GdkWindowObject *) window)->state)));
-
-  if (GDK_WINDOW_IS_MAPPED (window))
-    ShowWindow (GDK_WINDOW_HWND (window), SW_RESTORE);
-  else
-    gdk_synthesize_window_state (window,
-				 GDK_WINDOW_STATE_MAXIMIZED,
-				 0);
-}
-
-void
-gdk_window_fullscreen (GdkWindow *window)
-{
-  gint x, y, width, height;
-  FullscreenInfo *fi;
-  GdkWindowObject *private = (GdkWindowObject *) window;
-  HMONITOR monitor;
-  MONITORINFO mi;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  fi = g_new (FullscreenInfo, 1);
-
-  if (!GetWindowRect (GDK_WINDOW_HWND (window), &(fi->r)))
-    g_free (fi);
-  else
-    {
-      GdkWindowImplWin32 *impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-
-      monitor = MonitorFromWindow (GDK_WINDOW_HWND (window), MONITOR_DEFAULTTONEAREST);
-      mi.cbSize = sizeof (mi);
-      if (monitor && GetMonitorInfo (monitor, &mi))
-	{
-	  x = mi.rcMonitor.left;
-	  y = mi.rcMonitor.top;
-	  width = mi.rcMonitor.right - x;
-	  height = mi.rcMonitor.bottom - y;
-	}
-      else
-	{
-	  x = y = 0;
-	  width = GetSystemMetrics (SM_CXSCREEN);
-	  height = GetSystemMetrics (SM_CYSCREEN);
-	}
-
-      /* remember for restoring */
-      fi->hint_flags = impl->hint_flags;
-      impl->hint_flags &= ~GDK_HINT_MAX_SIZE;
-      g_object_set_data (G_OBJECT (window), "fullscreen-info", fi);
-      fi->style = GetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE);
-
-      /* Send state change before configure event */
-      gdk_synthesize_window_state (window, 0, GDK_WINDOW_STATE_FULLSCREEN);
-
-      SetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE, 
-                     (fi->style & ~WS_OVERLAPPEDWINDOW) | WS_POPUP);
-
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), HWND_TOP,
-			       x, y, width, height,
-			       SWP_NOCOPYBITS | SWP_SHOWWINDOW));
-    }
-}
-
-void
-gdk_window_unfullscreen (GdkWindow *window)
-{
-  FullscreenInfo *fi;
-  GdkWindowObject *private = (GdkWindowObject *) window;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  fi = g_object_get_data (G_OBJECT (window), "fullscreen-info");
-  if (fi)
-    {
-      GdkWindowImplWin32 *impl = GDK_WINDOW_IMPL_WIN32 (private->impl);
-
-      gdk_synthesize_window_state (window, GDK_WINDOW_STATE_FULLSCREEN, 0);
-
-      impl->hint_flags = fi->hint_flags;
-      SetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE, fi->style);
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), HWND_NOTOPMOST,
-			       fi->r.left, fi->r.top,
-			       fi->r.right - fi->r.left, fi->r.bottom - fi->r.top,
-			       SWP_NOCOPYBITS | SWP_SHOWWINDOW));
-      
-      g_object_set_data (G_OBJECT (window), "fullscreen-info", NULL);
-      g_free (fi);
-      update_style_bits (window);
-    }
-}
-
-void
-gdk_window_set_keep_above (GdkWindow *window,
-			   gboolean   setting)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_keep_above: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   setting ? "YES" : "NO"));
-
-  if (GDK_WINDOW_IS_MAPPED (window))
-    {
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window),
-			       setting ? HWND_TOPMOST : HWND_NOTOPMOST,
-			       0, 0, 0, 0,
-			       SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE));
-    }
-
-  gdk_synthesize_window_state (window,
-			       setting ? GDK_WINDOW_STATE_BELOW : GDK_WINDOW_STATE_ABOVE,
-			       setting ? GDK_WINDOW_STATE_ABOVE : 0);
-}
-
-void
-gdk_window_set_keep_below (GdkWindow *window,
-			   gboolean   setting)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_keep_below: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   setting ? "YES" : "NO"));
-
-  if (GDK_WINDOW_IS_MAPPED (window))
-    {
-      API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window),
-			       setting ? HWND_BOTTOM : HWND_NOTOPMOST,
-			       0, 0, 0, 0,
-			       SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE));
-    }
-
-  gdk_synthesize_window_state (window,
-			       setting ? GDK_WINDOW_STATE_ABOVE : GDK_WINDOW_STATE_BELOW,
-			       setting ? GDK_WINDOW_STATE_BELOW : 0);
-}
-
-void
-gdk_window_focus (GdkWindow *window,
-                  guint32    timestamp)
-{
-  GdkWindowObject *private;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  private = (GdkWindowObject *)window;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_focus: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   _gdk_win32_window_state_to_string (((GdkWindowObject *) window)->state)));
-
-  if (private->state & GDK_WINDOW_STATE_MAXIMIZED)
-    ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWMAXIMIZED);
-  else if (private->state & GDK_WINDOW_STATE_ICONIFIED)
-    ShowWindow (GDK_WINDOW_HWND (window), SW_RESTORE);
-  else if (!IsWindowVisible (GDK_WINDOW_HWND (window)))
-    ShowWindow (GDK_WINDOW_HWND (window), SW_SHOWNORMAL);
-  else
-    ShowWindow (GDK_WINDOW_HWND (window), SW_SHOW);
-
-  SetFocus (GDK_WINDOW_HWND (window));
-}
-
-void
-gdk_window_set_modal_hint (GdkWindow *window,
-			   gboolean   modal)
-{
-  GdkWindowObject *private;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_modal_hint: %p: %s\n",
-			   GDK_WINDOW_HWND (window),
-			   modal ? "YES" : "NO"));
-
-  private = (GdkWindowObject*) window;
-
-  if (modal == private->modal_hint)
-    return;
-
-  private->modal_hint = modal;
-
-#if 0
-  /* Not sure about this one.. -- Cody */
-  if (GDK_WINDOW_IS_MAPPED (window))
-    API_CALL (SetWindowPos, (GDK_WINDOW_HWND (window), 
-			     modal ? HWND_TOPMOST : HWND_NOTOPMOST,
-			     0, 0, 0, 0,
-			     SWP_NOMOVE | SWP_NOSIZE));
-#else
-
-  if (modal)
-    {
-      _gdk_push_modal_window (window);
-      gdk_window_raise (window);
-    }
-  else
-    {
-      _gdk_remove_modal_window (window);
-    }
-
-#endif
-}
-
-void
-gdk_window_set_skip_taskbar_hint (GdkWindow *window,
-				  gboolean   skips_taskbar)
-{
-  static GdkWindow *owner = NULL;
-  //GdkWindowAttr wa;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_skip_taskbar_hint: %p: %s, doing nothing\n",
-			   GDK_WINDOW_HWND (window),
-			   skips_taskbar ? "YES" : "NO"));
-
-  // ### TODO: Need to figure out what to do here.
-  return;
-
-  if (skips_taskbar)
-    {
-#if 0
-      if (owner == NULL)
-		{
-		  wa.window_type = GDK_WINDOW_TEMP;
-		  wa.wclass = GDK_INPUT_OUTPUT;
-		  wa.width = wa.height = 1;
-		  wa.event_mask = 0;
-		  owner = gdk_window_new_internal (NULL, &wa, 0, TRUE);
-		}
-#endif
-
-      SetWindowLongPtr (GDK_WINDOW_HWND (window), GWLP_HWNDPARENT, (LONG_PTR) GDK_WINDOW_HWND (owner));
-
-#if 0 /* Should we also turn off the minimize and maximize buttons? */
-      SetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE,
-		     GetWindowLong (GDK_WINDOW_HWND (window), GWL_STYLE) & ~(WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_SYSMENU));
-     
-      SetWindowPos (GDK_WINDOW_HWND (window), NULL,
-		    0, 0, 0, 0,
-		    SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE |
-		    SWP_NOREPOSITION | SWP_NOSIZE | SWP_NOZORDER);
-#endif
-    }
-  else
-    {
-      SetWindowLongPtr (GDK_WINDOW_HWND (window), GWLP_HWNDPARENT, 0);
-    }
-}
-
-void
-gdk_window_set_skip_pager_hint (GdkWindow *window,
-				gboolean   skips_pager)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  GDK_NOTE (MISC, g_print ("gdk_window_set_skip_pager_hint: %p: %s, doing nothing\n",
-			   GDK_WINDOW_HWND (window),
-			   skips_pager ? "YES" : "NO"));
-}
-
-void
-gdk_window_set_type_hint (GdkWindow        *window,
-			  GdkWindowTypeHint hint)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  GDK_NOTE (MISC,
-	    G_STMT_START{
-	      static GEnumClass *class = NULL;
-	      if (!class)
-		class = g_type_class_ref (GDK_TYPE_WINDOW_TYPE_HINT);
-	      g_print ("gdk_window_set_type_hint: %p: %s\n",
-		       GDK_WINDOW_HWND (window),
-		       g_enum_get_value (class, hint)->value_name);
-	    }G_STMT_END);
-
-  ((GdkWindowImplWin32 *)((GdkWindowObject *)window)->impl)->type_hint = hint;
-
-  update_style_bits (window);
-}
-
-GdkWindowTypeHint
-gdk_window_get_type_hint (GdkWindow *window)
-{
-  g_return_val_if_fail (GDK_IS_WINDOW (window), GDK_WINDOW_TYPE_HINT_NORMAL);
-  
-  if (GDK_WINDOW_DESTROYED (window))
-    return GDK_WINDOW_TYPE_HINT_NORMAL;
-
-  return GDK_WINDOW_IMPL_WIN32 (((GdkWindowObject *) window)->impl)->type_hint;
-}
-
-static void
-gdk_win32_window_shape_combine_region (GdkWindow       *window,
-				       const GdkRegion *shape_region,
-				       gint             offset_x,
-				       gint             offset_y)
-{
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  if (!shape_region)
-    {
-      GDK_NOTE (MISC, g_print ("gdk_win32_window_shape_combine_region: %p: none\n",
-			       GDK_WINDOW_HWND (window)));
-      SetWindowRgn (GDK_WINDOW_HWND (window), NULL, TRUE);
-    }
-  else
-    {
-      HRGN hrgn;
-
-      hrgn = _gdk_win32_gdkregion_to_hrgn (shape_region, 0, 0);
-      
-      GDK_NOTE (MISC, g_print ("gdk_win32_window_shape_combine_region: %p: %p\n",
-			       GDK_WINDOW_HWND (window),
-			       hrgn));
-
-      do_shape_combine_region (window, hrgn, offset_x, offset_y);
-    }
-}
-
-GdkWindow *
-gdk_window_lookup_for_display (GdkDisplay      *display,
-                               GdkNativeWindow  anid)
-{
-  return gdk_win32_window_lookup_for_display (display, anid);
-}
-
-GdkWindow *
-gdk_win32_window_lookup_for_display (GdkDisplay      *display,
-                                     GdkNativeWindow  anid)
-{
-  g_return_val_if_fail (display == _gdk_display, NULL);
-
-  return gdk_window_lookup (anid);
-}
-
-void
-gdk_window_enable_synchronized_configure (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-}
-
-void
-gdk_window_configure_finished (GdkWindow *window)
-{
-  g_return_if_fail (GDK_IS_WINDOW (window));
-}
-
-void
-_gdk_windowing_window_beep (GdkWindow *window)
-{
-  gdk_display_beep (_gdk_display);
-}
-
-void
-gdk_window_set_opacity (GdkWindow *window,
-			gdouble    opacity)
-{
-  LONG exstyle;
-  typedef BOOL (WINAPI *PFN_SetLayeredWindowAttributes) (HWND, COLORREF, BYTE, DWORD);
-  PFN_SetLayeredWindowAttributes setLayeredWindowAttributes = NULL;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_return_if_fail (WINDOW_IS_TOPLEVEL (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  if (opacity < 0)
-    opacity = 0;
-  else if (opacity > 1)
-    opacity = 1;
-
-  exstyle = GetWindowLong (GDK_WINDOW_HWND (window), GWL_EXSTYLE);
-
-  if (!(exstyle & WS_EX_LAYERED))
-    SetWindowLong (GDK_WINDOW_HWND (window),
-		    GWL_EXSTYLE,
-		    exstyle | WS_EX_LAYERED);
-
-  setLayeredWindowAttributes = 
-    (PFN_SetLayeredWindowAttributes)GetProcAddress (GetModuleHandle ("user32.dll"), "SetLayeredWindowAttributes");
-
-  if (setLayeredWindowAttributes)
-    {
-      API_CALL (setLayeredWindowAttributes, (GDK_WINDOW_HWND (window),
-					     0,
-					     opacity * 0xff,
-					     LWA_ALPHA));
-    }
-}
-
-GdkRegion *
-_gdk_windowing_get_shape_for_mask (GdkBitmap *mask)
-{
-  GdkRegion *region;
-  HRGN hrgn = _gdk_win32_bitmap_to_hrgn (mask);
-
-  region = _gdk_win32_hrgn_to_region (hrgn);
-  DeleteObject (hrgn);
-
-  return region;
-}
-
-void
-_gdk_windowing_window_set_composited (GdkWindow *window, gboolean composited)
-{
-}
-
-GdkRegion *
-_gdk_windowing_window_get_shape (GdkWindow *window)
-{
-  HRGN hrgn = CreateRectRgn (0, 0, 0, 0);
-  int  type = GetWindowRgn (GDK_WINDOW_HWND (window), hrgn);
-
-  if (type == SIMPLEREGION || type == COMPLEXREGION)
-    {
-      GdkRegion *region = _gdk_win32_hrgn_to_region (hrgn);
-
-      DeleteObject (hrgn);
-      return region;
-    }
-
-  return NULL;
-}
-
-GdkRegion *
-_gdk_windowing_window_get_input_shape (GdkWindow *window)
-{
-  /* CHECK: are these really supposed to be the same? */
-  return _gdk_windowing_window_get_shape (window);
-}
-
-static gboolean
-_gdk_win32_window_queue_antiexpose (GdkWindow *window,
-				    GdkRegion *area)
-{
-  HRGN hrgn = _gdk_win32_gdkregion_to_hrgn (area, 0, 0);
-
-  GDK_NOTE (EVENTS, g_print ("_gdk_windowing_window_queue_antiexpose: ValidateRgn %p %s\n",
-			     GDK_WINDOW_HWND (window),
-			     _gdk_win32_gdkregion_to_string (area)));
-
-  ValidateRgn (GDK_WINDOW_HWND (window), hrgn);
-
-  DeleteObject (hrgn);
-
-  return FALSE;
-}
-
-/*
- * queue_translation is meant to only move any outstanding invalid area
- * in the given area by dx,dy. A typical example of when its needed is an
- * app with two toplevels where one (A) overlaps the other (B). If the
- * app first moves A so that B is invalidated and then scrolls B before
- * handling the expose. The scroll operation will copy the invalid area
- * to a new position, but when the invalid area is then exposed it only
- * redraws the old areas not the place where the invalid data was copied
- * by the scroll.
- */
-static void
-_gdk_win32_window_queue_translation (GdkWindow *window,
-				     GdkGC     *gc,
-				     GdkRegion *area,
-				     gint       dx,
-				     gint       dy)
-{
-  HRGN hrgn = CreateRectRgn (0, 0, 0, 0);
-  int ret = GetUpdateRgn (GDK_WINDOW_HWND (window), hrgn, FALSE);
-  if (ret == ERROR)
-    WIN32_API_FAILED ("GetUpdateRgn");
-  else if (ret != NULLREGION)
-    {
-      /* Get current updateregion, move any part of it that intersects area by dx,dy */
-      HRGN update = _gdk_win32_gdkregion_to_hrgn (area, 0, 0);
-      ret = CombineRgn (update, hrgn, update, RGN_AND);
-      if (ret == ERROR)
-        WIN32_API_FAILED ("CombineRgn");
-      else if (ret != NULLREGION)
-	{
-	  OffsetRgn (update, dx, dy);
-          API_CALL (InvalidateRgn, (GDK_WINDOW_HWND (window), update, TRUE));
-	}
-      DeleteObject (update);
-    }
-  DeleteObject (hrgn);
-}
-
-static void
-gdk_win32_input_shape_combine_region (GdkWindow *window,
-				      const GdkRegion *shape_region,
-				      gint offset_x,
-				      gint offset_y)
-{
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-  /* CHECK: are these really supposed to be the same? */
-  gdk_win32_window_shape_combine_region (window, shape_region, offset_x, offset_y);
-}
-
-void
-_gdk_windowing_window_process_updates_recurse (GdkWindow *window,
-					       GdkRegion *region)
-{
-  _gdk_window_process_updates_recurse (window, region);
-}
-
-void
-_gdk_windowing_before_process_all_updates (void)
-{
-}
-
-void
-_gdk_windowing_after_process_all_updates (void)
-{
-}
-
-static void
-gdk_window_impl_iface_init (GdkWindowImplIface *iface)
-{
-  iface->show = gdk_win32_window_show;
-  iface->hide = gdk_win32_window_hide;
-  iface->withdraw = gdk_win32_window_withdraw;
-  iface->set_events = gdk_win32_window_set_events;
-  iface->get_events = gdk_win32_window_get_events;
-  iface->raise = gdk_win32_window_raise;
-  iface->lower = gdk_win32_window_lower;
-  iface->restack_under = gdk_win32_window_restack_under;
-  iface->restack_toplevel = gdk_win32_window_restack_toplevel;
-  iface->move_resize = gdk_win32_window_move_resize;
-  iface->set_background = gdk_win32_window_set_background;
-  iface->set_back_pixmap = gdk_win32_window_set_back_pixmap;
-  iface->reparent = gdk_win32_window_reparent;
-  iface->clear_region = gdk_window_win32_clear_region;
-  iface->set_cursor = gdk_win32_window_set_cursor;
-  iface->get_geometry = gdk_win32_window_get_geometry;
-  iface->get_root_coords = gdk_win32_window_get_root_coords;
-  iface->get_pointer = gdk_window_win32_get_pointer;
-  iface->get_deskrelative_origin = gdk_win32_window_get_deskrelative_origin;
-  iface->shape_combine_region = gdk_win32_window_shape_combine_region;
-  iface->input_shape_combine_region = gdk_win32_input_shape_combine_region;
-  iface->set_static_gravities = gdk_win32_window_set_static_gravities;
-  iface->queue_antiexpose = _gdk_win32_window_queue_antiexpose;
-  iface->queue_translation = _gdk_win32_window_queue_translation;
-  iface->destroy = _gdk_win32_window_destroy;
-  iface->input_window_destroy = _gdk_input_window_destroy;
-  iface->input_window_crossing = _gdk_input_crossing_event;
-  /* CHECK: we may not need set_pixmap anymore if setting FALSE */
-  iface->supports_native_bg = TRUE;
-}
-
-gboolean
-gdk_win32_window_is_win32 (GdkWindow *window)
-{
-  return GDK_WINDOW_IS_WIN32 (window);
-}
-
-HWND
-gdk_win32_window_get_impl_hwnd (GdkWindow *window)
-{
-  if (GDK_WINDOW_IS_WIN32 (window))
-    return GDK_WINDOW_HWND (window);
-  return NULL;
-}
-
-
-GdkDrawable *
-gdk_win32_begin_direct_draw_libgtk_only (GdkDrawable *drawable,
-					 GdkGC *gc,
-					 gpointer *priv_data,
-					 gint *x_offset_out,
-					 gint *y_offset_out)
-{
-  GdkDrawable *impl;
-
-  impl = _gdk_drawable_begin_direct_draw (drawable,
-					  gc,
-					  priv_data,
-					  x_offset_out,
-					  y_offset_out);
-
-  return impl;
-}
-
-void
-gdk_win32_end_direct_draw_libgtk_only (gpointer priv_data)
-{
-  _gdk_drawable_end_direct_draw (priv_data);
-}
diff --git a/gdk/win32/gdkwindow-win32.h b/gdk/win32/gdkwindow-win32.h
deleted file mode 100644
index 5c091d7..0000000
--- a/gdk/win32/gdkwindow-win32.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/* GDK - The GIMP Drawing Kit
- * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/*
- * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
- * file for a list of people on the GTK+ Team.  See the ChangeLog
- * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
- */
-
-#ifndef __GDK_WINDOW_WIN32_H__
-#define __GDK_WINDOW_WIN32_H__
-
-#include <gdk/win32/gdkdrawable-win32.h>
-
-G_BEGIN_DECLS
-
-typedef struct _GdkWin32PositionInfo    GdkWin32PositionInfo;
-
-#if 0
-struct _GdkWin32PositionInfo
-{
-  gint x;
-  gint y;
-  gint width;
-  gint height;
-  gint x_offset;		/* Offsets to add to Win32 coordinates */
-  gint y_offset;		/* within window to get GDK coodinates */
-  guint big : 1;
-  guint mapped : 1;
-  guint no_bg : 1;	        /* Set when the window background
-				 * is temporarily unset during resizing
-				 * and scaling
-				 */
-  GdkRectangle clip_rect;	/* visible rectangle of window */
-};
-#endif
-
-
-/* Window implementation for Win32
- */
-
-typedef struct _GdkWindowImplWin32 GdkWindowImplWin32;
-typedef struct _GdkWindowImplWin32Class GdkWindowImplWin32Class;
-
-#define GDK_TYPE_WINDOW_IMPL_WIN32              (_gdk_window_impl_win32_get_type ())
-#define GDK_WINDOW_IMPL_WIN32(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_WINDOW_IMPL_WIN32, GdkWindowImplWin32))
-#define GDK_WINDOW_IMPL_WIN32_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_WINDOW_IMPL_WIN32, GdkWindowImplWin32Class))
-#define GDK_IS_WINDOW_IMPL_WIN32(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_WINDOW_IMPL_WIN32))
-#define GDK_IS_WINDOW_IMPL_WIN32_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_WINDOW_IMPL_WIN32))
-#define GDK_WINDOW_IMPL_WIN32_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GDK_TYPE_WINDOW_IMPL_WIN32, GdkWindowImplWin32Class))
-
-struct _GdkWindowImplWin32
-{
-  GdkDrawableImplWin32 parent_instance;
-
-  gint8 toplevel_window_type;
-
-  HCURSOR hcursor;
-  HICON   hicon_big;
-  HICON   hicon_small;
-
-  /* When VK_PACKET sends us a leading surrogate, it's stashed here.
-   * Later, when another VK_PACKET sends a tailing surrogate, we make up
-   * a full unicode character from them, or discard the leading surrogate,
-   * if the next key is not a tailing surrogate.
-   */
-  wchar_t leading_surrogate_keydown;
-  wchar_t leading_surrogate_keyup;
-
-  /* Window size hints */
-  gint hint_flags;
-  GdkGeometry hints;
-
-  GdkEventMask native_event_mask;
-
-  GdkWindowTypeHint type_hint;
-
-  GdkEventMask extension_events_mask;
-
-  GdkWindow *transient_owner;
-  GSList    *transient_children;
-  gint       num_transients;
-  gboolean   changing_state;
-
-  gint initial_x;
-  gint initial_y;
-
-  guint no_bg : 1;
-  guint inhibit_configure : 1;
-  guint override_redirect : 1;
-};
- 
-struct _GdkWindowImplWin32Class 
-{
-  GdkDrawableImplWin32Class parent_class;
-};
-
-GType _gdk_window_impl_win32_get_type (void);
-
-void  _gdk_win32_window_tmp_unset_bg  (GdkWindow *window,
-				       gboolean   recurse);
-void  _gdk_win32_window_tmp_reset_bg  (GdkWindow *window,
-				       gboolean   recurse);
-
-void  _gdk_win32_window_tmp_unset_parent_bg (GdkWindow *window);
-void  _gdk_win32_window_tmp_reset_parent_bg (GdkWindow *window);
-
-G_END_DECLS
-
-#endif /* __GDK_WINDOW_WIN32_H__ */
diff --git a/gdk/win32/makefile.msc b/gdk/win32/makefile.msc
deleted file mode 100644
index 7a88284..0000000
--- a/gdk/win32/makefile.msc
+++ /dev/null
@@ -1,79 +0,0 @@
-## Makefile for building the GDK DLL with Microsoft C
-## Use: nmake -f makefile.msc
-
-################################################################
-
-# Nothing much configurable below
-
-TOP = ../../..
-!INCLUDE $(TOP)/glib/build/win32/make.msc
-
-# Location of the Wintab toolkit. Downloadable from http://www.pointing.com.
-# definition should possibly go to build/win32/module.def, too.
-!IFNDEF WTKIT
-WTKIT = $(TOP)\wtkit126
-!ENDIF
-
-GTK_VER=2.0
-
-DEFINES = \
-	-DHAVE_CONFIG_H -DINSIDE_GDK_WIN32 -DGDK_VERSION=\"$(GTK_VER)\" \
-	-DGDK_COMPILATION -DG_LOG_DOMAIN=\"Gdk\"
-
-INCLUDES = -FImsvc_recommended_pragmas.h \
-	-I. -I.. -I..\.. $(GLIB_CFLAGS) $(GDK_PIXBUF_CFLAGS) \
-	$(PANGO_CFLAGS) $(CAIRO_CFLAGS) \
-	-I$(WTKIT)\include -I$(GLIB) \
-
-all: \
-	..\..\config.h	\
-	..\gdkconfig.h \
-	gdk-win32.lib \
-	gdk.res
-
-gdk_win32_OBJECTS = \
-	gdkapplaunchcontext-win32.obj \
-	gdkcolor-win32.obj \
-	gdkcursor-win32.obj \
-	gdkdnd-win32.obj \
-	gdkdisplay-win32.obj \
-	gdkdrawable-win32.obj \
-	gdkevents-win32.obj \
-	gdkfont-win32.obj \
-	gdkgc-win32.obj \
-	gdkgeometry-win32.obj \
-	gdkglobals-win32.obj \
-	gdkim-win32.obj \
-	gdkimage-win32.obj \
-	gdkinput.obj \
-	gdkinput-win32.obj \
-	gdkkeys-win32.obj \
-	gdkmain-win32.obj \
-	gdkpixmap-win32.obj \
-	gdkproperty-win32.obj \
-#	gdkregion-win32.obj \
-	gdkscreen-win32.obj \
-	gdkselection-win32.obj \
-	gdkspawn-win32.obj \
-	gdktestutils-win32.obj \
-	gdkvisual-win32.obj \
-	gdkwin32id.obj \
-	gdkwindow-win32.obj
-
-..\..\config.h : ..\..\config.h.win32
-	copy ..\..\config.h.win32 ..\..\config.h
-
-..\gdkconfig.h : ..\gdkconfig.h.win32
-	copy ..\gdkconfig.h.win32 ..\gdkconfig.h
-
-gdk.res : rc\gdk.rc
-	rc -DBUILDNUMBER=0 -r -fo gdk.res rc\gdk.rc
-
-gdk-win32.lib : $(gdk_win32_OBJECTS)
-	lib -out:gdk-win32.lib $(gdk_win32_OBJECTS)
-
-clean::
-	del *.obj
-	del *.lib
-	del *.err
-	del *.res
diff --git a/gdk/win32/pktdef.h b/gdk/win32/pktdef.h
deleted file mode 100644
index b8695f0..0000000
--- a/gdk/win32/pktdef.h
+++ /dev/null
@@ -1,233 +0,0 @@
-/* -------------------------------- pktdef.h -------------------------------- */
-/* Combined 16 & 32-bit version. */
-
-/*------------------------------------------------------------------------------
-The text and information contained in this file may be freely used,
-copied, or distributed without compensation or licensing restrictions.
-
-This file is copyright 1991-1998 by LCS/Telegraphics.
-------------------------------------------------------------------------------*/
-/*------------------------------------------------------------------------------
-
-How to use pktdef.h:
-
-1. Include wintab.h
-2. if using just one packet format:
-	a. Define PACKETDATA and PACKETMODE as or'ed combinations of WTPKT bits
-	   (use the PK_* identifiers).
-	b. Include pktdef.h.
-	c. The generated structure typedef will be called PACKET.  Use PACKETDATA
-	   and PACKETMODE to fill in the LOGCONTEXT structure.
-3. If using multiple packet formats, for each one:
-	a. Define PACKETNAME. Its text value will be a prefix for this packet's
-	   parameters and names.
-	b. Define <PACKETNAME>PACKETDATA and <PACKETNAME>PACKETMODE similar to
-	   2.a. above.
-	c. Include pktdef.h.
-	d. The generated structure typedef will be called
-	   <PACKETNAME>PACKET. Compare with 2.c. above and example #2 below.
-4. If using extension packet data, do the following additional steps
-   for each extension:
-	a. Before including pktdef.h, define <PACKETNAME>PACKET<EXTENSION>
-	   as either PKEXT_ABSOLUTE or PKEXT_RELATIVE.
-	b. The generated structure typedef will contain a field for the
-	   extension data.
-	c. Scan the WTI_EXTENSION categories to find the extension's
-	   packet mask bit.
-	d. OR the packet mask bit with <PACKETNAME>PACKETDATA and use the
-	   result in the lcPktData field of the LOGCONTEXT structure.
-	e. If <PACKETNAME>PACKET<EXTENSION> was PKEXT_RELATIVE, OR the
-	   packet mask bit with <PACKETNAME>PACKETMODE and use the result
-	   in the lcPktMode field of the LOGCONTEXT structure.
-
-
-Example #1.	-- single packet format
-
-#include <wintab.h>
-#define PACKETDATA	PK_X | PK_Y | PK_BUTTONS	/@ x, y, buttons @/
-#define PACKETMODE	PK_BUTTONS					/@ buttons relative mode @/
-#include <pktdef.h>
-...
-	lc.lcPktData = PACKETDATA;
-	lc.lcPktMode = PACKETMODE;
-
-Example #2. -- multiple formats
-
-#include <wintab.h>
-#define PACKETNAME		MOE
-#define MOEPACKETDATA	PK_X | PK_Y | PK_BUTTONS	/@ x, y, buttons @/
-#define MOEPACKETMODE	PK_BUTTONS					/@ buttons relative mode @/
-#include <pktdef.h>
-#define PACKETNAME		LARRY
-#define LARRYPACKETDATA	PK_Y | PK_Z | PK_BUTTONS	/@ y, z, buttons @/
-#define LARRYPACKETMODE	PK_BUTTONS					/@ buttons relative mode @/
-#include <pktdef.h>
-#define PACKETNAME		CURLY
-#define CURLYPACKETDATA	PK_X | PK_Z | PK_BUTTONS	/@ x, z, buttons @/
-#define CURLYPACKETMODE	PK_BUTTONS					/@ buttons relative mode @/
-#include <pktdef.h>
-...
-	lcMOE.lcPktData = MOEPACKETDATA;
-	lcMOE.lcPktMode = MOEPACKETMODE;
-...
-	lcLARRY.lcPktData = LARRYPACKETDATA;
-	lcLARRY.lcPktMode = LARRYPACKETMODE;
-...
-	lcCURLY.lcPktData = CURLYPACKETDATA;
-	lcCURLY.lcPktMode = CURLYPACKETMODE;
-
-Example #3. -- extension packet data "XFOO".
-	
-#include <wintab.h>
-#define PACKETDATA	PK_X | PK_Y | PK_BUTTONS	/@ x, y, buttons @/
-#define PACKETMODE	PK_BUTTONS					/@ buttons relative mode @/
-#define PACKETXFOO	PKEXT_ABSOLUTE				/@ XFOO absolute mode @/
-#include <pktdef.h>
-...
-UINT ScanExts(UINT wTag)
-{
-	UINT i;
-	UINT wScanTag;
-
-	/@ scan for wTag's info category. @/
-	for (i = 0; WTInfo(WTI_EXTENSIONS + i, EXT_TAG, &wScanTag); i++) {
-		 if (wTag == wScanTag) {
-			/@ return category offset from WTI_EXTENSIONS. @/
-			return i;
-		}
-	}
-	/@ return error code. @/
-	return 0xFFFF;
-}
-...
-	lc.lcPktData = PACKETDATA;
-	lc.lcPktMode = PACKETMODE;
-#ifdef PACKETXFOO
-	categoryXFOO = ScanExts(WTX_XFOO);
-	WTInfo(WTI_EXTENSIONS + categoryXFOO, EXT_MASK, &maskXFOO);
-	lc.lcPktData |= maskXFOO;
-#if PACKETXFOO == PKEXT_RELATIVE
-	lc.lcPktMode |= maskXFOO;
-#endif
-#endif
-	WTOpen(hWnd, &lc, TRUE);
-
-
-------------------------------------------------------------------------------*/
-#ifdef __cplusplus
-extern "C" {
-#endif	/* __cplusplus */
-
-#ifndef PACKETNAME
-	/* if no packet name prefix */
-	#define __PFX(x)	x
-	#define __IFX(x,y)	x ## y
-#else
-	/* add prefixes and infixes to packet format names */
-	#define __PFX(x)		__PFX2(PACKETNAME,x)
-	#define __PFX2(p,x)		__PFX3(p,x)
-	#define __PFX3(p,x)		p ## x
-	#define __IFX(x,y)		__IFX2(x,PACKETNAME,y)
-	#define __IFX2(x,i,y)	__IFX3(x,i,y)
-	#define __IFX3(x,i,y)	x ## i ## y
-#endif
-
-#define __SFX2(x,s)		__SFX3(x,s)
-#define __SFX3(x,s)		x ## s
-
-#define __TAG  	__IFX(tag,PACKET)
-#define __TYPES	__PFX(PACKET), * __IFX(P,PACKET), NEAR * __IFX(NP,PACKET), \
-					FAR * __IFX(LP,PACKET)
-
-#define __DATA		(__PFX(PACKETDATA))
-#define __MODE		(__PFX(PACKETMODE))
-#define __EXT(x)	__SFX2(__PFX(PACKET),x)
-
-	
-typedef struct __TAG {
-	#if (__DATA & PK_CONTEXT)
-		HCTX			pkContext;
-	#endif
-	#if (__DATA & PK_STATUS)
-		UINT			pkStatus;
-	#endif
-	#if (__DATA & PK_TIME)
-		DWORD			pkTime;
-	#endif
-	#if (__DATA & PK_CHANGED)
-		WTPKT			pkChanged;
-	#endif
-	#if (__DATA & PK_SERIAL_NUMBER)
-		UINT			pkSerialNumber;
-	#endif
-	#if (__DATA & PK_CURSOR)
-		UINT			pkCursor;
-	#endif
-	#if (__DATA & PK_BUTTONS)
-		DWORD			pkButtons;
-	#endif
-	#if (__DATA & PK_X)
-		LONG			pkX;
-	#endif
-	#if (__DATA & PK_Y)
-		LONG			pkY;
-	#endif
-	#if (__DATA & PK_Z)
-		LONG			pkZ;
-	#endif
-	#if (__DATA & PK_NORMAL_PRESSURE)
-		#if (__MODE & PK_NORMAL_PRESSURE)
-			/* relative */
-			int			pkNormalPressure;
-		#else
-			/* absolute */
-			UINT		pkNormalPressure;
-		#endif
-	#endif
-	#if (__DATA & PK_TANGENT_PRESSURE)
-		#if (__MODE & PK_TANGENT_PRESSURE)
-			/* relative */
-			int			pkTangentPressure;
-		#else
-			/* absolute */
-			UINT		pkTangentPressure;
-		#endif
-	#endif
-	#if (__DATA & PK_ORIENTATION)
-		ORIENTATION		pkOrientation;
-	#endif
-	#if (__DATA & PK_ROTATION)
-		ROTATION		pkRotation; /* 1.1 */
-	#endif
-
-#ifndef NOWTEXTENSIONS
-	/* extensions begin here. */
-	#if (__EXT(FKEYS) == PKEXT_RELATIVE) || (__EXT(FKEYS) == PKEXT_ABSOLUTE)
-		UINT			pkFKeys;
-	#endif
-	#if (__EXT(TILT) == PKEXT_RELATIVE) || (__EXT(TILT) == PKEXT_ABSOLUTE)
-		TILT			pkTilt;
-	#endif
-#endif
-
-} __TYPES ;
-
-#undef PACKETNAME
-#undef __TAG
-#undef __TAG2
-#undef __TYPES
-#undef __TYPES2
-#undef __DATA
-#undef __MODE
-#undef __PFX
-#undef __PFX2
-#undef __PFX3
-#undef __IFX
-#undef __IFX2
-#undef __IFX3
-#undef __SFX2
-#undef __SFX3
-
-#ifdef __cplusplus
-}
-#endif	/* __cplusplus */
diff --git a/gdk/win32/rc/Makefile.am b/gdk/win32/rc/Makefile.am
deleted file mode 100644
index 9171923..0000000
--- a/gdk/win32/rc/Makefile.am
+++ /dev/null
@@ -1,15 +0,0 @@
-include $(top_srcdir)/Makefile.decl
-
-EXTRA_DIST += \
-	gdk.rc \
-	gdk.rc.in \
-	gtk.ico
-
-if USE_WIN32
-noinst_DATA = gdk-win32-res.o
-endif
-
-gdk-win32-res.o : gdk.rc gtk.ico
-	$(WINDRES) gdk.rc $@
-
--include $(top_srcdir)/git.mk
diff --git a/gdk/win32/rc/Makefile.in b/gdk/win32/rc/Makefile.in
deleted file mode 100644
index 7a6d552..0000000
--- a/gdk/win32/rc/Makefile.in
+++ /dev/null
@@ -1,657 +0,0 @@
-# Makefile.in generated by automake 1.16.5 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2021 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-# GTK+ - The GIMP Toolkit
-
-VPATH = @srcdir@
-am__is_gnu_make = { \
-  if test -z '$(MAKELEVEL)'; then \
-    false; \
-  elif test -n '$(MAKE_HOST)'; then \
-    true; \
-  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
-    true; \
-  else \
-    false; \
-  fi; \
-}
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = gdk/win32/rc
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/introspection.m4 \
-	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
-	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
-	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES = gdk.rc
-CONFIG_CLEAN_VPATH_FILES =
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-SOURCES =
-DIST_SOURCES =
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-DATA = $(noinst_DATA)
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/gdk.rc.in \
-	$(top_srcdir)/Makefile.decl
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AS = @AS@
-ATK_PREFIX = @ATK_PREFIX@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-BASE_DEPENDENCIES_CFLAGS = @BASE_DEPENDENCIES_CFLAGS@
-BASE_DEPENDENCIES_LIBS = @BASE_DEPENDENCIES_LIBS@
-CAIRO_BACKEND_CFLAGS = @CAIRO_BACKEND_CFLAGS@
-CAIRO_BACKEND_LIBS = @CAIRO_BACKEND_LIBS@
-CAIRO_PREFIX = @CAIRO_PREFIX@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCAS = @CCAS@
-CCASDEPMODE = @CCASDEPMODE@
-CCASFLAGS = @CCASFLAGS@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CSCOPE = @CSCOPE@
-CTAGS = @CTAGS@
-CUPS_API_MAJOR = @CUPS_API_MAJOR@
-CUPS_API_MINOR = @CUPS_API_MINOR@
-CUPS_CFLAGS = @CUPS_CFLAGS@
-CUPS_CONFIG = @CUPS_CONFIG@
-CUPS_LIBS = @CUPS_LIBS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DB2HTML = @DB2HTML@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
-DIRECTFB_LIBS = @DIRECTFB_LIBS@
-DLLTOOL = @DLLTOOL@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-ETAGS = @ETAGS@
-EXEEXT = @EXEEXT@
-EXE_MANIFEST_ARCHITECTURE = @EXE_MANIFEST_ARCHITECTURE@
-FGREP = @FGREP@
-FILECMD = @FILECMD@
-GAIL_INET_LIBS = @GAIL_INET_LIBS@
-GAIL_LT_CURRENT_MINUS_AGE = @GAIL_LT_CURRENT_MINUS_AGE@
-GAIL_LT_VERSION_INFO = @GAIL_LT_VERSION_INFO@
-GDK_DEP_CFLAGS = @GDK_DEP_CFLAGS@
-GDK_DEP_LIBS = @GDK_DEP_LIBS@
-GDK_EXTRA_CFLAGS = @GDK_EXTRA_CFLAGS@
-GDK_EXTRA_LIBS = @GDK_EXTRA_LIBS@
-GDK_PACKAGES = @GDK_PACKAGES@
-GDK_PIXBUF_CSOURCE = @GDK_PIXBUF_CSOURCE@
-GDK_PIXBUF_LIBS = @GDK_PIXBUF_LIBS@
-GDK_WLIBS = @GDK_WLIBS@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GLIB_CFLAGS = @GLIB_CFLAGS@
-GLIB_COMPILE_RESOURCES = @GLIB_COMPILE_RESOURCES@
-GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GLIB_LIBS = @GLIB_LIBS@
-GLIB_MKENUMS = @GLIB_MKENUMS@
-GLIB_PREFIX = @GLIB_PREFIX@
-GMODULE_CFLAGS = @GMODULE_CFLAGS@
-GMODULE_LIBS = @GMODULE_LIBS@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GOBJECT_QUERY = @GOBJECT_QUERY@
-GREP = @GREP@
-GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_CHECK_PATH = @GTKDOC_CHECK_PATH@
-GTKDOC_DEPS_CFLAGS = @GTKDOC_DEPS_CFLAGS@
-GTKDOC_DEPS_LIBS = @GTKDOC_DEPS_LIBS@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
-GTK_API_VERSION = @GTK_API_VERSION@
-GTK_BINARY_AGE = @GTK_BINARY_AGE@
-GTK_BINARY_VERSION = @GTK_BINARY_VERSION@
-GTK_DEBUG_FLAGS = @GTK_DEBUG_FLAGS@
-GTK_DEP_CFLAGS = @GTK_DEP_CFLAGS@
-GTK_DEP_LIBS = @GTK_DEP_LIBS@
-GTK_EXTRA_CFLAGS = @GTK_EXTRA_CFLAGS@
-GTK_EXTRA_LIBS = @GTK_EXTRA_LIBS@
-GTK_INTERFACE_AGE = @GTK_INTERFACE_AGE@
-GTK_MAJOR_VERSION = @GTK_MAJOR_VERSION@
-GTK_MICRO_VERSION = @GTK_MICRO_VERSION@
-GTK_MINOR_VERSION = @GTK_MINOR_VERSION@
-GTK_PACKAGES = @GTK_PACKAGES@
-GTK_UPDATE_ICON_CACHE = @GTK_UPDATE_ICON_CACHE@
-GTK_VERSION = @GTK_VERSION@
-GTK_XIM_FLAGS = @GTK_XIM_FLAGS@
-HAVE_HTTP_AUTHSTRING = @HAVE_HTTP_AUTHSTRING@
-HTML_DIR = @HTML_DIR@
-INCLUDED_IMMODULE_DEFINE = @INCLUDED_IMMODULE_DEFINE@
-INCLUDED_IMMODULE_OBJ = @INCLUDED_IMMODULE_OBJ@
-INDENT = @INDENT@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTL_MACOSX_LIBS = @INTL_MACOSX_LIBS@
-INTROSPECTION_CFLAGS = @INTROSPECTION_CFLAGS@
-INTROSPECTION_COMPILER = @INTROSPECTION_COMPILER@
-INTROSPECTION_GENERATE = @INTROSPECTION_GENERATE@
-INTROSPECTION_GIRDIR = @INTROSPECTION_GIRDIR@
-INTROSPECTION_LIBS = @INTROSPECTION_LIBS@
-INTROSPECTION_MAKEFILE = @INTROSPECTION_MAKEFILE@
-INTROSPECTION_SCANNER = @INTROSPECTION_SCANNER@
-INTROSPECTION_TYPELIBDIR = @INTROSPECTION_TYPELIBDIR@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBTOOL_EXPORT_OPTIONS = @LIBTOOL_EXPORT_OPTIONS@
-LIB_EXE_MACHINE_FLAG = @LIB_EXE_MACHINE_FLAG@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-LT_CURRENT_MINUS_AGE = @LT_CURRENT_MINUS_AGE@
-LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
-LT_VERSION_INFO = @LT_VERSION_INFO@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MATH_LIB = @MATH_LIB@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANGO_PREFIX = @PANGO_PREFIX@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PERL = @PERL@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-RANLIB = @RANLIB@
-REBUILD = @REBUILD@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WINDRES = @WINDRES@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-XMLCATALOG = @XMLCATALOG@
-XML_CATALOG_FILE = @XML_CATALOG_FILE@
-XSLTPROC = @XSLTPROC@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-gdktarget = @gdktarget@
-gdktargetlib = @gdktargetlib@
-gtktargetlib = @gtktargetlib@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-ms_librarian = @ms_librarian@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-runstatedir = @runstatedir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-GTESTER = gtester		# in $PATH for non-GLIB packages
-GTESTER_REPORT = gtester-report		# in $PATH for non-GLIB packages
-
-# initialize variables for unconditional += appending
-EXTRA_DIST = gdk.rc gdk.rc.in gtk.ico
-TEST_PROGS = 
-
-### testing rules
-
-# Xvfb based test rules
-XVFB = Xvfb -ac -noreset -screen 0 800x600x16
-XIDS = 101 102 103 104 105 106 107 197 199 211 223 227 293 307 308 309 310 311 \
-   491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 \
-   991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 \
-  1008 1009 4703 4721 4723 4729 4733 4751 9973 9974 9975 9976 9977 9978 9979 \
-  9980 9981 9982 9983 9984 9985 9986 9987 9988 9989 9990 9991 9992 9993 9994 \
-  9995 9996 9997 9998 9999
-
-SKIP_GDKTARGET = \
-	test "$(gdktarget)" != "x11" \
-	&& echo "Gtk+Tests:INFO: Skipping GUI tests for non-X11 target."
-
-XVFB_START = \
-	${XVFB} -help 2>/dev/null 1>&2 \
-	&& XID=`for id in $(XIDS) ; do test -e /tmp/.X$$id-lock || { echo $$id; exit 0; }; done; exit 1` \
-	&& { ${XVFB} :$$XID -screen 0 800x600x16 -nolisten tcp -auth /dev/null >/dev/null 2>&1 & \
-	       trap "kill -15 $$! " 0 HUP INT QUIT TRAP USR1 PIPE TERM ; } \
-	|| { echo "Gtk+Tests:ERROR: Failed to start Xvfb environment for X11 target tests."; exit 1; } \
-	&& DISPLAY=:$$XID && export DISPLAY
-
-@USE_WIN32_TRUE@noinst_DATA = gdk-win32-res.o
-all: all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/Makefile.decl $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu gdk/win32/rc/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu gdk/win32/rc/Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
-	esac;
-$(top_srcdir)/Makefile.decl $(am__empty):
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-gdk.rc: $(top_builddir)/config.status $(srcdir)/gdk.rc.in
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-tags TAGS:
-
-ctags CTAGS:
-
-cscope cscopelist:
-
-distdir: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) distdir-am
-
-distdir-am: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-	$(MAKE) $(AM_MAKEFLAGS) check-local
-check: check-am
-all-am: Makefile $(DATA)
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: check-am install-am install-strip
-
-.PHONY: all all-am check check-am check-local clean clean-generic \
-	clean-libtool cscopelist-am ctags-am distclean \
-	distclean-generic distclean-libtool distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am tags-am uninstall \
-	uninstall-am
-
-.PRECIOUS: Makefile
-
-# call as: $(XVFB_START) && someprogram
-
-# test: run all tests in cwd and subdirs
-test: test-cwd test-recurse
-# test-cwd: run tests in cwd
-test-cwd: ${TEST_PROGS}
-	@$(SKIP_GDKTARGET) || test -z "${TEST_PROGS}" || { \
-	  $(XVFB_START) && { set -e; $(TESTS_ENVIRONMENT) ${GTESTER} --verbose ${TEST_PROGS}; }; \
-	}
-# test-report: run tests in subdirs and generate report
-# perf-report: run tests in subdirs with -m perf and generate report
-# full-report: like test-report: with -m perf and -m slow
-test-report perf-report full-report:	${TEST_PROGS}
-	@ ignore_logdir=true ; \
-	  if test -z "$$GTESTER_LOGDIR" ; then \
-	    GTESTER_LOGDIR=`mktemp -d "\`pwd\`/.testlogs-XXXXXX"`; export GTESTER_LOGDIR ; \
-	    ignore_logdir=false ; \
-	  fi ; \
-	  $(SKIP_GDKTARGET) || test -z "${TEST_PROGS}" || { \
-	    case $@ in \
-	    test-report) test_options="-k";; \
-	    perf-report) test_options="-k -m=perf";; \
-	    full-report) test_options="-k -m=perf -m=slow";; \
-	    esac ; \
-	    $(XVFB_START) && { \
-	      set -e; \
-	      if test -z "$$GTESTER_LOGDIR" ; then \
-	        ${GTESTER} --verbose $$test_options -o test-report.xml ${TEST_PROGS} ; \
-	      elif test -n "${TEST_PROGS}" ; then \
-	        ${GTESTER} --verbose $$test_options -o `mktemp "$$GTESTER_LOGDIR/log-XXXXXX"` ${TEST_PROGS} ; \
-	      fi ; \
-	    }; \
-	  }; \
-	  $$ignore_logdir || { \
-	    echo '<?xml version="1.0"?>' > $@.xml ; \
-	    echo '<report-collection>'  >> $@.xml ; \
-	    for lf in `ls -L "$$GTESTER_LOGDIR"/.` ; do \
-	      sed '1,1s/^<?xml\b[^>?]*?>//' <"$$GTESTER_LOGDIR"/"$$lf" >> $@.xml ; \
-	    done ; \
-	    echo >> $@.xml ; \
-	    echo '</report-collection>' >> $@.xml ; \
-	    rm -rf "$$GTESTER_LOGDIR"/ ; \
-	    ${GTESTER_REPORT} --version 2>/dev/null 1>&2 ; test "$$?" != 0 || ${GTESTER_REPORT} $@.xml >$@.html ; \
-	  }
-.PHONY: test test-cwd test-recurse test-report perf-report full-report
-# run make test-cwd as part of make check
-check-local: test-cwd
-
-gdk-win32-res.o : gdk.rc gtk.ico
-	$(WINDRES) gdk.rc $@
-
--include $(top_srcdir)/git.mk
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff --git a/gdk/win32/rc/gdk.rc b/gdk/win32/rc/gdk.rc
deleted file mode 100644
index 5eb44d5..0000000
--- a/gdk/win32/rc/gdk.rc
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <winver.h>
-
-GTK_ICON		ICON			"./gtk.ico"
-
-VS_VERSION_INFO VERSIONINFO
-  FILEVERSION 2,24,33,0
-  PRODUCTVERSION 2,24,33,0
-  FILEFLAGSMASK 0
-  FILEFLAGS 0
-  FILEOS VOS__WINDOWS32
-  FILETYPE VFT_DLL
-  FILESUBTYPE VFT2_UNKNOWN
-  BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-      BLOCK "040904B0"
-      BEGIN
-	VALUE "CompanyName", "The GTK developer community"
-	VALUE "FileDescription", "GIMP Drawing Kit"
-	VALUE "FileVersion", "2.24.33.0"
-	VALUE "InternalName", "libgdk-win32-2.0-0"
-	VALUE "LegalCopyright", "Copyright  1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald. Modified by the GTK+ Team and others 1997-2005."
-	VALUE "OriginalFilename", "libgdk-win32-2.0-0.dll"
-	VALUE "ProductName", "GTK+"
-	VALUE "ProductVersion", "2.24.33"
-      END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-      VALUE "Translation", 0x409, 1200
-    END
-  END
diff --git a/gdk/win32/rc/gdk.rc.in b/gdk/win32/rc/gdk.rc.in
deleted file mode 100644
index a1a00fd..0000000
--- a/gdk/win32/rc/gdk.rc.in
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <winver.h>
-
-GTK_ICON		ICON			"@srcdir@/gtk.ico"
-
-VS_VERSION_INFO VERSIONINFO
-  FILEVERSION @GTK_MAJOR_VERSION@,@GTK_MINOR_VERSION@,@GTK_MICRO_VERSION@,0
-  PRODUCTVERSION @GTK_MAJOR_VERSION@,@GTK_MINOR_VERSION@,@GTK_MICRO_VERSION@,0
-  FILEFLAGSMASK 0
-  FILEFLAGS 0
-  FILEOS VOS__WINDOWS32
-  FILETYPE VFT_DLL
-  FILESUBTYPE VFT2_UNKNOWN
-  BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-      BLOCK "040904B0"
-      BEGIN
-	VALUE "CompanyName", "The GTK developer community"
-	VALUE "FileDescription", "GIMP Drawing Kit"
-	VALUE "FileVersion", "@GTK_VERSION@.0"
-	VALUE "InternalName", "libgdk-win32-@GTK_API_VERSION@-@LT_CURRENT_MINUS_AGE@"
-	VALUE "LegalCopyright", "Copyright  1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald. Modified by the GTK+ Team and others 1997-2005."
-	VALUE "OriginalFilename", "libgdk-win32-@GTK_API_VERSION@-@LT_CURRENT_MINUS_AGE@.dll"
-	VALUE "ProductName", "GTK+"
-	VALUE "ProductVersion", "@GTK_VERSION@"
-      END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-      VALUE "Translation", 0x409, 1200
-    END
-  END
diff --git a/gdk/win32/rc/gtk.ico b/gdk/win32/rc/gtk.ico
deleted file mode 100644
index 5e13f95..0000000
Binary files a/gdk/win32/rc/gtk.ico and /dev/null differ
diff --git a/gdk/win32/wintab.h b/gdk/win32/wintab.h
deleted file mode 100644
index 04b8825..0000000
--- a/gdk/win32/wintab.h
+++ /dev/null
@@ -1,863 +0,0 @@
-/* -------------------------------- wintab.h -------------------------------- */
-/* Combined 16 & 32-bit version. */
-
-/*------------------------------------------------------------------------------
-The text and information contained in this file may be freely used,
-copied, or distributed without compensation or licensing restrictions.
-
-This file is copyright 1991-1998 by LCS/Telegraphics.
-------------------------------------------------------------------------------*/
-
-#ifndef _INC_WINTAB     /* prevent multiple includes */
-#define _INC_WINTAB
-
-#ifdef __cplusplus
-extern "C" {
-#endif	/* __cplusplus */
-
-/* -------------------------------------------------------------------------- */
-/* Messages */
-#ifndef NOWTMESSAGES
-
-	#define WT_DEFBASE		0x7FF0
-	#define WT_MAXOFFSET	0xF
-
-	#define _WT_PACKET(b)		((b)+0)
-	#define _WT_CTXOPEN(b)		((b)+1)
-	#define _WT_CTXCLOSE(b)		((b)+2)
-	#define _WT_CTXUPDATE(b)	((b)+3)
-	#define _WT_CTXOVERLAP(b)	((b)+4)
-	#define _WT_PROXIMITY(b)	((b)+5)
-	#define _WT_INFOCHANGE(b)	((b)+6)
-	#define _WT_CSRCHANGE(b)	((b)+7) /* 1.1 */
-	#define _WT_MAX(b)			((b)+WT_MAXOFFSET)
-	
-	#define WT_PACKET			_WT_PACKET(WT_DEFBASE)
-	#define WT_CTXOPEN			_WT_CTXOPEN(WT_DEFBASE)
-	#define WT_CTXCLOSE			_WT_CTXCLOSE(WT_DEFBASE)
-	#define WT_CTXUPDATE		_WT_CTXUPDATE(WT_DEFBASE)
-	#define WT_CTXOVERLAP		_WT_CTXOVERLAP(WT_DEFBASE)
-	#define WT_PROXIMITY		_WT_PROXIMITY(WT_DEFBASE)
-	#define WT_INFOCHANGE		_WT_INFOCHANGE(WT_DEFBASE)
-	#define WT_CSRCHANGE		_WT_CSRCHANGE(WT_DEFBASE) /* 1.1 */
-	#define WT_MAX				_WT_MAX(WT_DEFBASE)
-
-#endif
-
-/* -------------------------------------------------------------------------- */
-/* -------------------------------------------------------------------------- */
-/* Data Types */
-
-/* -------------------------------------------------------------------------- */
-/* COMMON DATA DEFS */
-
-DECLARE_HANDLE(HMGR);		/* manager handle */
-DECLARE_HANDLE(HCTX);		/* context handle */
-DECLARE_HANDLE(HWTHOOK);	/* hook handle */
-
-typedef DWORD WTPKT;		/* packet mask */
-
-
-#ifndef NOWTPKT
-
-	/* WTPKT bits */
-	#define PK_CONTEXT			0x0001	/* reporting context */
-	#define PK_STATUS			0x0002	/* status bits */
-	#define PK_TIME				0x0004	/* time stamp */
-	#define PK_CHANGED			0x0008	/* change bit vector */
-	#define PK_SERIAL_NUMBER   	0x0010	/* packet serial number */
-	#define PK_CURSOR			0x0020	/* reporting cursor */
-	#define PK_BUTTONS			0x0040	/* button information */
-	#define PK_X				0x0080	/* x axis */
-	#define PK_Y				0x0100	/* y axis */
-	#define PK_Z				0x0200	/* z axis */
-	#define PK_NORMAL_PRESSURE	0x0400	/* normal or tip pressure */
-	#define PK_TANGENT_PRESSURE	0x0800	/* tangential or barrel pressure */
-	#define PK_ORIENTATION		0x1000	/* orientation info: tilts */
-	#define PK_ROTATION			0x2000	/* rotation info; 1.1 */
-
-#endif
-
-typedef DWORD FIX32;				/* fixed-point arithmetic type */
-
-#ifndef NOFIX32
-	#define INT(x)	HIWORD(x)
-	#define FRAC(x)	LOWORD(x)
-
-	#define CASTFIX32(x)	((FIX32)((x)*65536L))
-
-	#define ROUND(x)		(INT(x) + (FRAC(x) > (WORD)0x8000))
-
-	#define FIX_MUL(c, a, b)						\
-		(c = (((DWORD)FRAC(a) * FRAC(b)) >> 16) +	\
-			(DWORD)INT(a) * FRAC(b) +				\
-			(DWORD)INT(b) * FRAC(a) +				\
-			((DWORD)INT(a) * INT(b) << 16))
-
-	#ifdef _WINDLL
-		#define FIX_DIV_SC static
-	#else
-		#define FIX_DIV_SC
-	#endif
-
-	#define FIX_DIV(c, a, b)					\
-		{							   			\
-			FIX_DIV_SC DWORD temp, rem, btemp;	\
-									   			\
-			/* fraction done bytewise */		\
-			temp = ((a / b) << 16);				\
-			rem = a % b;			   			\
-			btemp = b;							\
-			if (INT(btemp) < 256) {				\
-				rem <<= 8;				   		\
-			}									\
-			else {								\
-				btemp >>= 8;					\
-			}									\
-			temp += ((rem / btemp) << 8);  		\
-			rem %= btemp;			   			\
-			rem <<= 8;				   			\
-			temp += rem / btemp;		   		\
-			c = temp;				   			\
-		}
-#endif
-
-/* -------------------------------------------------------------------------- */
-/* INFO DATA DEFS */
-
-#ifndef NOWTINFO
-
-#ifndef NOWTAXIS
-
-typedef struct tagAXIS {
-	LONG	axMin;
-	LONG	axMax;
-	UINT	axUnits;
-	FIX32	axResolution;
-} AXIS, *PAXIS, NEAR *NPAXIS, FAR *LPAXIS;
-
-	/* unit specifiers */
-	#define TU_NONE			0
-	#define TU_INCHES		1
-	#define TU_CENTIMETERS	2
-	#define TU_CIRCLE		3
-
-#endif
-
-#ifndef NOWTSYSBUTTONS
-
-/* system button assignment values */
-#define SBN_NONE		0x00
-#define SBN_LCLICK		0x01
-#define SBN_LDBLCLICK	0x02
-#define SBN_LDRAG		0x03
-#define SBN_RCLICK		0x04
-#define SBN_RDBLCLICK	0x05
-#define SBN_RDRAG		0x06
-#define SBN_MCLICK		0x07
-#define SBN_MDBLCLICK	0x08
-#define SBN_MDRAG		0x09
-/* for Pen Windows */
-#define SBN_PTCLICK		0x10
-#define SBN_PTDBLCLICK	0x20
-#define SBN_PTDRAG		0x30
-#define SBN_PNCLICK		0x40
-#define SBN_PNDBLCLICK	0x50
-#define SBN_PNDRAG		0x60
-#define SBN_P1CLICK		0x70
-#define SBN_P1DBLCLICK	0x80
-#define SBN_P1DRAG		0x90
-#define SBN_P2CLICK		0xA0
-#define SBN_P2DBLCLICK	0xB0
-#define SBN_P2DRAG		0xC0
-#define SBN_P3CLICK		0xD0
-#define SBN_P3DBLCLICK	0xE0
-#define SBN_P3DRAG		0xF0
-
-#endif
-
-#ifndef NOWTCAPABILITIES
-
-/* hardware capabilities */
-#define HWC_INTEGRATED		0x0001
-#define HWC_TOUCH			0x0002
-#define HWC_HARDPROX		0x0004
-#define HWC_PHYSID_CURSORS	0x0008 /* 1.1 */
-#endif
-
-#ifndef NOWTIFC
-
-#ifndef NOWTCURSORS 
-
-/* cursor capabilities */
-#define CRC_MULTIMODE	0x0001 /* 1.1 */
-#define CRC_AGGREGATE	0x0002 /* 1.1 */
-#define CRC_INVERT		0x0004 /* 1.1 */
-
-#endif 
-
-/* info categories */
-#define WTI_INTERFACE		1
-	#define IFC_WINTABID		1
-	#define IFC_SPECVERSION		2
-	#define IFC_IMPLVERSION		3
-	#define IFC_NDEVICES		4
-	#define IFC_NCURSORS		5
-	#define IFC_NCONTEXTS		6
-	#define IFC_CTXOPTIONS		7
-	#define IFC_CTXSAVESIZE		8
-	#define IFC_NEXTENSIONS		9
-	#define IFC_NMANAGERS		10
-	#define IFC_MAX				10
-
-
-#endif
-
-#ifndef NOWTSTATUS
-
-#define WTI_STATUS			2
-	#define STA_CONTEXTS		1
-	#define STA_SYSCTXS			2
-	#define STA_PKTRATE			3
-	#define STA_PKTDATA			4
-	#define STA_MANAGERS		5
-	#define STA_SYSTEM			6
-	#define STA_BUTTONUSE		7
-	#define STA_SYSBTNUSE		8
-	#define STA_MAX				8
-
-#endif
-
-#ifndef NOWTDEFCONTEXT
-
-#define WTI_DEFCONTEXT	3
-#define WTI_DEFSYSCTX	4
-#define WTI_DDCTXS		400 /* 1.1 */
-#define WTI_DSCTXS		500 /* 1.1 */
-	#define CTX_NAME		1
-	#define CTX_OPTIONS		2
-	#define CTX_STATUS		3
-	#define CTX_LOCKS		4
-	#define CTX_MSGBASE		5
-	#define CTX_DEVICE		6
-	#define CTX_PKTRATE		7
-	#define CTX_PKTDATA		8
-	#define CTX_PKTMODE		9
-	#define CTX_MOVEMASK	10
-	#define CTX_BTNDNMASK	11
-	#define CTX_BTNUPMASK	12
-	#define CTX_INORGX		13
-	#define CTX_INORGY		14
-	#define CTX_INORGZ		15
-	#define CTX_INEXTX		16
-	#define CTX_INEXTY		17
-	#define CTX_INEXTZ		18
-	#define CTX_OUTORGX		19
-	#define CTX_OUTORGY		20
-	#define CTX_OUTORGZ		21
-	#define CTX_OUTEXTX		22
-	#define CTX_OUTEXTY		23
-	#define CTX_OUTEXTZ		24
-	#define CTX_SENSX		25
-	#define CTX_SENSY		26
-	#define CTX_SENSZ		27
-	#define CTX_SYSMODE		28
-	#define CTX_SYSORGX		29
-	#define CTX_SYSORGY		30
-	#define CTX_SYSEXTX		31
-	#define CTX_SYSEXTY		32
-	#define CTX_SYSSENSX	33
-	#define CTX_SYSSENSY	34
-	#define CTX_MAX			34
-
-#endif
-
-#ifndef NOWTDEVICES
-
-#define WTI_DEVICES		100
-	#define DVC_NAME			1
-	#define DVC_HARDWARE		2
-	#define DVC_NCSRTYPES		3
-	#define DVC_FIRSTCSR		4
-	#define DVC_PKTRATE			5
-	#define DVC_PKTDATA			6
-	#define DVC_PKTMODE			7
-	#define DVC_CSRDATA			8
-	#define DVC_XMARGIN			9
-	#define DVC_YMARGIN			10
-	#define DVC_ZMARGIN			11
-	#define DVC_X				12
-	#define DVC_Y				13
-	#define DVC_Z				14
-	#define DVC_NPRESSURE		15
-	#define DVC_TPRESSURE		16
-	#define DVC_ORIENTATION		17
-	#define DVC_ROTATION		18 /* 1.1 */
-	#define DVC_PNPID			19 /* 1.1 */
-	#define DVC_MAX				19
-
-#endif
-
-#ifndef NOWTCURSORS
-
-#define WTI_CURSORS		200
-	#define CSR_NAME			1
-	#define CSR_ACTIVE			2
-	#define CSR_PKTDATA			3
-	#define CSR_BUTTONS			4
-	#define CSR_BUTTONBITS		5
-	#define CSR_BTNNAMES		6
-	#define CSR_BUTTONMAP		7
-	#define CSR_SYSBTNMAP		8
-	#define CSR_NPBUTTON		9
-	#define CSR_NPBTNMARKS		10
-	#define CSR_NPRESPONSE		11
-	#define CSR_TPBUTTON		12
-	#define CSR_TPBTNMARKS		13
-	#define CSR_TPRESPONSE		14
-	#define CSR_PHYSID			15 /* 1.1 */
-	#define CSR_MODE			16 /* 1.1 */
-	#define CSR_MINPKTDATA		17 /* 1.1 */
-	#define CSR_MINBUTTONS		18 /* 1.1 */
-	#define CSR_CAPABILITIES	19 /* 1.1 */
-	#define CSR_MAX				19
-
-#endif
-
-#ifndef NOWTEXTENSIONS
-
-#define WTI_EXTENSIONS	300
-	#define EXT_NAME		1
-	#define EXT_TAG			2
-	#define EXT_MASK		3
-	#define EXT_SIZE		4
-	#define EXT_AXES		5
-	#define EXT_DEFAULT		6
-	#define EXT_DEFCONTEXT	7
-	#define EXT_DEFSYSCTX	8
-	#define EXT_CURSORS		9 
-	#define EXT_MAX			109 /* Allow 100 cursors */
-
-#endif
-
-#endif
-
-/* -------------------------------------------------------------------------- */
-/* CONTEXT DATA DEFS */
-
-#define LCNAMELEN	40
-#define LC_NAMELEN	40
-#ifdef WIN32
-typedef struct tagLOGCONTEXTA {
-	char	lcName[LCNAMELEN];
-	UINT	lcOptions;
-	UINT	lcStatus;
-	UINT	lcLocks;
-	UINT	lcMsgBase;
-	UINT	lcDevice;
-	UINT	lcPktRate;
-	WTPKT	lcPktData;
-	WTPKT	lcPktMode;
-	WTPKT	lcMoveMask;
-	DWORD	lcBtnDnMask;
-	DWORD	lcBtnUpMask;
-	LONG	lcInOrgX;
-	LONG	lcInOrgY;
-	LONG	lcInOrgZ;
-	LONG	lcInExtX;
-	LONG	lcInExtY;
-	LONG	lcInExtZ;
-	LONG	lcOutOrgX;
-	LONG	lcOutOrgY;
-	LONG	lcOutOrgZ;
-	LONG	lcOutExtX;
-	LONG	lcOutExtY;
-	LONG	lcOutExtZ;
-	FIX32	lcSensX;
-	FIX32	lcSensY;
-	FIX32	lcSensZ;
-	BOOL	lcSysMode;
-	int		lcSysOrgX;
-	int		lcSysOrgY;
-	int		lcSysExtX;
-	int		lcSysExtY;
-	FIX32	lcSysSensX;
-	FIX32	lcSysSensY;
-} LOGCONTEXTA, *PLOGCONTEXTA, NEAR *NPLOGCONTEXTA, FAR *LPLOGCONTEXTA;
-typedef struct tagLOGCONTEXTW {
-	WCHAR	lcName[LCNAMELEN];
-	UINT	lcOptions;
-	UINT	lcStatus;
-	UINT	lcLocks;
-	UINT	lcMsgBase;
-	UINT	lcDevice;
-	UINT	lcPktRate;
-	WTPKT	lcPktData;
-	WTPKT	lcPktMode;
-	WTPKT	lcMoveMask;
-	DWORD	lcBtnDnMask;
-	DWORD	lcBtnUpMask;
-	LONG	lcInOrgX;
-	LONG	lcInOrgY;
-	LONG	lcInOrgZ;
-	LONG	lcInExtX;
-	LONG	lcInExtY;
-	LONG	lcInExtZ;
-	LONG	lcOutOrgX;
-	LONG	lcOutOrgY;
-	LONG	lcOutOrgZ;
-	LONG	lcOutExtX;
-	LONG	lcOutExtY;
-	LONG	lcOutExtZ;
-	FIX32	lcSensX;
-	FIX32	lcSensY;
-	FIX32	lcSensZ;
-	BOOL	lcSysMode;
-	int		lcSysOrgX;
-	int		lcSysOrgY;
-	int		lcSysExtX;
-	int		lcSysExtY;
-	FIX32	lcSysSensX;
-	FIX32	lcSysSensY;
-} LOGCONTEXTW, *PLOGCONTEXTW, NEAR *NPLOGCONTEXTW, FAR *LPLOGCONTEXTW;
-#ifdef UNICODE
-typedef LOGCONTEXTW LOGCONTEXT;
-typedef PLOGCONTEXTW PLOGCONTEXT;
-typedef NPLOGCONTEXTW NPLOGCONTEXT;
-typedef LPLOGCONTEXTW LPLOGCONTEXT;
-#else
-typedef LOGCONTEXTA LOGCONTEXT;
-typedef PLOGCONTEXTA PLOGCONTEXT;
-typedef NPLOGCONTEXTA NPLOGCONTEXT;
-typedef LPLOGCONTEXTA LPLOGCONTEXT;
-#endif /* UNICODE */
-#else /* WIN32 */
-typedef struct tagLOGCONTEXT {
-	char	lcName[LCNAMELEN];
-	UINT	lcOptions;
-	UINT	lcStatus;
-	UINT	lcLocks;
-	UINT	lcMsgBase;
-	UINT	lcDevice;
-	UINT	lcPktRate;
-	WTPKT	lcPktData;
-	WTPKT	lcPktMode;
-	WTPKT	lcMoveMask;
-	DWORD	lcBtnDnMask;
-	DWORD	lcBtnUpMask;
-	LONG	lcInOrgX;
-	LONG	lcInOrgY;
-	LONG	lcInOrgZ;
-	LONG	lcInExtX;
-	LONG	lcInExtY;
-	LONG	lcInExtZ;
-	LONG	lcOutOrgX;
-	LONG	lcOutOrgY;
-	LONG	lcOutOrgZ;
-	LONG	lcOutExtX;
-	LONG	lcOutExtY;
-	LONG	lcOutExtZ;
-	FIX32	lcSensX;
-	FIX32	lcSensY;
-	FIX32	lcSensZ;
-	BOOL	lcSysMode;
-	int		lcSysOrgX;
-	int		lcSysOrgY;
-	int		lcSysExtX;
-	int		lcSysExtY;
-	FIX32	lcSysSensX;
-	FIX32	lcSysSensY;
-} LOGCONTEXT, *PLOGCONTEXT, NEAR *NPLOGCONTEXT, FAR *LPLOGCONTEXT;
-#endif /* WIN32 */
-
-	/* context option values */
-	#define CXO_SYSTEM		0x0001
-	#define CXO_PEN			0x0002
-	#define CXO_MESSAGES	0x0004
-	#define CXO_MARGIN		0x8000
-	#define CXO_MGNINSIDE	0x4000
-	#define CXO_CSRMESSAGES	0x0008 /* 1.1 */
-
-	/* context status values */
-	#define CXS_DISABLED	0x0001
-	#define CXS_OBSCURED	0x0002
-	#define CXS_ONTOP		0x0004
-
-	/* context lock values */
-	#define CXL_INSIZE		0x0001
-	#define CXL_INASPECT	0x0002
-	#define CXL_SENSITIVITY	0x0004
-	#define CXL_MARGIN		0x0008
-	#define CXL_SYSOUT		0x0010
-
-/* -------------------------------------------------------------------------- */
-/* EVENT DATA DEFS */
-
-/* For packet structure definition, see pktdef.h */
-
-/* packet status values */
-#define TPS_PROXIMITY		0x0001
-#define TPS_QUEUE_ERR		0x0002
-#define TPS_MARGIN			0x0004
-#define TPS_GRAB			0x0008
-#define TPS_INVERT			0x0010 /* 1.1 */
-
-typedef struct tagORIENTATION {
-	int orAzimuth;
-	int orAltitude;
-	int orTwist;
-} ORIENTATION, *PORIENTATION, NEAR *NPORIENTATION, FAR *LPORIENTATION;
-
-typedef struct tagROTATION { /* 1.1 */
-	int	roPitch;
-	int roRoll;
-	int roYaw;
-} ROTATION, *PROTATION, NEAR *NPROTATION, FAR *LPROTATION;
-// grandfather in obsolete member names.
-#define rotPitch	roPitch
-#define rotRoll		roRoll
-#define rotYaw		roYaw
-
-/* relative buttons */
-#define TBN_NONE	0
-#define TBN_UP		1
-#define TBN_DOWN	2
-
-/* -------------------------------------------------------------------------- */
-/* DEVICE CONFIG CONSTANTS */
-
-#ifndef NOWTDEVCFG
-
-#define WTDC_NONE		0
-#define WTDC_CANCEL		1
-#define WTDC_OK			2
-#define WTDC_RESTART	3
-
-#endif
-
-/* -------------------------------------------------------------------------- */
-/* HOOK CONSTANTS */
-
-#ifndef NOWTHOOKS
-
-#define WTH_PLAYBACK		1
-#define WTH_RECORD			2
-
-#define WTHC_GETLPLPFN	    (-3)
-#define WTHC_LPLPFNNEXT	    (-2)
-#define WTHC_LPFNNEXT	    (-1)
-#define WTHC_ACTION		    0
-#define WTHC_GETNEXT   	    1
-#define WTHC_SKIP 	   		2
-
-#endif
-
-/* -------------------------------------------------------------------------- */
-/* PREFERENCE FUNCTION CONSTANTS */
-
-#ifndef NOWTPREF
-
-#define WTP_LPDEFAULT	((LPVOID)-1L)
-#define WTP_DWDEFAULT	((DWORD)-1L)
-
-#endif
-
-/* -------------------------------------------------------------------------- */
-/* EXTENSION TAGS AND CONSTANTS */
-
-#ifndef NOWTEXTENSIONS
-
-/* constants for use with pktdef.h */
-#define PKEXT_ABSOLUTE	1
-#define PKEXT_RELATIVE	2
-
-/* Extension tags. */
-#define WTX_OBT			0	/* Out of bounds tracking */
-#define WTX_FKEYS		1	/* Function keys */
-#define WTX_TILT		2	/* Raw Cartesian tilt; 1.1 */
-#define WTX_CSRMASK		3	/* select input by cursor type; 1.1 */
-#define WTX_XBTNMASK	4	/* Extended button mask; 1.1 */
-
-typedef struct tagXBTNMASK {
-	BYTE xBtnDnMask[32];
-	BYTE xBtnUpMask[32];
-} XBTNMASK;
-
-typedef struct tagTILT { /* 1.1 */
-	int tiltX;
-	int tiltY;
-} TILT;
-
-#endif
-
-/* -------------------------------------------------------------------------- */
-/* -------------------------------------------------------------------------- */
-/* Functions */
-
-	#ifndef API
-		#ifndef WINAPI
-			#define API			FAR PASCAL
-		#else
-			#define API			WINAPI
-		#endif
-	#endif
-
-#ifndef NOWTCALLBACKS
-
-	#ifndef CALLBACK
-	#define CALLBACK	FAR PASCAL
-	#endif
-
-	#ifndef NOWTMANAGERFXNS
-	/* callback function types */
-	typedef BOOL (WINAPI * WTENUMPROC)(HCTX, LPARAM); /* changed CALLBACK->WINAPI, 1.1 */
-	typedef BOOL (WINAPI * WTCONFIGPROC)(HCTX, HWND);
-	typedef LRESULT (WINAPI * WTHOOKPROC)(int, WPARAM, LPARAM);
-	typedef WTHOOKPROC FAR *LPWTHOOKPROC;
-	#endif
-
-#endif
-
-
-#ifndef NOWTFUNCTIONS
-
-	#ifndef NOWTBASICFXNS
-	/* BASIC FUNCTIONS */
-#ifdef WIN32
-	UINT API WTInfoA(UINT, UINT, LPVOID);
-	#define ORD_WTInfoA						20
-	UINT API WTInfoW(UINT, UINT, LPVOID);
-	#define ORD_WTInfoW					  1020
-	#ifdef UNICODE
-	#define WTInfo  WTInfoW
-	#define ORD_WTInfo  ORD_WTInfoW
-	#else
-	#define WTInfo  WTInfoA
-	#define ORD_WTInfo  ORD_WTInfoA
-	#endif /* !UNICODE */
-#else
-	UINT API WTInfo(UINT, UINT, LPVOID);
-	#define ORD_WTInfo						20
-#endif
-#ifdef WIN32
-	HCTX API WTOpenA(HWND, LPLOGCONTEXTA, BOOL);
-	#define ORD_WTOpenA						21
-	HCTX API WTOpenW(HWND, LPLOGCONTEXTW, BOOL);
-	#define ORD_WTOpenW					  1021
-	#ifdef UNICODE
-	#define WTOpen  WTOpenW
-	#define ORD_WTOpen  ORD_WTOpenW
-	#else
-	#define WTOpen  WTOpenA
-	#define ORD_WTOpen  ORD_WTOpenA
-	#endif /* !UNICODE */
-#else
-	HCTX API WTOpen(HWND, LPLOGCONTEXT, BOOL);
-	#define ORD_WTOpen						21
-#endif
-	BOOL API WTClose(HCTX);
-	#define ORD_WTClose						22
-	int API WTPacketsGet(HCTX, int, LPVOID);
-	#define ORD_WTPacketsGet				23
-	BOOL API WTPacket(HCTX, UINT, LPVOID);
-	#define ORD_WTPacket					24
-	#endif
-
-	#ifndef NOWTVISIBILITYFXNS
-	/* VISIBILITY FUNCTIONS */
-	BOOL API WTEnable(HCTX, BOOL);
-	#define ORD_WTEnable					40
-	BOOL API WTOverlap(HCTX, BOOL);
-	#define ORD_WTOverlap					41
-	#endif
-
-	#ifndef NOWTCTXEDITFXNS
-	/* CONTEXT EDITING FUNCTIONS */
-	BOOL API WTConfig(HCTX, HWND);
-	#define ORD_WTConfig					60
-#ifdef WIN32
-	BOOL API WTGetA(HCTX, LPLOGCONTEXTA);
-	#define ORD_WTGetA						61
-	BOOL API WTGetW(HCTX, LPLOGCONTEXTW);
-	#define ORD_WTGetW					  1061
-	#ifdef UNICODE
-	#define WTGet  WTGetW
-	#define ORD_WTGet  ORD_WTGetW
-	#else
-	#define WTGet  WTGetA
-	#define ORD_WTGet  ORD_WTGetA
-	#endif /* !UNICODE */
-#else
-	BOOL API WTGet(HCTX, LPLOGCONTEXT);
-	#define ORD_WTGet						61
-#endif
-#ifdef WIN32
-	BOOL API WTSetA(HCTX, LPLOGCONTEXTA);
-	#define ORD_WTSetA						62
-	BOOL API WTSetW(HCTX, LPLOGCONTEXTW);
-	#define ORD_WTSetW					  1062
-	#ifdef UNICODE
-	#define WTSet  WTSetW
-	#define ORD_WTSet  ORD_WTSetW
-	#else
-	#define WTSet  WTSetA
-	#define ORD_WTSet  ORD_WTSetA
-	#endif /* !UNICODE */
-#else
-	BOOL API WTSet(HCTX, LPLOGCONTEXT);
-	#define ORD_WTSet						62
-#endif
-	BOOL API WTExtGet(HCTX, UINT, LPVOID);
-	#define ORD_WTExtGet					63
-	BOOL API WTExtSet(HCTX, UINT, LPVOID);
-	#define ORD_WTExtSet					64
-	BOOL API WTSave(HCTX, LPVOID);
-	#define ORD_WTSave						65
-	HCTX API WTRestore(HWND, LPVOID, BOOL);
-	#define ORD_WTRestore					66
-	#endif
-
-	#ifndef NOWTQUEUEFXNS
-	/* ADVANCED PACKET AND QUEUE FUNCTIONS */
-	int API WTPacketsPeek(HCTX, int, LPVOID);
-	#define ORD_WTPacketsPeek				80
-	int API WTDataGet(HCTX, UINT, UINT, int, LPVOID, LPINT);
-	#define ORD_WTDataGet					81
-	int API WTDataPeek(HCTX, UINT, UINT, int, LPVOID, LPINT);
-	#define ORD_WTDataPeek					82
-#ifndef WIN32
-/* OBSOLETE IN WIN32! */
-	DWORD API WTQueuePackets(HCTX);
-	#define ORD_WTQueuePackets				83
-#endif
-	int API WTQueueSizeGet(HCTX);
-	#define ORD_WTQueueSizeGet				84
-	BOOL API WTQueueSizeSet(HCTX, int);
-	#define ORD_WTQueueSizeSet				85
-	#endif
-
-	#ifndef NOWTHMGRFXNS
-	/* MANAGER HANDLE FUNCTIONS */
-	HMGR API WTMgrOpen(HWND, UINT);
-	#define ORD_WTMgrOpen					100
-	BOOL API WTMgrClose(HMGR);
-	#define ORD_WTMgrClose					101
-	#endif
-
-	#ifndef NOWTMGRCTXFXNS
-	/* MANAGER CONTEXT FUNCTIONS */
-	BOOL API WTMgrContextEnum(HMGR, WTENUMPROC, LPARAM);
-	#define ORD_WTMgrContextEnum			120
-	HWND API WTMgrContextOwner(HMGR, HCTX);
-	#define ORD_WTMgrContextOwner			121
-	HCTX API WTMgrDefContext(HMGR, BOOL);
-	#define ORD_WTMgrDefContext				122
-	HCTX API WTMgrDefContextEx(HMGR, UINT, BOOL); /* 1.1 */
-	#define ORD_WTMgrDefContextEx			206
-	#endif
-	
-	#ifndef NOWTMGRCONFIGFXNS
-	/* MANAGER CONFIG BOX  FUNCTIONS */
-	UINT API WTMgrDeviceConfig(HMGR, UINT, HWND);
-	#define ORD_WTMgrDeviceConfig			140
-#ifndef WIN32
-/* OBSOLETE IN WIN32! */
-	BOOL API WTMgrConfigReplace(HMGR, BOOL, WTCONFIGPROC);
-	#define ORD_WTMgrConfigReplace			141
-#endif
-	#endif
-
-	#ifndef NOWTMGRHOOKFXNS
-	/* MANAGER PACKET HOOK FUNCTIONS */
-#ifndef WIN32
-/* OBSOLETE IN WIN32! */
-	WTHOOKPROC API WTMgrPacketHook(HMGR, BOOL, int, WTHOOKPROC);
-	#define ORD_WTMgrPacketHook				160
-	LRESULT API WTMgrPacketHookDefProc(int, WPARAM, LPARAM, LPWTHOOKPROC);
-	#define ORD_WTMgrPacketHookDefProc		161
-#endif
-	#endif
-
-	#ifndef NOWTMGRPREFFXNS
-	/* MANAGER PREFERENCE DATA FUNCTIONS */
-	BOOL API WTMgrExt(HMGR, UINT, LPVOID);
-	#define ORD_WTMgrExt					180
-	BOOL API WTMgrCsrEnable(HMGR, UINT, BOOL);
-	#define ORD_WTMgrCsrEnable				181
-	BOOL API WTMgrCsrButtonMap(HMGR, UINT, LPBYTE, LPBYTE);
-	#define ORD_WTMgrCsrButtonMap			182
-	BOOL API WTMgrCsrPressureBtnMarks(HMGR, UINT, DWORD, DWORD);
-	#define ORD_WTMgrCsrPressureBtnMarks	183
-	BOOL API WTMgrCsrPressureResponse(HMGR, UINT, UINT FAR *, UINT FAR *);
-	#define ORD_WTMgrCsrPressureResponse	184
-	BOOL API WTMgrCsrExt(HMGR, UINT, UINT, LPVOID);
-	#define ORD_WTMgrCsrExt					185
-	#endif
-
-/* Win32 replacements for non-portable functions. */
-	#ifndef NOWTQUEUEFXNS
-	/* ADVANCED PACKET AND QUEUE FUNCTIONS */
-	BOOL API WTQueuePacketsEx(HCTX, UINT FAR *, UINT FAR *);
-	#define ORD_WTQueuePacketsEx			200
-	#endif
-
-	#ifndef NOWTMGRCONFIGFXNS
-	/* MANAGER CONFIG BOX  FUNCTIONS */
-#ifdef WIN32
-	BOOL API WTMgrConfigReplaceExA(HMGR, BOOL, LPSTR, LPSTR);
-	#define ORD_WTMgrConfigReplaceExA		202
-	BOOL API WTMgrConfigReplaceExW(HMGR, BOOL, LPWSTR, LPSTR);
-	#define ORD_WTMgrConfigReplaceExW		1202
-	#ifdef UNICODE
-	#define WTMgrConfigReplaceEx  WTMgrConfigReplaceExW
-	#define ORD_WTMgrConfigReplaceEx  ORD_WTMgrConfigReplaceExW
-	#else
-	#define WTMgrConfigReplaceEx  WTMgrConfigReplaceExA
-	#define ORD_WTMgrConfigReplaceEx  ORD_WTMgrConfigReplaceExA
-	#endif /* !UNICODE */
-#else
-	BOOL API WTMgrConfigReplaceEx(HMGR, BOOL, LPSTR, LPSTR);
-	#define ORD_WTMgrConfigReplaceEx		202
-#endif
-	#endif
-
-	#ifndef NOWTMGRHOOKFXNS
-	/* MANAGER PACKET HOOK FUNCTIONS */
-#ifdef WIN32
-	HWTHOOK API WTMgrPacketHookExA(HMGR, int, LPSTR, LPSTR);
-	#define ORD_WTMgrPacketHookExA			203
-	HWTHOOK API WTMgrPacketHookExW(HMGR, int, LPWSTR, LPSTR);
-	#define ORD_WTMgrPacketHookExW			1203
-	#ifdef UNICODE
-	#define WTMgrPacketHookEx  WTMgrPacketHookExW
-	#define ORD_WTMgrPacketHookEx  ORD_WTMgrPacketHookExW
-	#else
-	#define WTMgrPacketHookEx  WTMgrPacketHookExA
-	#define ORD_WTMgrPacketHookEx  ORD_WTMgrPacketHookExA
-	#endif /* !UNICODE */
-#else
-	HWTHOOK API WTMgrPacketHookEx(HMGR, int, LPSTR, LPSTR);
-	#define ORD_WTMgrPacketHookEx			203
-#endif
-	BOOL API WTMgrPacketUnhook(HWTHOOK);
-	#define ORD_WTMgrPacketUnhook			204
-	LRESULT API WTMgrPacketHookNext(HWTHOOK, int, WPARAM, LPARAM);
-	#define ORD_WTMgrPacketHookNext			205
-	#endif
-
-	#ifndef NOWTMGRPREFFXNS
-	/* MANAGER PREFERENCE DATA FUNCTIONS */
-	BOOL API WTMgrCsrPressureBtnMarksEx(HMGR, UINT, UINT FAR *, UINT FAR *);
-	#define ORD_WTMgrCsrPressureBtnMarksEx	201
-	#endif
-
-
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif	/* __cplusplus */
-
-#endif /* #define _INC_WINTAB */
-
diff --git a/gdk/win32/xcursors.h b/gdk/win32/xcursors.h
deleted file mode 100644
index 4243a39..0000000
--- a/gdk/win32/xcursors.h
+++ /dev/null
@@ -1,363 +0,0 @@
-static const struct { const gchar *name; const gchar *builtin; gint type; guchar width; guchar height; guchar hotx; guchar hoty; gchar *data; } cursors[] = {
-  { "X_cursor", NULL, 0, 16, 16, 7, 7, 
-    "\125\000\000\125\152\100\001\251\152\220\006\251\152\244\032\251"
-    "\032\251\152\244\006\252\252\220\001\252\252\100\000\152\251\000"
-    "\000\152\251\000\001\252\252\100\006\252\252\220\032\251\152\244"
-    "\152\244\032\251\152\220\006\251\152\100\001\251\125\000\000\125" }, 
-  { "arrow", IDC_ARROW, 2, 16, 16, 14, 1, 
-    "\000\000\000\025\000\000\001\151\000\000\026\251\000\001\152\244"
-    "\000\026\252\244\001\152\252\220\006\252\252\220\005\126\252\100"
-    "\000\032\252\100\000\152\151\000\001\251\151\000\006\244\144\000"
-    "\032\220\144\000\152\100\020\000\031\000\000\000\004\000\000\000" }, 
-  { "based_arrow_down", NULL, 4, 10, 12, 4, 10, 
-    "\125\125\126\252\251\125\125\126\252\251\125\245\120\032\100\001"
-    "\244\001\132\124\031\246\101\152\224\005\245\000\025\100" }, 
-  { "based_arrow_up", NULL, 6, 10, 12, 4, 10, 
-    "\000\120\000\032\100\026\251\101\232\144\025\245\100\032\100\001"
-    "\244\005\132\125\152\252\225\125\125\152\252\225\125\125" }, 
-  { "boat", NULL, 8, 16, 9, 14, 4, 
-    "\000\026\000\000\000\152\240\000\201\225\150\000\252\252\252\252"
-    "\125\125\126\225\125\125\131\125\125\125\145\100\252\252\244\000"
-    "\125\125\120\000" }, 
-  { "bogosity", NULL, 10, 15, 16, 7, 7, 
-    "\125\105\105\125\251\031\032\225\144\144\145\101\221\221\220\126"
-    "\126\126\125\252\252\252\226\145\145\146\131\221\221\231\146\106"
-    "\106\145\231\131\131\226\252\252\252\125\225\225\225\006\106\106"
-    "\101\131\031\031\126\244\144\152\125\121\121\125" }, 
-  { "bottom_left_corner", IDC_SIZENESW, 12, 16, 16, 1, 14, 
-    "\125\000\000\000\151\000\000\000\151\025\000\120\151\031\001\220"
-    "\151\031\006\100\151\031\031\000\151\031\144\000\151\031\220\000"
-    "\151\032\125\120\151\032\252\220\151\025\125\120\151\000\000\000"
-    "\151\125\125\125\152\252\252\251\152\252\252\251\125\125\125\125" }, 
-  { "bottom_right_corner", IDC_SIZENWSE, 14, 16, 16, 14, 14, 
-    "\000\000\000\125\000\000\000\151\005\000\124\151\006\100\144\151"
-    "\001\220\144\151\000\144\144\151\000\031\144\151\000\006\144\151"
-    "\005\125\244\151\006\252\244\151\005\125\124\151\000\000\000\151"
-    "\125\125\125\151\152\252\252\251\152\252\252\251\125\125\125\125" }, 
-  { "bottom_side", IDC_SIZENS, 16, 15, 16, 7, 14, 
-    "\000\005\100\000\000\031\000\000\000\144\000\000\001\220\000\000"
-    "\006\100\000\000\031\000\000\120\144\024\001\221\221\220\001\226"
-    "\131\000\001\231\220\000\001\251\000\000\001\220\000\125\125\125"
-    "\125\252\252\252\226\252\252\252\125\125\125\125" }, 
-  { "bottom_tee", NULL, 18, 16, 12, 8, 10, 
-    "\000\005\120\000\000\006\220\000\000\006\220\000\000\006\220\000"
-    "\000\006\220\000\000\006\220\000\000\006\220\000\000\006\220\000"
-    "\125\126\225\125\152\252\252\251\152\252\252\251\125\125\125\125" }, 
-  { "box_spiral", NULL, 20, 16, 16, 8, 8, 
-    "\252\252\252\251\225\125\125\125\232\252\252\251\231\125\125\131"
-    "\231\252\252\231\231\225\125\231\231\232\251\231\231\231\131\231"
-    "\231\231\231\231\231\232\231\231\231\225\131\231\231\252\251\231"
-    "\231\125\125\231\232\252\252\231\225\125\125\131\252\252\252\251" }, 
-  { "center_ptr", IDC_UPARROW, 22, 12, 16, 5, 1, 
-    "\000\125\000\000\151\000\001\151\100\001\252\100\005\252\120\006"
-    "\252\220\026\252\224\032\252\244\132\252\245\151\151\151\145\151"
-    "\131\124\151\025\000\151\000\000\151\000\000\151\000\000\125\000" }, 
-  { "circle", NULL, 24, 16, 16, 8, 8, 
-    "\000\025\124\000\001\132\245\100\005\252\252\120\026\252\252\224"
-    "\032\245\132\244\132\220\006\245\152\100\001\251\152\100\001\251"
-    "\152\100\001\251\152\100\001\251\132\220\006\245\032\245\132\244"
-    "\026\252\252\224\005\252\252\120\001\132\245\100\000\025\124\000" }, 
-  { "clock", IDC_APPSTARTING, 26, 15, 16, 6, 3, 
-    "\032\252\252\101\241\252\012\112\030\132\112\141\206\222\111\206"
-    "\251\131\046\006\124\220\232\006\251\012\132\252\252\244\142\032"
-    "\110\221\210\151\042\106\041\244\211\030\232\246\044\242\032\110"
-    "\246\250\024\052\232\252\252\252\152\252\252\251" }, 
-  { "coffee_mug", NULL, 28, 16, 16, 7, 9, 
-    "\002\252\252\000\011\125\125\200\051\125\125\151\046\125\126\231"
-    "\145\252\251\131\245\125\125\131\245\125\125\131\145\125\125\131"
-    "\045\125\125\131\046\226\126\231\151\231\231\231\251\232\231\231"
-    "\246\231\226\231\145\125\125\131\045\125\125\131\012\252\252\240" }, 
-  { "cross", IDC_CROSS, 30, 16, 15, 7, 7, 
-    "\000\031\220\000\000\031\220\000\000\031\220\000\000\031\220\000"
-    "\000\031\220\000\125\131\225\125\252\251\252\252\125\125\125\125"
-    "\252\251\252\252\125\131\225\125\000\031\220\000\000\031\220\000"
-    "\000\031\220\000\000\031\220\000\000\031\220\000" }, 
-  { "cross_reverse", NULL, 32, 16, 15, 7, 7, 
-    "\044\030\220\140\211\030\221\211\142\130\226\044\030\230\230\220"
-    "\006\050\242\100\125\210\211\125\252\240\052\252\000\001\000\000"
-    "\252\240\052\252\125\210\211\125\006\050\242\100\030\230\230\220"
-    "\142\130\226\044\211\030\221\211\044\030\220\140" }, 
-  { "crosshair", IDC_CROSS, 34, 16, 15, 7, 7, 
-    "\000\006\100\000\000\006\100\000\000\006\100\000\000\006\100\000"
-    "\000\006\100\000\000\006\100\000\125\126\125\125\252\251\252\252"
-    "\125\126\125\125\000\006\100\000\000\006\100\000\000\006\100\000"
-    "\000\006\100\000\000\006\100\000\000\006\100\000" }, 
-  { "diamond_cross", NULL, 36, 15, 15, 7, 7, 
-    "\000\031\220\000\001\246\220\000\031\231\220\001\222\141\220\031"
-    "\011\201\221\220\046\001\232\252\232\252\225\125\025\125\252\251"
-    "\252\251\220\046\001\221\220\230\031\001\222\141\220\001\231\231"
-    "\000\001\246\220\000\001\231\000\000" }, 
-  { "dot", NULL, 38, 12, 12, 6, 6, 
-    "\001\125\100\025\252\124\032\252\244\132\252\245\152\252\251\152"
-    "\252\251\152\252\251\152\252\251\132\252\245\032\252\244\025\252"
-    "\124\001\125\100" }, 
-  { "dotbox", NULL, 40, 14, 14, 7, 6, 
-    "\125\125\125\126\252\252\251\145\125\125\226\100\000\031\144\000"
-    "\001\226\101\124\031\144\032\101\226\101\244\031\144\025\101\226"
-    "\100\000\031\144\000\001\226\125\125\131\152\252\252\225\125\125"
-    "\125" }, 
-  { "double_arrow", IDC_SIZENS, 42, 12, 16, 6, 8, 
-    "\000\125\000\001\151\100\005\252\120\026\252\224\132\151\245\151"
-    "\151\151\125\151\125\000\151\000\000\151\000\125\151\125\151\151"
-    "\151\132\151\245\026\252\224\005\252\120\001\151\100\000\125\000" }, 
-  { "draft_large", NULL, 44, 15, 15, 14, 0, 
-    "\000\000\000\030\000\000\006\220\000\001\252\100\000\152\244\000"
-    "\032\252\200\006\252\251\001\252\252\240\005\125\252\100\000\031"
-    "\250\000\001\226\220\000\031\032\000\001\220\144\000\031\001\200"
-    "\001\220\005\000\011\000\000\000\000" }, 
-  { "draft_small", NULL, 46, 15, 15, 14, 0, 
-    "\000\000\000\030\000\000\006\220\000\001\252\000\000\152\244\000"
-    "\032\252\200\000\125\251\000\000\031\240\000\001\226\100\000\031"
-    "\030\000\001\220\100\000\031\000\000\001\220\000\000\031\000\000"
-    "\001\220\000\000\011\000\000\000\000" }, 
-  { "draped_box", NULL, 48, 14, 14, 7, 6, 
-    "\125\125\125\126\252\252\251\140\145\220\226\032\132\111\146\220"
-    "\151\226\244\121\251\145\032\105\226\121\244\131\152\105\032\226"
-    "\151\006\231\141\245\244\226\006\131\011\152\252\252\225\125\125"
-    "\125" }, 
-  { "exchange", NULL, 50, 16, 16, 7, 7, 
-    "\120\025\124\000\144\152\251\000\151\252\252\100\152\245\126\220"
-    "\145\220\001\220\145\245\000\120\152\251\000\000\125\125\000\000"
-    "\000\000\125\125\000\000\152\251\005\000\032\131\006\100\006\131"
-    "\006\225\132\251\001\252\252\151\000\152\251\031\000\025\124\005" }, 
-  { "fleur", IDC_SIZEALL, 52, 16, 16, 8, 8, 
-    "\000\005\120\000\000\006\224\000\000\032\244\000\000\152\251\000"
-    "\001\026\224\100\006\106\221\220\132\126\225\245\152\252\252\251"
-    "\152\252\252\251\132\126\225\245\006\106\221\220\001\026\224\100"
-    "\000\152\251\000\000\032\244\000\000\006\220\000\000\005\120\000" }, 
-  { "gobbler", NULL, 54, 16, 16, 14, 2, 
-    "\000\000\125\120\000\000\152\220\120\000\152\125\225\125\132\132"
-    "\226\252\232\125\252\252\252\120\252\251\132\120\252\245\132\120"
-    "\151\125\132\220\125\125\252\120\026\252\251\100\001\225\125\000"
-    "\001\220\000\000\001\220\000\000\005\225\000\000\006\251\000\000" }, 
-  { "gumby", NULL, 56, 16, 16, 2, 0, 
-    "\012\252\000\000\122\125\200\000\244\225\140\000\251\231\230\000"
-    "\244\225\130\000\244\232\231\120\252\225\132\244\132\225\132\252"
-    "\005\225\130\152\000\225\130\152\000\226\131\252\000\226\130\152"
-    "\000\226\130\025\002\126\126\000\011\126\125\200\012\250\252\200" }, 
-  { "hand1", IDC_HAND, 58, 13, 16, 12, 0, 
-    "\000\000\006\200\000\032\240\000\152\220\000\152\220\000\152\220"
-    "\000\152\251\001\152\252\221\232\252\224\252\252\251\046\252\252"
-    "\105\132\252\101\126\252\100\226\145\100\051\131\000\006\231\000"
-    "\000\151\000\000" }, 
-  { "hand2", IDC_HAND, 60, 16, 16, 0, 1, 
-    "\025\125\100\000\152\252\220\000\225\125\144\000\152\251\131\000"
-    "\026\125\126\100\001\251\126\100\006\125\126\100\001\251\131\220"
-    "\006\125\145\144\001\245\225\131\000\132\125\144\000\031\145\220"
-    "\000\006\126\100\000\001\231\000\000\000\144\000\000\000\020\000" }, 
-  { "heart", NULL, 62, 15, 14, 6, 8, 
-    "\012\250\252\200\245\152\126\212\100\144\006\244\000\100\006\220"
-    "\000\000\032\100\000\000\151\000\104\001\251\000\100\032\051\000"
-    "\001\240\051\000\032\000\051\001\240\000\051\132\000\000\051\240"
-    "\000\000\052\000\000" }, 
-  { "icon", NULL, 64, 16, 16, 8, 8, 
-    "\252\252\252\252\246\146\146\146\231\231\231\232\246\146\146\146"
-    "\231\125\125\232\246\125\125\146\231\125\125\232\246\125\125\146"
-    "\231\125\125\232\246\125\125\146\231\125\125\232\246\125\125\146"
-    "\231\231\231\232\246\146\146\146\231\231\231\232\252\252\252\252" }, 
-  { "iron_cross", NULL, 66, 16, 16, 8, 7, 
-    "\005\125\125\120\032\252\252\244\026\252\252\224\145\252\252\131"
-    "\151\152\251\151\152\132\245\251\152\226\226\251\152\252\252\251"
-    "\152\252\252\251\152\226\226\251\152\132\245\251\151\152\251\151"
-    "\145\252\252\131\026\252\252\224\032\252\252\244\005\125\125\120" }, 
-  { "left_ptr", IDC_ARROW, 68, 10, 16, 1, 1, 
-    "\120\000\006\100\000\151\000\006\244\000\152\220\006\252\100\152"
-    "\251\006\252\244\152\252\226\252\125\151\244\006\106\220\120\151"
-    "\000\001\244\000\032\100\000\120" }, 
-  { "left_side", IDC_SIZEWE, 70, 16, 15, 1, 7, 
-    "\125\000\000\000\151\000\000\000\151\000\120\000\151\001\220\000"
-    "\151\006\100\000\151\031\000\000\151\145\125\125\151\252\252\251"
-    "\151\145\125\125\151\031\000\000\151\006\100\000\151\001\220\000"
-    "\151\000\120\000\151\000\000\000\125\000\000\000" }, 
-  { "left_tee", NULL, 72, 12, 16, 1, 8, 
-    "\125\000\000\151\000\000\151\000\000\151\000\000\151\000\000\151"
-    "\000\000\151\125\125\152\252\251\152\252\251\151\125\125\151\000"
-    "\000\151\000\000\151\000\000\151\000\000\151\000\000\125\000\000" }, 
-  { "leftbutton", NULL, 74, 16, 16, 8, 8, 
-    "\025\125\125\120\152\252\252\244\152\252\252\244\145\145\145\144"
-    "\145\146\146\144\145\146\146\144\145\146\146\144\145\146\146\144"
-    "\145\145\145\144\152\252\252\244\152\252\252\244\152\252\252\244"
-    "\152\252\252\244\152\252\252\244\152\252\252\244\025\125\125\120" }, 
-  { "ll_angle", NULL, 76, 12, 12, 1, 10, 
-    "\125\000\000\151\000\000\151\000\000\151\000\000\151\000\000\151"
-    "\000\000\151\000\000\151\000\000\151\125\125\152\252\251\152\252"
-    "\251\125\125\125" }, 
-  { "lr_angle", NULL, 78, 12, 12, 10, 10, 
-    "\000\000\125\000\000\151\000\000\151\000\000\151\000\000\151\000"
-    "\000\151\000\000\151\000\000\151\125\125\151\152\252\251\152\252"
-    "\251\125\125\125" }, 
-  { "man", NULL, 80, 16, 16, 14, 5, 
-    "\001\132\224\000\006\251\252\000\005\131\225\100\220\006\100\004"
-    "\144\032\220\052\031\145\145\232\006\246\152\105\001\146\145\000"
-    "\000\045\144\000\000\031\220\000\000\145\144\000\001\226\131\000"
-    "\006\131\226\100\026\144\146\120\152\220\032\245\252\220\032\252" }, 
-  { "middlebutton", NULL, 82, 16, 16, 8, 8, 
-    "\025\125\125\120\152\252\252\244\152\252\252\244\145\145\145\144"
-    "\146\145\146\144\146\145\146\144\146\145\146\144\146\145\146\144"
-    "\145\145\145\144\152\252\252\244\152\252\252\244\152\252\252\244"
-    "\152\252\252\244\152\252\252\244\152\252\252\244\025\125\125\120" }, 
-  { "mouse", NULL, 84, 16, 16, 4, 1, 
-    "\000\125\100\000\001\124\000\000\000\152\000\000\000\045\000\000"
-    "\025\151\125\100\125\132\125\120\152\252\252\225\225\125\125\145"
-    "\232\132\132\151\232\132\132\151\232\132\132\151\225\125\125\151"
-    "\005\125\125\051\001\125\124\000\000\225\140\000\000\052\200\000" }, 
-  { "pencil", NULL, 86, 13, 16, 11, 15, 
-    "\132\220\000\031\131\000\006\126\220\000\145\230\000\012\246\100"
-    "\001\225\140\000\031\131\000\002\125\200\000\145\144\000\012\126"
-    "\000\001\225\220\000\031\131\000\001\252\100\000\032\220\000\001"
-    "\244\000\000\031" }, 
-  { "pirate", IDC_NO, 88, 16, 16, 7, 12, 
-    "\000\152\220\000\001\252\244\000\006\252\251\000\032\132\132\100"
-    "\032\132\132\100\006\252\251\000\001\252\244\000\100\152\220\001"
-    "\200\152\220\045\220\152\220\151\145\032\101\220\032\200\052\100"
-    "\000\052\200\000\026\252\250\011\252\125\132\251\225\000\005\144" }, 
-  { "plus", NULL, 90, 12, 12, 5, 6, 
-    "\000\125\000\000\151\000\000\151\000\000\151\000\125\151\125\152"
-    "\252\251\152\252\251\125\151\125\000\151\000\000\151\000\000\151"
-    "\000\000\125\000" }, 
-  { "question_arrow", IDC_HELP, 92, 11, 16, 5, 8, 
-    "\002\252\000\052\252\002\245\152\032\125\151\152\001\245\151\012"
-    "\221\124\251\101\152\224\001\251\100\006\144\000\031\220\002\246"
-    "\240\026\232\120\026\245\000\026\120\000\025\000" }, 
-  { "right_ptr", NULL, 94, 10, 16, 8, 1, 
-    "\000\000\120\000\031\000\006\220\001\251\000\152\220\032\251\006"
-    "\252\221\252\251\152\252\225\132\251\001\246\220\151\031\006\220"
-    "\121\244\000\032\100\000\120\000" }, 
-  { "right_side", IDC_SIZEWE, 96, 16, 15, 14, 7, 
-    "\000\000\000\125\000\000\000\151\000\005\000\151\000\006\100\151"
-    "\000\001\220\151\000\000\144\151\125\125\131\151\152\252\252\151"
-    "\125\125\131\151\000\000\144\151\000\001\220\151\000\006\100\151"
-    "\000\005\000\151\000\000\000\151\000\000\000\125" }, 
-  { "right_tee", NULL, 98, 12, 16, 10, 8, 
-    "\000\000\125\000\000\151\000\000\151\000\000\151\000\000\151\000"
-    "\000\151\125\125\151\152\252\251\152\252\251\125\125\151\000\000"
-    "\151\000\000\151\000\000\151\000\000\151\000\000\151\000\000\125" }, 
-  { "rightbutton", NULL, 100, 16, 16, 8, 8, 
-    "\025\125\125\120\152\252\252\244\152\252\252\244\145\145\145\144"
-    "\146\146\145\144\146\146\145\144\146\146\145\144\146\146\145\144"
-    "\145\145\145\144\152\252\252\244\152\252\252\244\152\252\252\244"
-    "\152\252\252\244\152\252\252\244\152\252\252\244\025\125\125\120" }, 
-  { "rtl_logo", NULL, 102, 16, 16, 7, 7, 
-    "\125\125\125\125\152\252\252\251\145\125\131\131\144\000\031\031"
-    "\145\125\131\031\152\252\251\031\145\145\131\031\144\144\031\031"
-    "\144\144\031\031\144\145\131\131\144\152\252\251\144\145\125\131"
-    "\144\144\000\031\145\145\125\131\152\252\252\251\125\125\125\125" }, 
-  { "sailboat", NULL, 104, 16, 16, 8, 0, 
-    "\000\000\120\000\000\000\124\000\000\001\144\000\000\005\145\000"
-    "\000\006\151\000\000\026\151\000\000\032\151\100\000\132\152\100"
-    "\000\152\152\100\001\152\152\120\001\252\152\220\005\252\152\220"
-    "\006\252\152\225\026\252\152\245\132\251\132\200\025\125\124\000" }, 
-  { "sb_down_arrow", NULL, 106, 9, 16, 4, 15, 
-    "\005\124\001\231\000\146\100\031\220\006\144\001\231\000\146\100"
-    "\031\220\006\144\001\231\005\146\125\131\225\052\252\002\252\000"
-    "\052\000\002\000" }, 
-  { "sb_h_double_arrow", NULL, 108, 17, 18, 9, 9, 
-    "\000\005\124\000\000\001\231\000\000\000\146\100\000\000\031\220"
-    "\000\000\006\144\000\000\121\231\024\000\144\146\106\100\151\031"
-    "\221\244\152\252\152\252\132\252\232\252\221\244\146\106\220\031"
-    "\031\221\220\001\106\144\120\000\001\231\000\000\000\146\100\000"
-    "\000\031\220\000\000\006\144\000\000\001\125\000\000" }, 
-  { "sb_left_arrow", NULL, 110, 16, 9, 0, 4, 
-    "\000\120\000\000\001\220\000\000\006\225\125\125\032\252\252\252"
-    "\152\225\125\125\032\252\252\252\006\225\125\125\001\220\000\000"
-    "\000\120\000\000" }, 
-  { "sb_right_arrow", NULL, 112, 16, 9, 15, 4, 
-    "\000\000\005\000\000\000\006\100\125\125\126\220\252\252\252\244"
-    "\125\125\126\251\252\252\252\244\125\125\126\220\000\000\006\100"
-    "\000\000\005\000" }, 
-  { "sb_up_arrow", NULL, 114, 9, 16, 4, 0, 
-    "\000\200\000\250\000\252\200\252\250\126\145\125\231\120\146\100"
-    "\031\220\006\144\001\231\000\146\100\031\220\006\144\001\231\000"
-    "\146\100\025\120" },
-  { "sb_v_double_arrow", NULL, 116, 18, 17, 9, 9, 
-    "\000\000\120\000\000\000\032\100\000\000\006\251\000\000\001\252"
-    "\244\000\000\025\245\100\000\000\012\000\000\125\125\245\125\126"
-    "\252\252\252\251\125\125\125\125\126\252\252\252\251\125\125\245"
-    "\125\120\000\012\000\000\000\025\245\100\000\001\252\244\000\000"
-    "\006\251\000\000\000\032\100\000\000\000\120\000\000" }, 
-  { "shuttle", NULL, 118, 16, 16, 11, 0, 
-    "\000\000\006\100\000\000\032\220\000\000\152\244\000\000\251\252"
-    "\000\030\251\252\000\144\251\252\001\224\251\252\001\224\251\252"
-    "\001\224\251\252\001\224\251\252\006\224\251\252\032\224\251\252"
-    "\152\250\251\252\025\244\145\144\000\120\032\244\000\000\006\220" }, 
-  { "sizing", IDC_SIZENWSE, 120, 16, 16, 8, 8, 
-    "\125\125\120\000\152\252\220\000\145\125\120\000\144\000\000\000"
-    "\144\125\125\000\144\152\251\000\144\145\131\025\144\144\031\031"
-    "\144\144\031\031\124\145\131\031\000\152\251\031\000\125\126\131"
-    "\000\000\001\231\000\005\125\151\000\006\252\251\000\005\125\125" }, 
-  { "spider", NULL, 122, 16, 16, 6, 7, 
-    "\030\000\002\100\006\000\011\000\002\000\010\000\001\200\044\000"
-    "\100\225\140\001\220\152\220\152\050\152\222\220\006\252\251\000"
-    "\006\252\250\000\050\152\226\200\220\152\220\152\100\225\140\001"
-    "\001\200\040\000\002\100\030\000\006\000\011\000\030\000\002\100" }, 
-  { "spraycan", NULL, 124, 12, 16, 10, 2, 
-    "\000\000\012\001\100\205\006\230\112\012\244\205\032\144\112\152"
-    "\251\000\145\131\000\152\131\000\146\131\000\152\131\000\146\131"
-    "\000\152\131\000\152\131\000\145\131\000\145\131\000\152\251\000" }, 
-  { "star", NULL, 126, 16, 16, 7, 7, 
-    "\000\002\000\000\000\011\200\000\000\011\200\000\000\030\220\000"
-    "\000\044\140\000\000\140\044\000\001\140\045\100\132\202\012\224"
-    "\240\000\000\051\132\200\012\224\005\202\011\100\006\011\202\100"
-    "\030\044\140\220\030\220\030\220\032\100\006\220\031\000\001\220" }, 
-  { "target", NULL, 128, 16, 15, 7, 7, 
-    "\000\025\120\000\000\132\224\000\001\252\251\000\006\240\052\100"
-    "\032\000\002\220\150\001\000\244\240\006\100\051\240\030\220\051"
-    "\240\006\100\051\150\001\000\244\032\000\002\220\006\240\052\100"
-    "\001\252\251\000\000\132\224\000\000\025\120\000" }, 
-  { "tcross", IDC_CROSS, 130, 15, 15, 7, 7, 
-    "\000\005\100\000\000\031\000\000\000\144\000\000\001\220\000\000"
-    "\006\100\000\000\031\000\005\125\145\125\132\252\252\251\125\126"
-    "\125\124\000\031\000\000\000\144\000\000\001\220\000\000\006\100"
-    "\000\000\031\000\000\000\124\000\000" }, 
-  { "top_left_arrow", NULL, 132, 16, 16, 1, 1, 
-    "\124\000\000\000\151\100\000\000\152\224\000\000\032\251\100\000"
-    "\032\252\224\000\006\252\251\120\006\252\252\220\001\252\225\120"
-    "\001\252\220\000\000\151\144\000\000\151\031\000\000\031\006\100"
-    "\000\031\001\220\000\025\000\144\000\000\000\031\000\000\000\005" }, 
-  { "top_left_corner", IDC_SIZENWSE, 134, 16, 16, 1, 1, 
-    "\125\125\125\125\152\252\252\251\152\252\252\251\151\125\125\125"
-    "\151\000\000\000\151\025\125\120\151\032\252\220\151\032\125\120"
-    "\151\031\220\000\151\031\144\000\151\031\031\000\151\031\006\100"
-    "\151\031\001\220\151\025\000\120\151\000\000\000\125\000\000\000" }, 
-  { "top_right_corner", IDC_SIZENESW, 136, 16, 16, 14, 1, 
-    "\125\125\125\125\152\252\252\251\152\252\252\251\125\125\125\151"
-    "\000\000\000\151\005\125\124\151\006\252\244\151\005\125\244\151"
-    "\000\006\144\151\000\031\144\151\000\144\144\151\001\220\144\151"
-    "\006\100\144\151\005\000\124\151\000\000\000\151\000\000\000\125" }, 
-  { "top_side", IDC_SIZENS, 138, 15, 16, 7, 1, 
-    "\125\125\125\125\252\252\252\226\252\252\252\125\125\125\125\000"
-    "\006\100\000\000\152\100\000\006\146\100\000\145\226\100\006\106"
-    "\106\100\024\031\005\000\000\144\000\000\001\220\000\000\006\100"
-    "\000\000\031\000\000\000\144\000\000\001\120\000" }, 
-  { "top_tee", NULL, 140, 16, 12, 8, 1, 
-    "\125\125\125\125\152\252\252\251\152\252\252\251\125\126\225\125"
-    "\000\006\220\000\000\006\220\000\000\006\220\000\000\006\220\000"
-    "\000\006\220\000\000\006\220\000\000\006\220\000\000\005\120\000" }, 
-  { "trek", NULL, 142, 9, 16, 4, 0, 
-    "\001\220\000\124\000\152\100\152\244\152\252\132\232\226\252\244"
-    "\152\244\006\244\004\144\106\152\145\246\151\145\226\131\021\226"
-    "\104\145\220\031" }, 
-  { "ul_angle", NULL, 144, 12, 12, 1, 1, 
-    "\125\125\125\152\252\251\152\252\251\151\125\125\151\000\000\151"
-    "\000\000\151\000\000\151\000\000\151\000\000\151\000\000\151\000"
-    "\000\125\000\000" }, 
-  { "umbrella", NULL, 146, 16, 16, 8, 2, 
-    "\001\025\024\124\121\125\125\105\105\225\226\120\025\131\131\225"
-    "\145\226\231\140\131\152\245\225\126\006\102\124\000\006\100\000"
-    "\000\006\100\000\000\006\100\000\000\006\100\000\000\006\124\000"
-    "\000\006\124\000\000\006\144\000\000\006\144\000\000\001\220\000" }, 
-  { "ur_angle", NULL, 148, 12, 12, 10, 1, 
-    "\125\125\125\152\252\251\152\252\251\125\125\151\000\000\151\000"
-    "\000\151\000\000\151\000\000\151\000\000\151\000\000\151\000\000"
-    "\151\000\000\125" }, 
-  { "watch", IDC_WAIT, 150, 16, 16, 15, 9, 
-    "\006\252\251\000\006\252\251\000\006\252\251\000\032\252\252\100"
-    "\151\126\126\220\245\126\125\245\225\126\125\152\225\132\225\152"
-    "\225\132\225\152\225\145\125\152\245\225\125\245\151\125\126\220"
-    "\032\252\252\100\006\252\251\000\006\252\251\000\006\252\251\000" }, 
-  { "xterm", IDC_IBEAM, 152, 9, 16, 4, 8, 
-    "\125\025\132\232\225\152\124\026\120\001\220\000\144\000\031\000"
-    "\006\100\001\220\000\144\000\031\000\006\100\005\224\025\251\126"
-    "\246\245\124\125" }, 
-  { NULL, NULL, 0, 0, 0, 0, 0, NULL },
-};
